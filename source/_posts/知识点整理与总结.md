---
title: 知识点整理与总结
date: 2017-08-08 17:33:58
tags:
---

# 网络文件系统NFS：
* 查看启动rpcbind服务的状态：
	ps -ef|grep rpcbind  
* 修改NFS服务的配置文件：
	sudo vi /etc/exports 
其中中的最后一行为新添加的NFS配置，NFS配置信息格式如下：
<共享目录> [客户端1 选项（访问权限,用户映射,其他）] [客户端2 选项（访问权限,用户映射,其他）]  
如：/home/tos/shareDir 192.168.137.129(rw,no_root_squash,async)
客户端如果是 * ，表示所有主机都可以挂载
<!-- more -->
* 启动服务：
	sudo service nfs-kernel-server start 
	查看运行状态：sudo service nfs-kernel-server status
		ps -ef|grep nfsd

* 查看共享的文件夹和目标主机：
	showmount –e

# 分布式文件系统Ceph：
## Ceph 生态系统架构可以划分为四部分：
1. Clients：客户端（数据用户）
2. cmds：Metadata server cluster，元数据服务器（缓存和同步分布式元数据）
3. cosd：Object storage cluster，对象存储集群（将数据和元数据作为对象存储，执行其他关键职能）
4. cmon：Cluster monitors，集群监视器（执行监视功能）
## 磁盘块映射到元数据：
Linux 透视图中的一个文件会分配到一个来自元数据服务器的 inode number（INO），对于文件这是一个唯一的标识符。然后文件被推入一些对象中（根据文件的大小）。使用 INO 和 object number（ONO），每个对象都分配到一个对象 ID（OID）。在 OID 上使用一个简单的哈希，每个对象都被分配到一个放置组。放置组（标识为 PGID）是一个对象的概念容器。最后，放置组到对象存储设备（OSD）的映射是一个伪随机映射，使用一个叫做 Controlled Replication Under Scalable Hashing（CRUSH）的算法。这样一来，放置组（以及副本）到存储设备的映射就不用依赖任何元数据，而是依赖一个伪随机的映射函数。这种操作是理想的，因为它把存储的开销最小化，简化了分配和数据查询。
## 元数据服务器主要应用就是一个智能元数据缓存；元数据服务器管理 inode 空间，将文件名转变为元数据
4. 从存储角度来看，Ceph 对象存储设备执行从对象到块的映射
5. 对于objects storage和block storage,不需要元数据服务器。
6. 组件：
	MDS
	Monitor
	OSD：一个CEPH存储集群，要求至少两个CEPH OSDs，才能有效的保存两份数据。注意，这里的两个CEPH OSD是指运行在两台物理服务器上的，并不是在一台物理服务器上开两个CEPH OSD的守护进程。
	RADOS
	Gateway
7. 映射

	这种数据映射的优点：
把Object分成组，这降低了需要追踪和处理metadata的数量(在全局的层面上，我们不需要追踪和处理每个object的metadata和placement，只需要管理PG的metadata就可以了。PG的数量级远远低于object的数量级)。
增加PG的数量可以均衡每个OSD的负载，提高并行度。
分隔故障域，提高数据的可靠性。
## 强一致性

# Docker
## 1.Docker 使用客户端-服务器 (C/S) 架构模式。
## 2.要理解 Docker 内部构建，需要理解以下三种部件：
* Docker 镜像 - Docker images  ：Docker 容器运行时的只读模板
* Docker 仓库 - Docker registries   ：用来保存镜像
* Docker 容器 - Docker containers  ：和文件夹很类似，一个Docker容器包含了所有的某个应用运行所需要的环境
## 3.Docker架构：

* 1).libcontainer：正是由于libcontainer的存在，Docker可以直接调用libcontainer，而最终操纵容器的namespace、cgroups、apparmor、网络设备以及防火墙规则等。这一系列操作的完成都不需要依赖LXC或者其他包。
* 2). docker pull命令的作用为：从Docker Registry中下载指定的容器镜像，并存储在本地的Graph中，以备后续创建Docker容器时的使用。
名为"pull"的job在执行过程中，执行pullRepository操作，即从Docker Registry中下载相应的一个或者多个image；
* 3). docker run命令的作用是在一个全新的Docker容器内部运行一条指令。Docker在执行这条命令的时候，所做工作可以分为两部分：第一，创建Docker容器所需的rootfs；第二，创建容器的网络等运行环境，并真正运行用户指令。




## 4. An image is a filesystem and parameters to use at runtime.

# 错误解决办法：
## 1.提示#include<sys/types.h> 找不到sys/types.h   : 
更新go语言包到版本1.8

## 2.提示在gfapi.h中找不到glfs_fallocate()方法    : 
更新glusterfs版本到3.8

## 3.Package uuid was not found in the pkg-config search path.Perhaps you should add the directory containing `uuid.pc' to the PKG_CONFIG_PATH environment variable .Package 'uuid', required by 'glusterfs-api', not found   : 
执行:sudo apt-get install uuid-dev   
## 4.fatal error: sys/acl.h: No such file or directory   
执行：  sudo apt-get install uuid-dev libacl1-dev liblzo2-dev

## 5.apt-get update的时候如果出现hash校验失败
可以尝试使用apt-get update --fix-missing来解决；也可以试试sudo apt-get upgrade来升级软件包

## 6.出现connection failed check if gluster deamon is running ：
执行：
```
rm -fR /var/log/glusterfs/*
rm -rf /var/lib/glusterd/*
```
直接卸载重装：
```
	sudo apt-get remove glusterfs-common
	sudo add-apt-repository ppa:gluster/glusterfs-3.8
	sudo apt-get update
	sudo apt-get install glusterfs-server
```

## 7.安装glusterfs3.8：
```
	sudo add-apt-repository ppa:gluster/glusterfs-3.8
	sudo apt-get update
	sudo apt-get install glusterfs-server
```

## 8.git add的时候拼命地提示：
尚未暂存以备提交的变更：
  （使用 "git add <文件>..." 更新要提交的内容）
  （使用 "git checkout -- <文件>..." 丢弃工作区的改动）
  （提交或丢弃子模组中未跟踪或修改的内容）

	这是因为这个主题是用git clone下来的,说白了,也是一个git 仓库…
可以cd到该目录下,删掉.git文件夹,结束git的控制
然后就可以了
	
## 9.glusterfs删除某个brick：
```
sudo gluster volume remove-brick datapoint replica 1 n103:/mnt/glustermac force
```

## 10.在一台机器上创建replica=2的卷：
```
sudo gluster volume create datapoint replica 2 transport tcp n103:/mnt/gluster n103:/mnt/glustermac force
```

## 11.安装docker 
如果之前装过docker则sudo apt-get remove docker docker-engine
```
sudo apt-get update
sudo apt-get install \
    linux-image-extra-$(uname -r) \
    linux-image-extra-virtual
sudo apt-get install \
    apt-transport-https \
    ca-certificates \
    curl \
    software-properties-common
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
sudo add-apt-repository \
   "deb [arch=amd64] https://download.docker.com/linux/ubuntu \
   $(lsb_release -cs) \
   stable"
sudo apt-get update
sudo apt-get install docker-ce
```
	
## 12.将用户加入docker group中，使用docker时不用加sudo：
```
sudo groupadd docker
sudo gpasswd -a ${USER} docker
sudo service docker restart
```
注销登录后生效
	
## 13.往registry push镜像时，time.Parse()方法出错：parsing time "2017-04-22T07:30:42Z": extra text:
解决办法：见问题15
## 14.registry的存储结构：

blobs下面存储了registry的所有基本信息元素（镜像实际内容）

digest是基于内容寻址算法算出来的一串hash值

_layers是跟这个镜像有关的所有镜像层

_manifest是镜像的相关信息

revisions里面是该镜像所有可用的镜像digest，下面一个link指向blobs里面对应的digest。可以想象，同一个镜像名可以有多个不同的tag，所以revision目录下也会有多个digest指向不同的镜像digest。比如：将Ubuntu镜像tag成ubuntu:v0.1 ，将hello-world  tag成ubuntu:v0.2，这样他们两个虽然都是名为ubuntu的镜像，但是他们的内容却完全不同，所以digest也不同，因此revision下面会有多个digest

## 15.将一个[]byte数组p直接用string(p)转化为string后是有问题的
string的结构体是这样的：
```
struct String
{
	byte* str;
	intgo len;
}
```
golang里面string的概念不是以前遇到\0结尾的概念，他是一块连续的内存，首地址+长度，上面那样赋值，如果p里面有\0，他不会做结尾的处理。这个时候如果对这个string做其他操作，如time.parse(),strconv.Atoi()等就会出错，解决办法是自己写一个正规的转换函数。
```
func byteString(p []byte) string {
        for i := 0; i < len(p); i++ {
                if p[i] == 0 {
                        return string(p[0:i])
                }
        }
        return string(p)
}
```

## 16.Docker-Error response from daemon:client is newer than server 
方法一：在client端的环境变量中指定旧的API版本来解决：export DOCKER_API_VERSION=<version>
方法二（推荐）：重启Docker服务：sudo service docker restart

## 17.git删除本地已修改但未提交的文件：
如果未加入暂存区：git checkout . && git clean –xdf
如果已加入暂存区：git reset –hard    ;    git clean -xdf

## 18.使用Dockerfile生成镜像时，底层如果是alpine，如果提示pkg-config: exec: "pkg-config": executable file not found in $PATH 
表明alpine系统缺少pkg-config包，则在Dockerfile中加入 RUN apk add --update alpine-sdk 安装alpine系统相关包

## 19.使用Dockerfile生成镜像时，底层使用gluster/gluster-centos，如果提示Package glusterfs-api was not found in the pkg-config search path. 
表明pak-config里面缺少glusterfs-api包，安装即可，命令如下 yum -y install glusterfs-api-devel

## 20.遇到docker daemon不能启动
检查/etc/docker/daemon.json有没有问题，删除该文件也可以。执行sudo service docker restart启动daemon

## 21.安装docker-compose 
使用pip安装 sudo pip install docker-compose

## 22.docker login时遇到Error response from daemon: getsockopt: connection refused问题
在/etc/default/docker文件中加入：
DOCKER_OPTS="--insecure-registry 10.0.40.16:5000"

## 23.系统如果缺少依赖，执行
sudo apt-get update
sudo apt-get install -f

## 24.配置harbor时，如果在docker login的时候出现错误：Error responsefrom daemon: Get https://xx.xxx.xx.xx/v1/users/: dial tcp xx.xxx.xx.xx:443:getsockopt: connection refused
表明registry的端口5000没有映射出来，则在docker-compose.yml文件中添加registry的端口映射，如：
 registry:
    image: vmware/registry:photon-2.6.0
    container_name: registry
    restart: always
    volumes:
      - /data/registry:/storage:z
      - ./common/config/registry/:/etc/registry/:z
==    ports:
     - 5000:5000==
    networks:
      - harbor
    environment:
      - GODEBUG=netdns=cgo
    command:
      ["serve", "/etc/registry/config.yml"]
    depends_on:
      - log
    logging:
      driver: "syslog"
      options:  
        syslog-address: "tcp://127.0.0.1:1514"
        tag: "registry"
## 25.手动释放Ubuntu系统占用的内存
通过调整/proc/sys/vm/drop_caches来释放内存
echo 3 > /proc/sys/vm/drop_caches