---
title: 经典算法
date: 2018-03-07 20:10:43
tags: [algorithm, A* algorithm]
---

## A* Algorithm
该算法是一个求最短路径的算法，同Dijkstra算法类似，起始点到终点的距离f(M) = g(M) + h(M)，g(M)表示从起始点S走到M点的距离，h(M)表示从M点到终点的估计距离。算法的关键在h的估计上，可以采用欧氏距离、曼哈顿距离等距离度量方式。在采用特定的距离度量方式估计h(M)的值后，计算f(M)的值，并对f(M)的值进行排序，找到最小的f(M)对应的那个节点作为下一个节点。
与Dijkstra算法不同的是，Dijkstra算法是从未走过的节点中找到一个距离已走过的节点最近的节点作为下一个节点，如果A\*算法不对f(M)进行排序，则跟Dijkstra算法类似，只是比Dijkstra多计算一个估计值。如果h=0，则A\*算法类似于BFS算法，即不考虑终点，只考虑起始点，但可以保证给出最优解；如果g=0，s则A*算法类似于DFS，即不考虑起始点，一根筋的找离终点最近的下一个节点走，这样可能不会给出最优解。

<!--more-->

## Fibonacci堆
1. Fibonacci堆采用双向循环链表；
2. 去除最小节点后，将该节点的所有子节点都串联到根表中，然后将根表中度数相同的子树合并，直至没有度数相同的子树。
3. 在合并根表中相同度数的子树时，注意孩子节点的值要比父节点的值要小，这样才能保证Fibonacci堆中的最小值始终在根节点上。
4. 节点值减小：如果破坏了最小堆性质，则需要重新维护最小堆。首先将值减小的节点及其子树从堆中拿出来，然后将其并到根链表中；然后再从"被切节点的父节点"到所在树根节点递归执行级联剪枝。
5. 节点值增大：将值增大的节点的孩子添加到根链表中，如果值增大的节点不在根链表中，则将其也加入根链表中。然后对其父节点进行级联剪切；如果没有父节点，则判断是否需要更新堆得最小值。
6. 级联剪切的真正目的是为了防止"最小堆"由二叉树演化成链表。

## 装箱问题
tabu 搜索，模拟退火，领域搜索，GRASP算法

## 基本知识
一般5,000,000次循环用时在1s左右

### STL
#### 二分搜索
- lower_bound(<T> *begin, <T> *end, <T> key)：返回第一个不小于key的元素在数组中的位置
- binary_search
- upper_bound

#### 排序
- algotithm包里面sort(v.begin(), v.end())采用快排，快排不稳定；stable_sort采用归并排序，是稳定的，不过归并排序会产生额外的内存开销，时间复杂度虽然也是O(nlogn)，但会比快排稍慢。

#### set
set里元素不重复，由二叉搜索树实现，并且对树进行了平衡处理，使得元素在树中分布较为均匀，可以保证搜索、插入和删除的复杂度在O(logn)。