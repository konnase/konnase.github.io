<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo搭建个人博客并保存环境</title>
    <url>/2018/01/04/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E4%BF%9D%E5%AD%98%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h2 id="hexo搭建个人博客并保存环境"><a href="#hexo搭建个人博客并保存环境" class="headerlink" title="hexo搭建个人博客并保存环境"></a>hexo搭建个人博客并保存环境</h2><p>搭建过程可以参考网上一篇教程：<a href="https://www.jianshu.com/p/17d32db14aa6">Mac上搭建hexo</a></p>
<p>按照以上博客的配置，即可将个人博客搭建好，如果你想要将博客的环境保存下来，下次换台机器后还能继续使用之前配置的环境的话，可以在blog文件夹下新建一个git仓库(git init)，将该仓库托管到github上的某一个仓库里（我是将blog文件夹下的全部文件托管在github中博客所在仓库的hexo分支上），每次重新搭建环境的时候只需要从该分支拉取下来所有的环境信息即可在原来的基础上开始写新的博客。</p>
<p>在执行完：<code>node install -g hexo</code>后，不要执行<code>hexo init</code>，进入到blog文件夹，执行<code>git init</code>，创建git仓库，执行<code>git remote add origin git@github.com:konnase/konnase.github.io.git</code>添加原来的环境所在的远程git仓库，执行<code>git pull origin hexo:master</code>将远程的仓库拉取到本地，执行<code>npm install</code>安装hexo相关环境。到此，即可无缝使用原来的hexo环境了。</p>
<p>next主题的_config.yml文件复制到source/_data/next.yml，方便保存配置信息，因为next主题我是不会提交到git仓库中去保存的。</p>
<h3 id="next主题使用latex"><a href="#next主题使用latex" class="headerlink" title="next主题使用latex"></a>next主题使用latex</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo npm uninstall hexo-renderer-marked</span><br><span class="line">sudo npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>
<p>修改node_modules/kramed/lib/rules/inline.js下面的两行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inline = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">escape</span>: <span class="regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span>,</span><br><span class="line">    em: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>shadowsocks 搭建</title>
    <url>/2018/01/04/shadowsocks-%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="switchyOmega-shadowsocks-chrome科学上网"><a href="#switchyOmega-shadowsocks-chrome科学上网" class="headerlink" title="switchyOmega+shadowsocks+chrome科学上网"></a>switchyOmega+shadowsocks+chrome科学上网</h2><p>使用ssr客户端，配置服务器信息后代理规则选择全局<br><img src="/img/proxy_rule.png" alt="image"></p>
<span id="more"></span>
<p>系统代理设置为直连模式<br><img src="/img/system_proxy.png" alt="image"><br>打开选项设置，确保本地为1080<br><img src="/img/localport.png" alt="image"><br>进入chrome，安装SwitchyOmega（安装方法请另行搜索）。修改proxy情景模式（也可新建一个情景模式），代理协议http，服务器127.0.0.1，端口1080（注意此处与ssr客户端设置的端口保持一致）<br><img src="/img/changesituation.png" alt="image"><br>点击应用选项<br>切换到autoswitch，删除原先设置的条件（没有则忽略）。选中规则列表股则，下拉框选择刚更改的proxy。在规则列表格式处选择AutoProxy，并复制 <a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</a> 到规则列表网址中，点击立即更新情景模式，随后将自动更新情景模式<br><img src="/img/autoswitch.png" alt="image"><br>最后一步，点击switchyOmega，选择auto switch<br><img src="/img/chooseautoswitch.png" alt="image"><br>完事儿后，浏览Google，即可正常访问，速度较采用全局模式和pac模式要快很多，而且只是chrome走本地1080端口代理上网，其他应用均采用直连方式。</p>
<p>有时候连接不上，可以修改ssr配置文件中的timeout的值，将其调大一点，因为一旦连接延时较高，超过设置的timeout值，服务器将不能连接上。</p>
]]></content>
      <categories>
        <category>System</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
        <tag>switchyomege</tag>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>四大联赛数据分析</title>
    <url>/2017/12/24/%E5%9B%9B%E5%A4%A7%E8%81%94%E8%B5%9B%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">shoot = &#123;</span><br><span class="line">    <span class="string">&#x27;italy&#x27;</span>: [<span class="number">119</span>, <span class="number">74</span>, <span class="number">71</span>, <span class="number">68</span>, <span class="number">65</span>, <span class="number">61</span>, <span class="number">58</span>, <span class="number">56</span>, <span class="number">55</span>, <span class="number">51</span>],</span><br><span class="line">    <span class="string">&#x27;spain&#x27;</span>: [<span class="number">56</span>, <span class="number">46</span>, <span class="number">42</span>, <span class="number">39</span>, <span class="number">37</span>, <span class="number">36</span>, <span class="number">35</span>, <span class="number">33</span>, <span class="number">33</span>, <span class="number">32</span>],</span><br><span class="line">    <span class="string">&#x27;england&#x27;</span>: [<span class="number">64</span>, <span class="number">61</span>, <span class="number">55</span>, <span class="number">53</span>, <span class="number">53</span>, <span class="number">47</span>, <span class="number">44</span>, <span class="number">44</span>, <span class="number">43</span>, <span class="number">42</span>],</span><br><span class="line">    <span class="string">&#x27;germany&#x27;</span>: [<span class="number">63</span>, <span class="number">62</span>, <span class="number">49</span>, <span class="number">48</span>, <span class="number">47</span>, <span class="number">46</span>, <span class="number">44</span>, <span class="number">44</span>, <span class="number">44</span>, <span class="number">41</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goal = &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;italy&#x27;</span>: [<span class="number">13</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">7</span>],</span><br><span class="line">    <span class="string">&#x27;spain&#x27;</span>: [<span class="number">15</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">7</span>],</span><br><span class="line">    <span class="string">&#x27;england&#x27;</span>: [<span class="number">12</span>, <span class="number">11</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>],</span><br><span class="line">    <span class="string">&#x27;germany&#x27;</span>: [<span class="number">12</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shoot_leader = &#123;</span><br><span class="line">    <span class="string">&#x27;Cristiano Ronaldo&#x27;</span>: (<span class="number">1</span>, <span class="number">119</span>),</span><br><span class="line">    <span class="string">&#x27;Werner&#x27;</span>: (<span class="number">1</span>, <span class="number">63</span>),</span><br><span class="line">    <span class="string">&#x27;Messi&#x27;</span>: (<span class="number">1</span>, <span class="number">56</span>),</span><br><span class="line">    <span class="string">&#x27;Salah&#x27;</span>: (<span class="number">1</span>, <span class="number">64</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goal_leader = &#123;</span><br><span class="line">    <span class="string">&#x27;Aubameyang&#x27;</span>: (<span class="number">1</span>, <span class="number">12</span>),</span><br><span class="line">    <span class="string">&#x27;Messi&#x27;</span>: (<span class="number">1</span>, <span class="number">15</span>),</span><br><span class="line">    <span class="string">&#x27;Pia Turk&#x27;</span>: (<span class="number">1</span>, <span class="number">13</span>),</span><br><span class="line">    <span class="string">&#x27;Iovich&#x27;</span>: (<span class="number">1</span>, <span class="number">12</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x = [i + <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">df = pd.DataFrame(shoot, x)</span><br><span class="line">ax = df.plot()</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> shoot_leader.items():</span><br><span class="line">    plt.annotate(key, value)</span><br><span class="line">plt.title(<span class="string">&quot;Top 10 shoot times distribution of 4 leagues&quot;</span>)</span><br><span class="line"></span><br><span class="line">df_goal = pd.DataFrame(goal, x)</span><br><span class="line">df_goal.plot()</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> goal_leader.items():</span><br><span class="line">    plt.annotate(key, value)</span><br><span class="line">plt.title(<span class="string">&quot;Top 10 goal distribution of 4 leagues&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>截图<br><img src="/img/goal.png" alt="goal"><br><img src="/img/shoot_times.png" alt="shoot times"></p>
]]></content>
  </entry>
  <entry>
    <title>实习面经</title>
    <url>/2019/06/16/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>实习面试从三月份持续到五月份，一开始接受了腾讯的offer，后来去了阿里。从一开始面试头条备受打击，到后来得到满意的offer是一段很有价值的体验。</p>
<h1 id="头条"><a href="#头条" class="headerlink" title="头条"></a>头条</h1><h2 id="头条一面"><a href="#头条一面" class="headerlink" title="头条一面"></a>头条一面</h2><p>首先问了我的研究方向，吧啦吧啦讲了一大堆。接着问我k8s的scheduler实现，讲了过滤打分机制，这块内容不是特别清楚，接着问了docker的隔离和资源限制。问docker的启动流程的时候就懵了，不清楚具体的启动流程。后面给了道算法题：给定一段含有注释的c++代码，去掉注释，也没有顺利写出来。。<br>最后问CPU是怎么调度的、内存是怎么分配给进程的，都答得不好，卒。。</p>
<h2 id="头条二面"><a href="#头条二面" class="headerlink" title="头条二面"></a>头条二面</h2><p>哦，没有二面。。</p>
<h1 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h1><h2 id="阿里一面"><a href="#阿里一面" class="headerlink" title="阿里一面"></a>阿里一面</h2><p>主要是问简历上的东西。顺便问了下k8s service在底层怎么实现的（iptables），dockerfile和image的区别与联系。</p>
<h2 id="阿里二面"><a href="#阿里二面" class="headerlink" title="阿里二面"></a>阿里二面</h2><p>笔试面。是搞混部的阿里韩堂面的，给了一道题目，top k的题目，恰巧前几天做过。。写了个快排思想的解题思路</p>
<h2 id="阿里三面"><a href="#阿里三面" class="headerlink" title="阿里三面"></a>阿里三面</h2><p>李响大佬面的。开始聊了聊项目，慢慢聊起了gang scheduling，然后扯了一通。考虑集群中共有5个资源，有3个已经被占用了；此时job n申请3个资源，在gang scheduling的逻辑里面应该怎么做？最后问了在浏览器敲<a href="http://www.google.com会发生什么？从键盘输入到系统调用，到DNS，到tcp连接整个过程。">www.google.com会发生什么？从键盘输入到系统调用，到DNS，到tcp连接整个过程。</a></p>
<h2 id="阿里四面"><a href="#阿里四面" class="headerlink" title="阿里四面"></a>阿里四面</h2><p>交叉面。感觉也是问简历上的东西。。</p>
<h2 id="阿里五面"><a href="#阿里五面" class="headerlink" title="阿里五面"></a>阿里五面</h2><p>HR面。就是大是大非的问题，然后我问了下双十一的筹备工作，HR跟我说我有机会来感受的，也就是拿到offer了？</p>
<p>过了好长一段时间才收到阿里的意向书，最终还是选择了阿里。</p>
<h1 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h1><h2 id="腾讯一面"><a href="#腾讯一面" class="headerlink" title="腾讯一面"></a>腾讯一面</h2><p>一开始聊项目。</p>
<ul>
<li>python的深拷贝和浅拷贝</li>
<li>python的内存管理</li>
<li>多线程</li>
<li>多线程死锁怎么定位与调试？</li>
</ul>
<p>然后问了操作系统死锁的概念跟哲学家就餐问题。一些数据结构问题，二叉树的三种遍历，以及跟dfs、bfs的区别联系</p>
]]></content>
  </entry>
  <entry>
    <title>数据降维算法</title>
    <url>/2018/04/12/%E6%95%B0%E6%8D%AE%E9%99%8D%E7%BB%B4%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

<h1 id="如何实现降维"><a href="#如何实现降维" class="headerlink" title="如何实现降维"></a>如何实现降维</h1><h2 id="PCA（主成分分析）"><a href="#PCA（主成分分析）" class="headerlink" title="PCA（主成分分析）"></a>PCA（主成分分析）</h2><p>PCA可以把可能具有相关性的高维变量合成线性无关的低维变量，称合成后的低维变量为主成分。主成分可以代替原来的高维变量很好的反映数据的分布，而且减少了无关的变量。</p>
<p>不严格地说，主成分可以看做一组特征向量。通过计算数据集中两两变量之间的协方差得到的协方差距阵，再对协方差矩阵求特征值和特征向量，按照特征值的大小排序得到一组特征向量U，确定主成分的个数m(m&lt;d)，从U中按特征值大小从大到小取m个特征向量，这m个特征向量对应的属性个数即构成了降维后的数据空间维度的大小。</p>
<p>PCA降维的步骤：</p>
<ul>
<li>求样本数据（d维，n个样本）对应的每个变量X的均值，并将所有的样例都减去对应的均值。数据中心化的过程。</li>
<li>计算协方差矩阵</li>
<li>求协方差矩阵对应的特征值和特征向量。</li>
<li>将特征值按照从大到小的顺序排列，选择其中的m的特征值，并将对应的m个特征向量作为列向量组成变换矩阵。</li>
<li>用原来的d维的样本数据乘以变换矩阵即得到降维后n x m的矩阵，维度从d维降到m维。</li>
</ul>
<span id="more"></span>

<h2 id="LDA（线性判别分析）"><a href="#LDA（线性判别分析）" class="headerlink" title="LDA（线性判别分析）"></a>LDA（线性判别分析）</h2><p>先讲一个与降维无关的知识–隐含狄利克雷分布(Latent Dirichlet Allocation)，这是看线性判别分析时无意中看到的。</p>
<h3 id="隐含狄利克雷分布"><a href="#隐含狄利克雷分布" class="headerlink" title="隐含狄利克雷分布"></a>隐含狄利克雷分布</h3><p>主要思想是根据一篇给定的文档，推测其主题分布。</p>
<ul>
<li><p>考虑人类是怎么生成一篇文档的</p>
<ul>
<li>先确定这篇文章的几个主题，然后围绕着这几个主题遣词造句，表达成文。</li>
</ul>
</li>
<li><p>考虑机器应该怎么生成一篇文档</p>
<p>计算机在生成文档前，会先划分主题，生成主题分布；对于每一个主题，又有相应的词分布。</p>
<ul>
<li>按照先验概率选择一篇文档</li>
<li>从狄利克雷分布（即Dirichlet分布）中取样生成文档的主题分布，换言之，主题分布由超参数为的Dirichlet分布生成</li>
<li>从主题的多项式分布中取样生成文档第j个词的主题</li>
<li>从狄利克雷分布（即Dirichlet分布）中取样生成主题对应的词语分布，换言之，词语分布由参数为的Dirichlet分布生成</li>
<li>从词语的多项式分布中采样最终生成词语</li>
<li>重复以上过程，完成一篇文档</li>
</ul>
</li>
</ul>
<p>LDA是基于贝叶斯框架，认为主题分布和词分布不是唯一确定的，而是随机变量。这种思想与频率派的思想截然相反，后者认为这两种分布应该是确定的，而样本空间是不确定的。</p>
<ul>
<li>如何从已经产生的文档中反推主题分布<ul>
<li>需要估计“主题-词项”矩阵Φ和“文档-主题”矩阵Θ，使用变分-EM算法或者Gibbs采样进行估计。</li>
<li>根据大量已知的文档-词项信息，训练出文档-主题矩阵和主题-词项矩阵</li>
<li>将文档中的词项使用矩阵Φ和矩阵Θ得出文档主题。</li>
</ul>
</li>
</ul>
<h3 id="线性判别分析"><a href="#线性判别分析" class="headerlink" title="线性判别分析"></a>线性判别分析</h3><p>利用LDA对数据进行降维操作，考虑到了样本类别，是一种典型的监督降维技术。LDA考虑的重点是使投影后的样本在新的空间上需要有最大的类间距离和最小的类内距离。度量类间距离常用的方法是使用投影后两个类别的均值点之间的距离；度量类内距离常用的方法是使用投影后同一类别之间的数据的方差。用类间距离比上类内距离得：<br>$$J(w)=\frac{w^T S_b w}{w^T S_w w}$$<br>最大化J(w)就能同时最大化类间距离和最小化类内距离。其中\(S_b\)表示类间散度矩阵，\(S_w\)表示类内散度矩阵。使用广义特征值问题求解得：<br>$$S_w^{-1}S_bw = \lambda w$$<br>求解\(S_w^{-1}S_b\)的特征值和特征向量，然后如同PCA一样将原始数据降到m维。</p>
<h2 id="NCA（近邻成分分析）"><a href="#NCA（近邻成分分析）" class="headerlink" title="NCA（近邻成分分析）"></a>NCA（近邻成分分析）</h2><p>NCA是度量学习中经常使用的方法，通过学习一个度量矩阵M来度量样本集中两两样例之间的距离。一般采用梯度下降的方法来拟合度量矩阵M。当M是一个低秩矩阵的时候，可以通过对M进行特征值分解，找到一组正交基，这一组正交基可以组成一个变换矩阵P，P中正交基的数目为矩阵M的秩r，显然r&lt;d（d为原属性数）。则变换矩阵P可用于降维。</p>
<h2 id="三种降维方法的对比"><a href="#三种降维方法的对比" class="headerlink" title="三种降维方法的对比"></a>三种降维方法的对比</h2><p>PCA是不考虑样本类别输出的无监督降维技术。它主要考察的是数据在投影到新的样本空间后数据之间的方差最大，即投影后的数据的离散程度最高。而不同于PCA的是，LDA在进行投影的时候还考虑到原始样本的类别，而且LDA还假设某一类别的类条件概率密度函数是均值不同、方差相同的高斯分布。LDA是一种监督降维技术。NCA学习出来的降维矩阵P没有复杂的矩阵运算（计算协方差），也无需对样本空间分布进行特定的假设。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] 周志华. 机器学习 : = Machine learning[M]. 清华大学出版社, 2016.<br>[2] <a href="https://blog.csdn.net/HLBoy_happy/article/details/77146012lda">https://blog.csdn.net/HLBoy_happy/article/details/77146012lda</a><br>[3] <a href="https://zhuanlan.zhihu.com/p/27899927?group_id=869893271453863936">https://zhuanlan.zhihu.com/p/27899927?group_id=869893271453863936</a></p>
]]></content>
      <tags>
        <tag>pca</tag>
        <tag>nca</tag>
        <tag>lda</tag>
        <tag>data reduction</tag>
      </tags>
  </entry>
  <entry>
    <title>知识点整理与总结</title>
    <url>/2017/08/08/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%E4%B8%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="网络文件系统NFS："><a href="#网络文件系统NFS：" class="headerlink" title="网络文件系统NFS："></a>网络文件系统NFS：</h1><ul>
<li><p>查看启动rpcbind服务的状态：<br>  ps -ef|grep rpcbind  </p>
</li>
<li><p>修改NFS服务的配置文件：<br>  sudo vi /etc/exports <br>其中中的最后一行为新添加的NFS配置，NFS配置信息格式如下：<br>&lt;共享目录&gt; [客户端1 选项（访问权限,用户映射,其他）] [客户端2 选项（访问权限,用户映射,其他）]  <br>如：/home/tos/shareDir 192.168.137.129(rw,no_root_squash,async)<br>客户端如果是 * ，表示所有主机都可以挂载</p>
<span id="more"></span></li>
<li><p>启动服务：<br>  sudo service nfs-kernel-server start <br>  查看运行状态：sudo service nfs-kernel-server status</p>
<pre><code>  ps -ef|grep nfsd
</code></pre>
</li>
<li><p>查看共享的文件夹和目标主机：<br>  showmount –e</p>
</li>
</ul>
<h1 id="分布式文件系统Ceph："><a href="#分布式文件系统Ceph：" class="headerlink" title="分布式文件系统Ceph："></a>分布式文件系统Ceph：</h1><h2 id="Ceph-生态系统架构可以划分为四部分："><a href="#Ceph-生态系统架构可以划分为四部分：" class="headerlink" title="Ceph 生态系统架构可以划分为四部分："></a>Ceph 生态系统架构可以划分为四部分：</h2><ol>
<li>Clients：客户端（数据用户）</li>
<li>cmds：Metadata server cluster，元数据服务器（缓存和同步分布式元数据）</li>
<li>cosd：Object storage cluster，对象存储集群（将数据和元数据作为对象存储，执行其他关键职能）</li>
<li>cmon：Cluster monitors，集群监视器（执行监视功能）</li>
</ol>
<h2 id="磁盘块映射到元数据："><a href="#磁盘块映射到元数据：" class="headerlink" title="磁盘块映射到元数据："></a>磁盘块映射到元数据：</h2><p>Linux 透视图中的一个文件会分配到一个来自元数据服务器的 inode number（INO），对于文件这是一个唯一的标识符。然后文件被推入一些对象中（根据文件的大小）。使用 INO 和 object number（ONO），每个对象都分配到一个对象 ID（OID）。在 OID 上使用一个简单的哈希，每个对象都被分配到一个放置组。放置组（标识为 PGID）是一个对象的概念容器。最后，放置组到对象存储设备（OSD）的映射是一个伪随机映射，使用一个叫做 Controlled Replication Under Scalable Hashing（CRUSH）的算法。这样一来，放置组（以及副本）到存储设备的映射就不用依赖任何元数据，而是依赖一个伪随机的映射函数。这种操作是理想的，因为它把存储的开销最小化，简化了分配和数据查询。</p>
<h2 id="元数据服务器主要应用就是一个智能元数据缓存；元数据服务器管理-inode-空间，将文件名转变为元数据"><a href="#元数据服务器主要应用就是一个智能元数据缓存；元数据服务器管理-inode-空间，将文件名转变为元数据" class="headerlink" title="元数据服务器主要应用就是一个智能元数据缓存；元数据服务器管理 inode 空间，将文件名转变为元数据"></a>元数据服务器主要应用就是一个智能元数据缓存；元数据服务器管理 inode 空间，将文件名转变为元数据</h2><h2 id="从存储角度来看，Ceph-对象存储设备执行从对象到块的映射"><a href="#从存储角度来看，Ceph-对象存储设备执行从对象到块的映射" class="headerlink" title="从存储角度来看，Ceph 对象存储设备执行从对象到块的映射"></a>从存储角度来看，Ceph 对象存储设备执行从对象到块的映射</h2><h2 id="对于objects-storage和block-storage-不需要元数据服务器。"><a href="#对于objects-storage和block-storage-不需要元数据服务器。" class="headerlink" title="对于objects storage和block storage,不需要元数据服务器。"></a>对于objects storage和block storage,不需要元数据服务器。</h2><h2 id="组件："><a href="#组件：" class="headerlink" title="组件："></a>组件：</h2><pre><code>MDS
Monitor
OSD：一个CEPH存储集群，要求至少两个CEPH OSDs，才能有效的保存两份数据。注意，这里的两个CEPH OSD是指运行在两台物理服务器上的，并不是在一台物理服务器上开两个CEPH OSD的守护进程。
RADOS
Gateway
</code></pre>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><pre><code>这种数据映射的优点：
</code></pre>
<p>把Object分成组，这降低了需要追踪和处理metadata的数量(在全局的层面上，我们不需要追踪和处理每个object的metadata和placement，只需要管理PG的metadata就可以了。PG的数量级远远低于object的数量级)。<br>增加PG的数量可以均衡每个OSD的负载，提高并行度。<br>分隔故障域，提高数据的可靠性。</p>
<h2 id="强一致性"><a href="#强一致性" class="headerlink" title="强一致性"></a>强一致性</h2><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="Docker-使用客户端-服务器-C-S-架构模式。"><a href="#Docker-使用客户端-服务器-C-S-架构模式。" class="headerlink" title="Docker 使用客户端-服务器 (C/S) 架构模式。"></a>Docker 使用客户端-服务器 (C/S) 架构模式。</h2><h2 id="要理解-Docker-内部构建，需要理解以下三种部件："><a href="#要理解-Docker-内部构建，需要理解以下三种部件：" class="headerlink" title="要理解 Docker 内部构建，需要理解以下三种部件："></a>要理解 Docker 内部构建，需要理解以下三种部件：</h2><ul>
<li><p>Docker 镜像 - Docker images  ：Docker 容器运行时的只读模板</p>
</li>
<li><p>Docker 仓库 - Docker registries   ：用来保存镜像</p>
</li>
<li><p>Docker 容器 - Docker containers  ：和文件夹很类似，一个Docker容器包含了所有的某个应用运行所需要的环境</p>
<h2 id="Docker架构："><a href="#Docker架构：" class="headerlink" title="Docker架构："></a>Docker架构：</h2></li>
<li><p>1).libcontainer：正是由于libcontainer的存在，Docker可以直接调用libcontainer，而最终操纵容器的namespace、cgroups、apparmor、网络设备以及防火墙规则等。这一系列操作的完成都不需要依赖LXC或者其他包。</p>
</li>
<li><p>2). docker pull命令的作用为：从Docker Registry中下载指定的容器镜像，并存储在本地的Graph中，以备后续创建Docker容器时的使用。<br>名为”pull”的job在执行过程中，执行pullRepository操作，即从Docker Registry中下载相应的一个或者多个image；</p>
</li>
<li><p>3). docker run命令的作用是在一个全新的Docker容器内部运行一条指令。Docker在执行这条命令的时候，所做工作可以分为两部分：第一，创建Docker容器所需的rootfs；第二，创建容器的网络等运行环境，并真正运行用户指令。</p>
</li>
</ul>
<h2 id="An-image-is-a-filesystem-and-parameters-to-use-at-runtime"><a href="#An-image-is-a-filesystem-and-parameters-to-use-at-runtime" class="headerlink" title="An image is a filesystem and parameters to use at runtime."></a>An image is a filesystem and parameters to use at runtime.</h2><h1 id="错误解决办法："><a href="#错误解决办法：" class="headerlink" title="错误解决办法："></a>错误解决办法：</h1><h2 id="提示-include-lt-sys-types-h-gt-找不到sys-types-h"><a href="#提示-include-lt-sys-types-h-gt-找不到sys-types-h" class="headerlink" title="提示#include&lt;sys/types.h&gt; 找不到sys/types.h   :"></a>提示#include&lt;sys/types.h&gt; 找不到sys/types.h   :</h2><p>更新go语言包到版本1.8</p>
<h2 id="提示在gfapi-h中找不到glfs-fallocate-方法"><a href="#提示在gfapi-h中找不到glfs-fallocate-方法" class="headerlink" title="提示在gfapi.h中找不到glfs_fallocate()方法    :"></a>提示在gfapi.h中找不到glfs_fallocate()方法    :</h2><p>更新glusterfs版本到3.8</p>
<h2 id="Package-uuid-was-not-found-in-the-pkg-config-search-path-Perhaps-you-should-add-the-directory-containing-uuid-pc’-to-the-PKG-CONFIG-PATH-environment-variable-Package-‘uuid’-required-by-‘glusterfs-api’-not-found"><a href="#Package-uuid-was-not-found-in-the-pkg-config-search-path-Perhaps-you-should-add-the-directory-containing-uuid-pc’-to-the-PKG-CONFIG-PATH-environment-variable-Package-‘uuid’-required-by-‘glusterfs-api’-not-found" class="headerlink" title="Package uuid was not found in the pkg-config search path.Perhaps you should add the directory containing `uuid.pc’ to the PKG_CONFIG_PATH environment variable .Package ‘uuid’, required by ‘glusterfs-api’, not found   :"></a>Package uuid was not found in the pkg-config search path.Perhaps you should add the directory containing `uuid.pc’ to the PKG_CONFIG_PATH environment variable .Package ‘uuid’, required by ‘glusterfs-api’, not found   :</h2><p>执行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install uuid-dev </span><br></pre></td></tr></table></figure>
<h2 id="fatal-error-sys-acl-h-No-such-file-or-directory"><a href="#fatal-error-sys-acl-h-No-such-file-or-directory" class="headerlink" title="fatal error: sys/acl.h: No such file or directory"></a>fatal error: sys/acl.h: No such file or directory</h2><p>执行：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install uuid-dev libacl1-dev liblzo2-dev</span><br></pre></td></tr></table></figure>

<h2 id="apt-get-update的时候如果出现hash校验失败"><a href="#apt-get-update的时候如果出现hash校验失败" class="headerlink" title="apt-get update的时候如果出现hash校验失败"></a>apt-get update的时候如果出现hash校验失败</h2><p>可以尝试使用apt-get update –fix-missing来解决；也可以试试sudo apt-get upgrade来升级软件包</p>
<h2 id="出现connection-failed-check-if-gluster-deamon-is-running-："><a href="#出现connection-failed-check-if-gluster-deamon-is-running-：" class="headerlink" title="出现connection failed check if gluster deamon is running ："></a>出现connection failed check if gluster deamon is running ：</h2><p>执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -fR /var/<span class="built_in">log</span>/glusterfs/*</span><br><span class="line">rm -rf /var/lib/glusterd/*</span><br></pre></td></tr></table></figure>
<p>直接卸载重装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove glusterfs-common</span><br><span class="line">sudo add-apt-repository ppa:gluster/glusterfs-3.8</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install glusterfs-server</span><br></pre></td></tr></table></figure>

<h2 id="安装glusterfs3-8："><a href="#安装glusterfs3-8：" class="headerlink" title="安装glusterfs3.8："></a>安装glusterfs3.8：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:gluster/glusterfs-3.8</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install glusterfs-server</span><br></pre></td></tr></table></figure>

<h2 id="git-add的时候拼命地提示："><a href="#git-add的时候拼命地提示：" class="headerlink" title="git add的时候拼命地提示："></a>git add的时候拼命地提示：</h2><p>尚未暂存以备提交的变更：<br>  （使用 “git add &lt;文件&gt;…” 更新要提交的内容）<br>  （使用 “git checkout – &lt;文件&gt;…” 丢弃工作区的改动）<br>  （提交或丢弃子模组中未跟踪或修改的内容）</p>
<pre><code>这是因为这个主题是用git clone下来的,说白了,也是一个git 仓库…
</code></pre>
<p>可以cd到该目录下,删掉.git文件夹,结束git的控制<br>然后就可以了</p>
<h2 id="glusterfs删除某个brick："><a href="#glusterfs删除某个brick：" class="headerlink" title="glusterfs删除某个brick："></a>glusterfs删除某个brick：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo gluster volume remove-brick datapoint replica 1 n103:/mnt/glustermac force</span><br></pre></td></tr></table></figure>

<h2 id="在一台机器上创建replica-2的卷："><a href="#在一台机器上创建replica-2的卷：" class="headerlink" title="在一台机器上创建replica=2的卷："></a>在一台机器上创建replica=2的卷：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo gluster volume create datapoint replica 2 transport tcp n103:/mnt/gluster n103:/mnt/glustermac force</span><br></pre></td></tr></table></figure>

<h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><p>如果之前装过docker则sudo apt-get remove docker docker-engine</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install \</span><br><span class="line">    linux-image-extra-$(uname -r) \</span><br><span class="line">    linux-image-extra-virtual</span><br><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line">sudo add-apt-repository \</span><br><span class="line">   <span class="string">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">   <span class="subst">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">   stable&quot;</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure>
<h2 id="将用户加入docker-group中，使用docker时不用加sudo："><a href="#将用户加入docker-group中，使用docker时不用加sudo：" class="headerlink" title="将用户加入docker group中，使用docker时不用加sudo："></a>将用户加入docker group中，使用docker时不用加sudo：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo groupadd docker</span><br><span class="line">sudo gpasswd -a <span class="variable">$&#123;USER&#125;</span> docker</span><br><span class="line">sudo service docker restart</span><br></pre></td></tr></table></figure>
<p>注销登录后生效</p>
<h2 id="往registry-push镜像时，time-Parse-方法出错：parsing-time-“2017-04-22T07-30-42Z”-extra-text"><a href="#往registry-push镜像时，time-Parse-方法出错：parsing-time-“2017-04-22T07-30-42Z”-extra-text" class="headerlink" title="往registry push镜像时，time.Parse()方法出错：parsing time “2017-04-22T07:30:42Z”: extra text:"></a>往registry push镜像时，time.Parse()方法出错：parsing time “2017-04-22T07:30:42Z”: extra text:</h2><p>解决办法：见问题15</p>
<h2 id="registry的存储结构："><a href="#registry的存储结构：" class="headerlink" title="registry的存储结构："></a>registry的存储结构：</h2><p>blobs下面存储了registry的所有基本信息元素（镜像实际内容）</p>
<p>digest是基于内容寻址算法算出来的一串hash值</p>
<p>_layers是跟这个镜像有关的所有镜像层</p>
<p>_manifest是镜像的相关信息</p>
<p>revisions里面是该镜像所有可用的镜像digest，下面一个link指向blobs里面对应的digest。可以想象，同一个镜像名可以有多个不同的tag，所以revision目录下也会有多个digest指向不同的镜像digest。比如：将Ubuntu镜像tag成ubuntu:v0.1 ，将hello-world  tag成ubuntu:v0.2，这样他们两个虽然都是名为ubuntu的镜像，但是他们的内容却完全不同，所以digest也不同，因此revision下面会有多个digest</p>
<h2 id="将一个-byte数组p直接用string-p-转化为string后是有问题的"><a href="#将一个-byte数组p直接用string-p-转化为string后是有问题的" class="headerlink" title="将一个[]byte数组p直接用string(p)转化为string后是有问题的"></a>将一个[]byte数组p直接用string(p)转化为string后是有问题的</h2><p>string的结构体是这样的：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> String</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">byte</span>* str;</span><br><span class="line">    intgo <span class="built_in">len</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>golang里面string的概念不是以前遇到\0结尾的概念，他是一块连续的内存，首地址+长度，上面那样赋值，如果p里面有\0，他不会做结尾的处理。这个时候如果对这个string做其他操作，如time.parse(),strconv.Atoi()等就会出错，解决办法是自己写一个正规的转换函数。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">byteString</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(p); i++ &#123;</span><br><span class="line">                <span class="keyword">if</span> p[i] == <span class="number">0</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">string</span>(p[<span class="number">0</span>:i])</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">string</span>(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Docker-Error-response-from-daemon-client-is-newer-than-server"><a href="#Docker-Error-response-from-daemon-client-is-newer-than-server" class="headerlink" title="Docker-Error response from daemon:client is newer than server"></a>Docker-Error response from daemon:client is newer than server</h2><p>方法一：在client端的环境变量中指定旧的API版本来解决：export DOCKER_API_VERSION=<version><br>方法二（推荐）：重启Docker服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service docker restart</span><br></pre></td></tr></table></figure>

<h2 id="git删除本地已修改但未提交的文件："><a href="#git删除本地已修改但未提交的文件：" class="headerlink" title="git删除本地已修改但未提交的文件："></a>git删除本地已修改但未提交的文件：</h2><p>如果未加入暂存区：git checkout . &amp;&amp; git clean –xdf<br>如果已加入暂存区：git reset –hard    ;    git clean -xdf</p>
<h2 id="使用Dockerfile生成镜像时，底层如果是alpine，如果提示pkg-config-exec-“pkg-config”-executable-file-not-found-in-PATH"><a href="#使用Dockerfile生成镜像时，底层如果是alpine，如果提示pkg-config-exec-“pkg-config”-executable-file-not-found-in-PATH" class="headerlink" title="使用Dockerfile生成镜像时，底层如果是alpine，如果提示pkg-config: exec: “pkg-config”: executable file not found in $PATH"></a>使用Dockerfile生成镜像时，底层如果是alpine，如果提示pkg-config: exec: “pkg-config”: executable file not found in $PATH</h2><p>表明alpine系统缺少pkg-config包，则在Dockerfile中加入 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RUN apk add --update alpine-sdk</span><br></pre></td></tr></table></figure>
<p> 安装alpine系统相关包</p>
<h2 id="使用Dockerfile生成镜像时，底层使用gluster-gluster-centos，如果提示Package-glusterfs-api-was-not-found-in-the-pkg-config-search-path"><a href="#使用Dockerfile生成镜像时，底层使用gluster-gluster-centos，如果提示Package-glusterfs-api-was-not-found-in-the-pkg-config-search-path" class="headerlink" title="使用Dockerfile生成镜像时，底层使用gluster/gluster-centos，如果提示Package glusterfs-api was not found in the pkg-config search path."></a>使用Dockerfile生成镜像时，底层使用gluster/gluster-centos，如果提示Package glusterfs-api was not found in the pkg-config search path.</h2><p>表明pak-config里面缺少glusterfs-api包，安装即可，命令如下 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install glusterfs-api-devel</span><br></pre></td></tr></table></figure>

<h2 id="遇到docker-daemon不能启动"><a href="#遇到docker-daemon不能启动" class="headerlink" title="遇到docker daemon不能启动"></a>遇到docker daemon不能启动</h2><p>检查/etc/docker/daemon.json有没有问题，删除该文件也可以。执行sudo service docker restart启动daemon</p>
<h2 id="docker-login时遇到Error-response-from-daemon-getsockopt-connection-refused问题"><a href="#docker-login时遇到Error-response-from-daemon-getsockopt-connection-refused问题" class="headerlink" title="docker login时遇到Error response from daemon: getsockopt: connection refused问题"></a>docker login时遇到Error response from daemon: getsockopt: connection refused问题</h2><p>在/etc/default/docker文件中加入：<br>DOCKER_OPTS=”–insecure-registry 10.0.40.16:5000”</p>
<h2 id="系统如果缺少依赖，执行"><a href="#系统如果缺少依赖，执行" class="headerlink" title="系统如果缺少依赖，执行"></a>系统如果缺少依赖，执行</h2><pre><code>sudo apt-get update
sudo apt-get install -f
</code></pre>
<h2 id="配置harbor时，如果在docker-login的时候出现错误：Error-responsefrom-daemon-Get-https-xx-xxx-xx-xx-v1-users-dial-tcp-xx-xxx-xx-xx-443-getsockopt-connection-refused"><a href="#配置harbor时，如果在docker-login的时候出现错误：Error-responsefrom-daemon-Get-https-xx-xxx-xx-xx-v1-users-dial-tcp-xx-xxx-xx-xx-443-getsockopt-connection-refused" class="headerlink" title="配置harbor时，如果在docker login的时候出现错误：Error responsefrom daemon: Get https://xx.xxx.xx.xx/v1/users/: dial tcp xx.xxx.xx.xx:443:getsockopt: connection refused"></a>配置harbor时，如果在docker login的时候出现错误：Error responsefrom daemon: Get <a href="https://xx.xxx.xx.xx/v1/users/">https://xx.xxx.xx.xx/v1/users/</a>: dial tcp xx.xxx.xx.xx:443:getsockopt: connection refused</h2><p>表明registry的端口5000没有映射出来，则在docker-compose.yml文件中添加registry的端口映射，ports: - 5000:5000 如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">registry:</span></span><br><span class="line">   <span class="attr">image:</span> <span class="string">vmware/registry:photon-2.6.0</span></span><br><span class="line">   <span class="attr">container_name:</span> <span class="string">registry</span></span><br><span class="line">   <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">   <span class="attr">volumes:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">/data/registry:/storage:zfile:///home/konnase/workspace/blog/source/_posts/Spring%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86.md</span></span><br><span class="line"></span><br><span class="line">     <span class="bullet">-</span> <span class="string">./common/config/registry/:/etc/registry/:z</span></span><br><span class="line">   <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">5000</span><span class="string">:5000</span></span><br><span class="line">   <span class="attr">networks:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">harbor</span></span><br><span class="line">   <span class="attr">environment:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">GODEBUG=netdns=cgo</span></span><br><span class="line">   <span class="attr">command:</span></span><br><span class="line">     [<span class="string">&quot;serve&quot;</span>, <span class="string">&quot;/etc/registry/config.yml&quot;</span>]</span><br><span class="line">   <span class="attr">depends_on:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">log</span></span><br><span class="line">   <span class="attr">logging:</span></span><br><span class="line">     <span class="attr">driver:</span> <span class="string">&quot;syslog&quot;</span></span><br><span class="line">     <span class="attr">options:</span>  </span><br><span class="line">       <span class="attr">syslog-address:</span> <span class="string">&quot;tcp://127.0.0.1:1514&quot;</span></span><br><span class="line">       <span class="attr">tag:</span> <span class="string">&quot;registry&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="手动释放Ubuntu系统占用的内存"><a href="#手动释放Ubuntu系统占用的内存" class="headerlink" title="手动释放Ubuntu系统占用的内存"></a>手动释放Ubuntu系统占用的内存</h2><p>通过调整/proc/sys/vm/drop_caches来释放内存<br>echo 3 &gt; /proc/sys/vm/drop_caches</p>
<h2 id="为远程主机设置代理"><a href="#为远程主机设置代理" class="headerlink" title="为远程主机设置代理"></a>为远程主机设置代理</h2><p>本机通过ssh登录远程主机，可以使用anyproxy来代理远程主机，这样远程主机即使没联网也能上外网。<br>本机通过</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g anyproxy</span><br></pre></td></tr></table></figure>
<p>安装anyproxy，然后在命令行执行：<code>anyproxy</code>即可开启代理。<br>远程主机上，执行<br><code>export http_proxy=your_proxy_address:port</code><br><code>export https_proxy=your_proxy_address:port</code><br>即可使远程主机使用本机代理上网.</p>
<blockquote>
<p>注意</p>
</blockquote>
<p>Windows防火墙可能导致代理出现问题，使用代理前请关闭Windows防火墙</p>
<h2 id="ssh登录gitlab"><a href="#ssh登录gitlab" class="headerlink" title="ssh登录gitlab"></a>ssh登录gitlab</h2><p>需要在本地.ssh目录下新建config文件，内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Host git.njuics.cn</span><br><span class="line">    Hostname git.njuics.cn</span><br><span class="line">    Port 2222</span><br></pre></td></tr></table></figure>

<h2 id="docker-registry加速"><a href="#docker-registry加速" class="headerlink" title="docker registry加速"></a>docker registry加速</h2><p>在/etc/docker/daemon.json中加入：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;http://hub-mirror.c.163.com&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>经典算法</title>
    <url>/2018/03/07/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="A-Algorithm"><a href="#A-Algorithm" class="headerlink" title="A* Algorithm"></a>A* Algorithm</h2><p>该算法是一个求最短路径的算法，同Dijkstra算法类似，起始点到终点的距离f(M) = g(M) + h(M)，g(M)表示从起始点S走到M点的距离，h(M)表示从M点到终点的估计距离。算法的关键在h的估计上，可以采用欧氏距离、曼哈顿距离等距离度量方式。在采用特定的距离度量方式估计h(M)的值后，计算f(M)的值，并对f(M)的值进行排序，找到最小的f(M)对应的那个节点作为下一个节点。<br>与Dijkstra算法不同的是，Dijkstra算法是从未走过的节点中找到一个距离已走过的节点最近的节点作为下一个节点，如果A*算法不对f(M)进行排序，则跟Dijkstra算法类似，只是比Dijkstra多计算一个估计值。如果h=0，则A*算法类似于BFS算法，即不考虑终点，只考虑起始点，但可以保证给出最优解；如果g=0，s则A*算法类似于DFS，即不考虑起始点，一根筋的找离终点最近的下一个节点走，这样可能不会给出最优解。</p>
<span id="more"></span>

<h2 id="Fibonacci堆"><a href="#Fibonacci堆" class="headerlink" title="Fibonacci堆"></a>Fibonacci堆</h2><ol>
<li>Fibonacci堆采用双向循环链表；</li>
<li>去除最小节点后，将该节点的所有子节点都串联到根表中，然后将根表中度数相同的子树合并，直至没有度数相同的子树。</li>
<li>在合并根表中相同度数的子树时，注意孩子节点的值要比父节点的值要小，这样才能保证Fibonacci堆中的最小值始终在根节点上。</li>
<li>节点值减小：如果破坏了最小堆性质，则需要重新维护最小堆。首先将值减小的节点及其子树从堆中拿出来，然后将其并到根链表中；然后再从”被切节点的父节点”到所在树根节点递归执行级联剪枝。</li>
<li>节点值增大：将值增大的节点的孩子添加到根链表中，如果值增大的节点不在根链表中，则将其也加入根链表中。然后对其父节点进行级联剪切；如果没有父节点，则判断是否需要更新堆得最小值。</li>
<li>级联剪切的真正目的是为了防止”最小堆”由二叉树演化成链表。</li>
</ol>
<h2 id="装箱问题"><a href="#装箱问题" class="headerlink" title="装箱问题"></a>装箱问题</h2><p>tabu 搜索，模拟退火，领域搜索，GRASP算法</p>
<h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><p>一般50,000,000次循环用时在0.5s左右</p>
<h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><h4 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h4><ul>
<li>lower_bound(<T> *begin, <T> *end, <T> key)：返回第一个不小于key的元素在数组中的位置</li>
<li>binary_search</li>
<li>upper_bound</li>
</ul>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ul>
<li>algotithm包里面sort(v.begin(), v.end())采用快排，快排不稳定；stable_sort采用归并排序，是稳定的，不过归并排序会产生额外的内存开销，时间复杂度虽然也是O(nlogn)，但会比快排稍慢。</li>
</ul>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>set里元素不重复，由二叉搜索树实现，并且对树进行了平衡处理，使得元素在树中分布较为均匀，可以保证搜索、插入和删除的复杂度在O(logn)。</p>
<h4 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h4><p>采用贪心法，一般分为若干步，每一步选择都以代价最小或者收益最大为判断标准，可行解即满足问题约束条件的解</p>
<h3 id="NP问题"><a href="#NP问题" class="headerlink" title="NP问题"></a>NP问题</h3><p>当我们讨论一个算法的时间复杂度时，是在说算法运行时间与其输入规模的关系。一个问题实例的规模就是指它被编码到图灵机的输入带上的长度。可以证明的是，用任何有限的字符集来编码，图灵机完成计算所用的时间T本质上都不会变，只是会乘上某个常数因子。所以通常我们用输入的二进制编码长度来表示输入规模。对于背包问题，其时间复杂度是O(nW)，n为物品个数，W为背包最大容量；复杂度转化为二进制表示为$O(n*2^{log^W})$，设m=$log^W$，则W随m是呈指数变化的</p>
<h4 id="NP-Hard"><a href="#NP-Hard" class="headerlink" title="NP-Hard"></a>NP-Hard</h4>]]></content>
      <tags>
        <tag>algorithm</tag>
        <tag>A* algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>编程规范</title>
    <url>/2018/11/22/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><ul>
<li><p>Use ‘’.startswith() and ‘’.endswith() instead of string slicing to check for prefixes or suffixes.</p>
<p>  startswith() and endswith() are cleaner and less error prone:</p>
<p>  Yes: if foo.startswith(‘bar’):</p>
<p>  No:  if foo[:3] == ‘bar’:</p>
</li>
<li><p>When catching exceptions, mention specific exceptions whenever possible instead of using a bare except: clause:</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> platform_specific_module</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    platform_specific_module = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h2 id="和-的用法"><a href="#和-的用法" class="headerlink" title="*和**的用法"></a>*和**的用法</h2><p>*args 表示接收一个tuple作为参数；\**kw 表示接收一个dict作为参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample</span>(<span class="params">a,*args,**kwargs</span>):</span></span><br><span class="line">  <span class="built_in">print</span> “a <span class="keyword">is</span> &#123;&#125;”.<span class="built_in">format</span>(a)</span><br><span class="line">  <span class="built_in">print</span> “*args <span class="keyword">is</span> a <span class="built_in">tuple</span> &#123;&#125;”.<span class="built_in">format</span>(args)</span><br><span class="line">  <span class="built_in">print</span> “**kwargs <span class="keyword">is</span> a dictionary &#123;&#125;”.<span class="built_in">format</span>(kwargs)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sample(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,name=”rahul”,age=<span class="number">26</span>)</span><br><span class="line">a <span class="keyword">is</span> <span class="number">1</span></span><br><span class="line">*args <span class="keyword">is</span> a <span class="built_in">tuple</span> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">**kwargs <span class="keyword">is</span> a dictionary &#123;‘age’: <span class="number">26</span>, ‘name’: ‘rahul’&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>code style</tag>
      </tags>
  </entry>
  <entry>
    <title>Mxnet</title>
    <url>/2018/09/16/deep_learning/Mxnet/</url>
    <content><![CDATA[<h1 id="Mxnet训练流程"><a href="#Mxnet训练流程" class="headerlink" title="Mxnet训练流程"></a>Mxnet训练流程</h1><ul>
<li>定义好symbol：符号式编程，生成描述计算的计算图，Symbol API 这个包主要是用于提供神经网络的图和自动求导。使用c++写好的Symbol类，可进行加减乘除等符号运算。</li>
<li>写好dataiter：如果是分布式训练，需要将训练数据平均切分到每台训练的机器上</li>
<li>初始化参数：cpu or gpu、学习率、优化器参数、针对不同网络设置参数初始化方法、验证度量(evaluation metrics)、loss function、callbacks</li>
<li>模型训练：<ul>
<li>创建Module: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mod = mx.mod.Module(symbol=net,</span><br><span class="line">    context=mx.cpu(),</span><br><span class="line">    data_names=[<span class="string">&#x27;data&#x27;</span>],</span><br><span class="line">    label_names=[<span class="string">&#x27;softmax_label&#x27;</span>])</span><br></pre></td></tr></table></figure></li>
<li>mod.fit():<ul>
<li>mod.bind(): 分配内存，为计算做准备</li>
<li>mod.inst_prams(): 初始化module参数</li>
<li>mod.init_optimizer(): 初始化优化器，默认sgd</li>
<li>mod.metri.create(): 创建evaluation metric</li>
<li>mod.forward(): 前向传播计算</li>
<li>mod.update_metric(): 更新预测精度</li>
<li>mod.backward(): 反向传播，更新计算梯度</li>
<li>mod.update(): 更新参数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Mxnet参数服务器架构"><a href="#Mxnet参数服务器架构" class="headerlink" title="Mxnet参数服务器架构"></a>Mxnet参数服务器架构</h2><ul>
<li>server节点可以跟其他server节点通信，每个server负责自己分到的参数，server group共同维持所有参数的更新</li>
<li>worker节点之间没有通信，只跟<strong>自己对应的server</strong>进行通信</li>
<li>每个worker group有一个task scheduler，负责向worker分配任务，并且监控worker的运行情况。当有新的worker加入或者退出，task scheduler 负责重新分配任务。</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.cnblogs.com/heguanyou/p/7868596.html">MXnet之ps-lite及parameter server原理</a></p>
]]></content>
      <tags>
        <tag>mxnet</tag>
      </tags>
  </entry>
  <entry>
    <title>NCCL</title>
    <url>/2019/09/26/deep_learning/NCCL/</url>
    <content><![CDATA[<h1 id="NCCL"><a href="#NCCL" class="headerlink" title="NCCL"></a>NCCL</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>NVIDIA Collective Communication Library是一个GPU拓扑感知的，提供了多GPU collective通信的库。</p>
<p>NCCL只能支持到8张GPU的深度学习训练（<a href="https://docs.nvidia.com/deeplearning/sdk/introduction/index.html#introduction">参见</a>）</p>
<p>开发者文档<a href="https://devblogs.nvidia.com/scaling-deep-learning-training-nccl/">nccl2.3</a></p>
<p>在<a href="https://devblogs.nvidia.com/massively-scale-deep-learning-training-nccl-2-4/">nccl2.4介绍文档</a>中提到NCCL的All Reduce操作被用于百度ring-all-reduce和Horovod这两个使用ring的分布式训练框架中来获取GPU之间的full bandwidth。但同时提到ring的缺点是随着GPU数目的增长，延迟也成线性增加。<strong>为什么延迟会呈线性增加？</strong>，很简单，因为每个GPU每次发送完一个chunk就必须等下一个chunk从另一张GPU发过来，整个过程（包括reduce scatter和all gather）总共需要发送2(n-1)次，则延时为2(n-1)的倍数。见<a href="https://images.nvidia.com/events/sc15/pdfs/NCCL-Woolley.pdf">NCCL collective示意图</a></p>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>编译NVIDIA官方<a href="https://github.com/NVIDIA/nccl-tests">nccl-tests</a>，在8张Tesla V100 GPU机器上测试，GPU机器的拓扑如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@9a417caaf03b:~/nccl-tests<span class="comment"># nvidia-smi topo -m</span></span><br><span class="line">	GPU0	GPU1	GPU2	GPU3	GPU4	GPU5	GPU6	GPU7	CPU Affinity</span><br><span class="line">GPU0	 X 	NV1	NV1	NV2	SYS	SYS	NV2	SYS	0-95</span><br><span class="line">GPU1	NV1	 X 	NV2	NV1	SYS	SYS	SYS	NV2	0-95</span><br><span class="line">GPU2	NV1	NV2	 X 	NV2	NV1	SYS	SYS	SYS	0-95</span><br><span class="line">GPU3	NV2	NV1	NV2	 X 	SYS	NV1	SYS	SYS	0-95</span><br><span class="line">GPU4	SYS	SYS	NV1	SYS	 X 	NV2	NV1	NV2	0-95</span><br><span class="line">GPU5	SYS	SYS	SYS	NV1	NV2	 X 	NV2	NV1	0-95</span><br><span class="line">GPU6	NV2	SYS	SYS	SYS	NV1	NV2	 X 	NV1	0-95</span><br><span class="line">GPU7	SYS	NV2	SYS	SYS	NV2	NV1	NV1	 X 	0-95</span><br><span class="line"></span><br><span class="line">Legend:</span><br><span class="line"></span><br><span class="line">  X    = Self</span><br><span class="line">  SYS  = Connection traversing PCIe as well as the SMP interconnect between NUMA nodes (e.g., QPI/UPI)</span><br><span class="line">  NODE = Connection traversing PCIe as well as the interconnect between PCIe Host Bridges within a NUMA node</span><br><span class="line">  PHB  = Connection traversing PCIe as well as a PCIe Host Bridge (typically the CPU)</span><br><span class="line">  PXB  = Connection traversing multiple PCIe switches (without traversing the PCIe Host Bridge)</span><br><span class="line">  PIX  = Connection traversing a single PCIe switch</span><br><span class="line">  NV<span class="comment">#  = Connection traversing a bonded set of # NVLinks</span></span><br></pre></td></tr></table></figure>
<p>执行nccl-tests里面的<code>all_reduce_perf</code>性能测试，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@9a417caaf03b:~/nccl-tests<span class="comment"># ./build/all_reduce_perf -b 8 -e 128M -f 2 -g 8</span></span><br><span class="line"><span class="comment"># nThread 1 nGpus 8 minBytes 8 maxBytes 134217728 step: 2(factor) warmup iters: 5 iters: 20 validation: 1</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Using devices</span></span><br><span class="line"><span class="comment">#   Rank  0 Pid    746 on 9a417caaf03b device  0 [0x4f] Tesla V100-SXM2-16GB</span></span><br><span class="line"><span class="comment">#   Rank  1 Pid    746 on 9a417caaf03b device  1 [0x50] Tesla V100-SXM2-16GB</span></span><br><span class="line"><span class="comment">#   Rank  2 Pid    746 on 9a417caaf03b device  2 [0x5f] Tesla V100-SXM2-16GB</span></span><br><span class="line"><span class="comment">#   Rank  3 Pid    746 on 9a417caaf03b device  3 [0x60] Tesla V100-SXM2-16GB</span></span><br><span class="line"><span class="comment">#   Rank  4 Pid    746 on 9a417caaf03b device  4 [0xb1] Tesla V100-SXM2-16GB</span></span><br><span class="line"><span class="comment">#   Rank  5 Pid    746 on 9a417caaf03b device  5 [0xb2] Tesla V100-SXM2-16GB</span></span><br><span class="line"><span class="comment">#   Rank  6 Pid    746 on 9a417caaf03b device  6 [0xdb] Tesla V100-SXM2-16GB</span></span><br><span class="line"><span class="comment">#   Rank  7 Pid    746 on 9a417caaf03b device  7 [0xdc] Tesla V100-SXM2-16GB</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#                                                     out-of-place                       in-place</span></span><br><span class="line"><span class="comment">#       size         count    type   redop     time   algbw   busbw  error     time   algbw   busbw  error</span></span><br><span class="line"><span class="comment">#        (B)    (elements)                     (us)  (GB/s)  (GB/s)            (us)  (GB/s)  (GB/s)</span></span><br><span class="line">           8             2   <span class="built_in">float</span>     sum    48.46    0.00    0.00  1e-07    48.17    0.00    0.00  1e-07</span><br><span class="line">          16             4   <span class="built_in">float</span>     sum    48.61    0.00    0.00  6e-08    49.16    0.00    0.00  6e-08</span><br><span class="line">          32             8   <span class="built_in">float</span>     sum    48.48    0.00    0.00  6e-08    48.14    0.00    0.00  6e-08</span><br><span class="line">          64            16   <span class="built_in">float</span>     sum    48.92    0.00    0.00  6e-08    48.50    0.00    0.00  6e-08</span><br><span class="line">         128            32   <span class="built_in">float</span>     sum    48.13    0.00    0.00  6e-08    48.25    0.00    0.00  6e-08</span><br><span class="line">         256            64   <span class="built_in">float</span>     sum    48.47    0.01    0.01  6e-08    48.50    0.01    0.01  6e-08</span><br><span class="line">         512           128   <span class="built_in">float</span>     sum    48.56    0.01    0.02  6e-08    48.29    0.01    0.02  6e-08</span><br><span class="line">        1024           256   <span class="built_in">float</span>     sum    48.88    0.02    0.04  2e-07    48.83    0.02    0.04  2e-07</span><br><span class="line">        2048           512   <span class="built_in">float</span>     sum    49.40    0.04    0.07  2e-07    49.15    0.04    0.07  2e-07</span><br><span class="line">        4096          1024   <span class="built_in">float</span>     sum    49.13    0.08    0.15  2e-07    48.97    0.08    0.15  2e-07</span><br><span class="line">        8192          2048   <span class="built_in">float</span>     sum    49.14    0.17    0.29  2e-07    49.25    0.17    0.29  2e-07</span><br><span class="line">       16384          4096   <span class="built_in">float</span>     sum    50.35    0.33    0.57  2e-07    49.77    0.33    0.58  2e-07</span><br><span class="line">       32768          8192   <span class="built_in">float</span>     sum    51.06    0.64    1.12  2e-07    50.78    0.65    1.13  2e-07</span><br><span class="line">       65536         16384   <span class="built_in">float</span>     sum    52.78    1.24    2.17  2e-07    52.64    1.24    2.18  2e-07</span><br><span class="line">      131072         32768   <span class="built_in">float</span>     sum    56.56    2.32    4.06  2e-07    55.63    2.36    4.12  2e-07</span><br><span class="line">      262144         65536   <span class="built_in">float</span>     sum    60.26    4.35    7.61  2e-07    59.48    4.41    7.71  2e-07</span><br><span class="line">      524288        131072   <span class="built_in">float</span>     sum    61.48    8.53   14.92  2e-07    61.34    8.55   14.96  2e-07</span><br><span class="line">     1048576        262144   <span class="built_in">float</span>     sum    89.27   11.75   20.56  2e-07    88.45   11.85   20.75  2e-07</span><br><span class="line">     2097152        524288   <span class="built_in">float</span>     sum    119.6   17.53   30.68  2e-07    116.7   17.97   31.45  2e-07</span><br><span class="line">     4194304       1048576   <span class="built_in">float</span>     sum    147.4   28.45   49.79  2e-07    145.1   28.91   50.59  2e-07</span><br><span class="line">     8388608       2097152   <span class="built_in">float</span>     sum    203.8   41.16   72.03  2e-07    204.0   41.12   71.97  2e-07</span><br><span class="line">    16777216       4194304   <span class="built_in">float</span>     sum    324.1   51.77   90.59  2e-07    325.7   51.51   90.14  2e-07</span><br><span class="line">    33554432       8388608   <span class="built_in">float</span>     sum    550.8   60.92  106.62  2e-07    553.3   60.64  106.12  2e-07</span><br><span class="line">    67108864      16777216   <span class="built_in">float</span>     sum    992.7   67.60  118.30  2e-07    995.0   67.45  118.04  2e-07</span><br><span class="line">   134217728      33554432   <span class="built_in">float</span>     sum   1818.8   73.80  129.14  2e-07   1821.9   73.67  128.92  2e-07</span><br><span class="line"><span class="comment"># Out of bounds values : 0 OK</span></span><br><span class="line"><span class="comment"># Avg bus bandwidth    : 25.9598</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>algbw = S/t</code>，<code>S</code>表示数据量，<code>t</code>表示操作完<code>S</code>数据量所用时间。这里操作可以使all reduce、all gather等<code>collective operation</code>。以128MB数据测试结果为例：<code>algbw = 134217728/(1818.8*10^(-6))/1000^3 = 73.80  GB/s</code>。</p>
</li>
<li><p><code>busbw = algbw * 2(n-1)/n</code>，<code>n</code>表示<code>collective operation</code>中节点的个数，在这里即为<code>./build/all_reduce_perf -b 8 -e 128M -f 2 -g 8</code>参数<code>-g</code>的值，即GPU的数目。</p>
</li>
</ul>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="ncclAllReduce是如何进行GPU间通信的？"><a href="#ncclAllReduce是如何进行GPU间通信的？" class="headerlink" title="ncclAllReduce是如何进行GPU间通信的？"></a>ncclAllReduce是如何进行GPU间通信的？</h3><p>按照ring的形式还是tree的形式？查看<a href="http://on-demand.gputechconf.com/gtc/2017/presentation/s7155-jeaugey-nccl.pdf">gtc 2017 nccl 2.0 report</a>，其中描述了nccl使用ring的形式在GPU之间交换数据，如下图：<br><img src="/img/deep_learning/nccl-move-data-using-ring.jpg"><br>同时，nccl 2.0在单线程调用多device时增加了手动调用的verb ncclGroupStart/ncclGroupEnd<br><img src="/img/deep_learning/nccl2.0-group-device-call.jpg"><br>可以看看知乎上的一个回答，介绍<a href="https://www.zhihu.com/question/63219175">nccl的设计和实验</a></p>
<p>在nccl 2.4中引入了double binary trees，见<a href="https://devblogs.nvidia.com/massively-scale-deep-learning-training-nccl-2-4/">nccl2.4介绍文档</a>，从效果来看延迟改善了不少，如下图：<br><img src="/img/deep_learning/Summit-Latency.png"><br>double binary trees有待进一步研究</p>
<h3 id="ncclAllReduce是如何构造一条带宽最大的环？"><a href="#ncclAllReduce是如何构造一条带宽最大的环？" class="headerlink" title="ncclAllReduce是如何构造一条带宽最大的环？"></a>ncclAllReduce是如何构造一条带宽最大的环？</h3><p>NCCL中有一个环境变量<code>NCCL_RINGS</code>可以用来覆盖NCCL构造的GPU环，见<a href="https://docs.nvidia.com/deeplearning/sdk/nccl-developer-guide/docs/env.html#nccl-rings">NCCL_RINGS</a></p>
]]></content>
      <tags>
        <tag>deep learnig</tag>
        <tag>all reduce</tag>
        <tag>NCCL</tag>
      </tags>
  </entry>
  <entry>
    <title>Tensorflow</title>
    <url>/2018/12/20/deep_learning/Tensorflow/</url>
    <content><![CDATA[<h1 id="1-模型"><a href="#1-模型" class="headerlink" title="1. 模型"></a>1. 模型</h1><h2 id="1-1-Graph-and-Session"><a href="#1-1-Graph-and-Session" class="headerlink" title="1.1. Graph and Session"></a>1.1. Graph and Session</h2><p>在分布式参数服务器架构训练中，<code>tf.train.replica_device_setter(ps_tasks=3)</code>可以用来指定将tf.Variable的放置位置，比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.device(tf.train.replica_device_setter(ps_tasks=<span class="number">3</span>)):</span><br><span class="line">  <span class="comment"># tf.Variable objects are, by default, placed on tasks in &quot;/job:ps&quot; in a</span></span><br><span class="line">  <span class="comment"># round-robin fashion. And only Variable ops are placed on ps tasks</span></span><br><span class="line">  w_0 = tf.Variable(...)  <span class="comment"># placed on &quot;/job:ps/task:0&quot;</span></span><br><span class="line">  b_0 = tf.Variable(...)  <span class="comment"># placed on &quot;/job:ps/task:1&quot;</span></span><br><span class="line">  w_1 = tf.Variable(...)  <span class="comment"># placed on &quot;/job:ps/task:2&quot;</span></span><br><span class="line">  b_1 = tf.Variable(...)  <span class="comment"># placed on &quot;/job:ps/task:0&quot;</span></span><br><span class="line"></span><br><span class="line">  input_data = tf.placeholder(tf.float32)     <span class="comment"># placed on &quot;/job:worker&quot;</span></span><br><span class="line">  layer_0 = tf.matmul(input_data, w_0) + b_0  <span class="comment"># placed on &quot;/job:worker&quot;</span></span><br><span class="line">  layer_1 = tf.matmul(layer_0, w_1) + b_1     <span class="comment"># placed on &quot;/job:worker&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># or place worker</span></span><br><span class="line"><span class="keyword">with</span> tf.device(tf.train.replica_device_setter( </span><br><span class="line">                       worker_device=<span class="string">&#x27;/job:worker/task:&#x27;</span>+task_idx, </span><br><span class="line">                       clustercluster=cluster)):</span><br><span class="line">        <span class="comment"># build your model here as if you only were using a single machine</span></span><br><span class="line">        <span class="keyword">with</span> tf.Session(server.target):</span><br><span class="line">            <span class="comment"># train your model here </span></span><br></pre></td></tr></table></figure>
<p>tf.Variable 对象默认是放在ps上的，也只有Varibale是放在ps上的</p>
<p>ps上面只是存储了模型的参数，多个ps会将模型的参数拆分之后分别进行存储，workers计算参数更新之后，会将相应的参数发送到对应的ps上去。</p>
<p><code>tf.train.replica_device_setter</code>会返回一个device function，用于<code>with tf.device(device_function)</code>：在Operation对象构造时自动给Operation对象</p>
<span id="more"></span>

<h3 id="1-1-1-概念"><a href="#1-1-1-概念" class="headerlink" title="1.1.1. 概念"></a>1.1.1. 概念</h3><ul>
<li>client：编写代码的程序，client里面构造了tf.Graph，并构建tf.Session来启动训练</li>
<li>tf.Session：Tensorflow使用tf.Session类来表示client程序（通常为Python）与c++运行时之间的连接。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create a default in-process session.</span></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a remote session.</span></span><br><span class="line"><span class="keyword">with</span> tf.Session(<span class="string">&quot;grpc://example.org:2222&quot;</span>):</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></li>
<li>cluster：对于一个cluster，由tf.train.ClusterSpec指定，里面包含了一些Server，Server又可以分为两种job（ps和worker），每个job可以有多个tasks</li>
</ul>
<h2 id="1-2-数据并行"><a href="#1-2-数据并行" class="headerlink" title="1.2. 数据并行"></a>1.2. 数据并行</h2><p>数据并行分为图内复制和图间复制，</p>
<h3 id="1-2-1-in-graph-replication"><a href="#1-2-1-in-graph-replication" class="headerlink" title="1.2.1. in-graph replication"></a>1.2.1. in-graph replication</h3><p>图内复制中所有的Operation都在一张tf.Graph中；用一个客户端来生成Graph， 把所有tf.Operation分配到所有的ps和worker上。一般是单机多卡的训练。</p>
<h3 id="1-2-2-between-graph-replication"><a href="#1-2-2-between-graph-replication" class="headerlink" title="1.2.2. between-graph replication"></a>1.2.2. between-graph replication</h3><p>每个/job/worker的task都有独立的client，参数通过tf.trian.replica_device_setter复制到task中，而每个worker上都会有模型计算部分的副本</p>
<p>框架  代码过程<br>参数更新的时候的通信</p>
]]></content>
      <tags>
        <tag>deep learnig</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式深度学习资源调度</title>
    <url>/2018/09/14/deep_learning/deep_learning_scheduling/</url>
    <content><![CDATA[<h2 id="分布式机器学习相关会议"><a href="#分布式机器学习相关会议" class="headerlink" title="分布式机器学习相关会议"></a>分布式机器学习相关会议</h2><ul>
<li>各大机器学习会议上（NIPS， ICML，ICLR）</li>
<li>各大系统会议上（SOSP，OSDI，ATC，EuroSys，SoCC）</li>
<li>应用对应的顶级会议上（CVPR，KDD）</li>
</ul>
<h2 id="常用的深度学习数据集"><a href="#常用的深度学习数据集" class="headerlink" title="常用的深度学习数据集"></a>常用的深度学习数据集</h2><ul>
<li>ImageNet：15 million 带标签的高分辨率224*224的RGB图像，共22,000catagories，1.2TB</li>
<li>ImageNet 2012: 1.2 million 带标签的高分辨率224*224的RGB图像，共1,000个分类，138GB；50,000张测试图像，1,000个分类</li>
<li>MNIST：输入是28*28是的二值图，输出是0-9这是个数字，60,000 训练图像，10,000测试图像</li>
<li>Cifar-10：由60,000张32*32的RGB彩色图片构成，共10个分类。50,000张训练，10,000张测试（交叉验证）</li>
</ul>
<h2 id="现有的一些分布式深度学习平台"><a href="#现有的一些分布式深度学习平台" class="headerlink" title="现有的一些分布式深度学习平台"></a>现有的一些分布式深度学习平台</h2><ul>
<li>腾讯的Mariana</li>
<li>Google的DistBelif</li>
<li>微软的Adam</li>
</ul>
<span id="more"></span>

<h2 id="分布式机器学习的研究领域"><a href="#分布式机器学习的研究领域" class="headerlink" title="分布式机器学习的研究领域"></a>分布式机器学习的研究领域</h2><h3 id="从统计、优化理论、优化算法角度来做"><a href="#从统计、优化理论、优化算法角度来做" class="headerlink" title="从统计、优化理论、优化算法角度来做"></a>从统计、优化理论、优化算法角度来做</h3><p>关注以下问题：通过分布式并行或其他方法加速训练后，这个新算法还能保证收敛到之前相同的最优值（或者一个满意的最优值）吗？在分布式环境下，收敛能有多快，比非分布式训练快多少？收敛的有多接近，和单机上跑出来的最优解一样吗？收敛需要什么假设？<em>应该怎么设计训练过程</em>（比如，怎么抽样数据、怎么更新参数）从而保证能接近某个最优解，同时还保证加速？</p>
<h3 id="从机器学习的模型角度"><a href="#从机器学习的模型角度" class="headerlink" title="从机器学习的模型角度"></a>从机器学习的模型角度</h3><p>修改原有的模型；提出新的模型；</p>
<h3 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h3><ul>
<li><p>异步训练：参数服务器架构；减小通信开销（计算开销&lt;&lt;通信开销）</p>
</li>
<li><p>数据并行：将数据分成很多小块，加快训练模型；要求数据之间没有依赖性</p>
</li>
<li><p>模型并行：如何划分模型？模型之间的关联性要考虑</p>
<p>Petuum和Tensorflow既支持数据并行也支持模型并行</p>
<ul>
<li>将CNN中的不同层放到不同的device(CPU or GPU)上这样拆分使得参数被分配到多个device上，对参数量巨大的模型就可以提供很好的支持</li>
<li>将CNN中某一层拆开放到不同的device上实现难度较大</li>
</ul>
</li>
<li><p>对反向传播算法的重调度：使计算时间和通信时间尽可能重叠</p>
</li>
<li><p>模型更新：对于全连接层，反向传播的时候，下一层计算的$\Delta w$</p>
</li>
</ul>
<h3 id="并行收敛算法满足的假设"><a href="#并行收敛算法满足的假设" class="headerlink" title="并行收敛算法满足的假设"></a>并行收敛算法满足的假设</h3><ul>
<li>训练程序的计算任务集中在参数更新函数上</li>
<li>每个iteration，数据之间没有依赖性</li>
<li>每个iteration开始之前，每个计算节点需要比较容易的拿到模型参数；每个节点计算完成之后，需要比较容易的将梯度收集起来应用于参数更新:<br>$ \theta(t+1) = \theta(t) - \alpha * \Delta(\theta(t),D_p(t)) $</li>
</ul>
<p>前两个条件容易满足，但第三个条件在多机环境下涉及网络通讯，如何保证参数共享以及梯度同步成了保证第三个条件要解决的核心问题。</p>
<h3 id="All-reduce并行算法"><a href="#All-reduce并行算法" class="headerlink" title="All reduce并行算法"></a>All reduce并行算法</h3><p>设数据量为 X，N GPUs，如果使用一个main gpu来做参数更新并把更新之后的参数再发送会其他worker，则此过程交换的参数为<code>2*X*(N-1)</code></p>
<p>这是 Baidu Silicon Valley AI Lab在GTC 2017上提出了allreduce的实现算法，一些分析如下：</p>
<h4 id="Multi-Tower-Scaling"><a href="#Multi-Tower-Scaling" class="headerlink" title="Multi-Tower Scaling"></a>Multi-Tower Scaling</h4><p><a href="http://on-demand.gputechconf.com/gtc/2017/presentation/s7543-andrew-gibiansky-effectively-scakukbg-deep-learning-frameworks.pdf">Effectively scaling deep learning framework</a>提到分布式训练中网络开销巨大，计算节点之间传递的参数数目太多，如果网络带宽不大，传输开销很大，影响扩展性。</p>
<p>下图指出使用一个main gpu来做参数同步的话，在他们的benchmark中，使用Titan X Maxwell GPU计算单个gpu发来的参数耗时在300ms左右，如果N的数目巨大，这将成为巨大的瓶颈。同时，通信开销在(N-1)/3 s，表明通信开销也是随N的数目线性增长。<br><img src="/img/communication_overhead.png" alt="communication overhead"><br>下图指出随着N的数目的增大，花在通信上的开销的比列越来越大<br><img src="/img/communication_overhead_1.png" alt="communication overhead"><br>遂提出了ring all reduce算法来解决高communication overhead的问题</p>
<h5 id="采用allreduce方式后"><a href="#采用allreduce方式后" class="headerlink" title="采用allreduce方式后"></a>采用allreduce方式后</h5><p>  <img src="/img/pscl_fig_2_allreduce.png" alt="allreduce"><br>  <img src="/img/pscl_fig_4_allreduce.png" alt="allreduce"><br>  <img src="/img/pscl_fig_5_allreduce.png" alt="allreduce"></p>
<p>  Process 1-4上面分别由4个chunk</p>
<ul>
<li>scatter reduce: 执行完N-1步之后，每个Process上都会有一个完整的chunk（比如Process 4上包含了c_11, c_21, c_31和c_41，即所有进程的chunk 1）</li>
<li>all gather: 然后将完整的chunk overwrite到其他不含有完整chunk的Process上</li>
</ul>
<p>  每个GPU会迭代2(N-1)次，并在每次迭代中发送 X/N 大小的数据。则完成一次reduce过程交换的参数量为<code>2*X*(N-1)/N</code></p>
<h5 id="Scaling-with-tensorflow"><a href="#Scaling-with-tensorflow" class="headerlink" title="Scaling with tensorflow"></a>Scaling with tensorflow</h5><p>  下图指出，Baidu在tensorflow的训练流图中的back prop 和weight update之间增加了ring allreduce，使用MPI实现GPUs之间的参数传递</p>
<p>  <img src="/img/scaling_with_tensorflow.png" alt="scaling with tensorflow"></p>
<p>  结果是使用40个GPUs，训练速度几乎呈线性增长</p>
<h2 id="分布式深度学习调度"><a href="#分布式深度学习调度" class="headerlink" title="分布式深度学习调度"></a>分布式深度学习调度</h2><h3 id="多任务调度"><a href="#多任务调度" class="headerlink" title="多任务调度"></a>多任务调度</h3><p>深度学习作业都是运行时间较长的作业，所以一般一个timeslot都会比较大，比如可能40 min或者1 hour</p>
<h3 id="深度学习集群的异构性"><a href="#深度学习集群的异构性" class="headerlink" title="深度学习集群的异构性"></a>深度学习集群的异构性</h3><p>每个深度学习集群包括多个infiniband区域，每个infiniband又由多个机架（rack）组成。不同的机架上可能会安装有不同的加速设备（比如GPU、TPU、FPGA等）。这些加速设备可能会有一个PCIe接口，更进一步，可能会使用不同供应商特制的连接技术进行交互。这些设备或是直接与CPU连接，或是通过PCIe交换机与CPU连接。<br>资源管理系统使用configuration set来描述设备类型、一个server上的设备拓扑和一个infiniband区域内的网络拓扑，scheduler使用bitmap获取设备资源用量以及表达资源请求量。</p>
<h4 id="单个训练作业的性能"><a href="#单个训练作业的性能" class="headerlink" title="单个训练作业的性能"></a>单个训练作业的性能</h4><p>单个job，如果拥有多个GPU，将job打包的越紧密，训练效果会越好。不过有些模型（如inception V3）可以忍受较为松散的packing</p>
<h4 id="多个训练作业间的干扰"><a href="#多个训练作业间的干扰" class="headerlink" title="多个训练作业间的干扰"></a>多个训练作业间的干扰</h4><p>深度学习作业依赖于GPU做计算加速，但是它还是要通过PCIe总线与CPU频繁的通信。因此，在同一server上的多个jobs之间会存在干扰。不同jobs放置的越近，干扰越大，则性能下降得更多<br><img src="/img/inter_job_inference.png" alt="inter_job_inference"></p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>job scheduler利用资源抽象视图，在调度的时候考虑数据本地性和设备拓扑结构。集群空闲时，将jobs分散到集群中来避免干扰；集群高负荷时，将jobs pack得更紧凑，来给多GPU的jobs腾出空间</p>
<h3 id="CPU的重要性"><a href="#CPU的重要性" class="headerlink" title="CPU的重要性"></a>CPU的重要性</h3><p>在GPU训练中，CPU也扮演者重要的角色，下图说明CPU对训练性能的影响<br><img src="/img/cpu_demand_to_reach_max_perf.png" alt="cpu_demand_to_reach_max_perf"></p>
<p>像Tensorflow会将GPU上的计算和CPU上的数据处理overlap起来，这样使得：如果GPU分配的好，即计算很快，那么CPU的用量将会很高</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/30976469">张昊的知乎专栏</a></li>
<li>[technologies behind distributed deep learning allreduce]distributed(<a href="https://preferredresearch.jp/2018/07/10/technologies-behind--deep-learning-allreduce/">https://preferredresearch.jp/2018/07/10/technologies-behind--deep-learning-allreduce/</a>)</li>
<li><a href="https://www.sigops.org/src/srcsosp2017/sosp17src-final35.pdf">All you need to know about scheduling deep learning jobs</a></li>
<li><a href="https://dl.acm.org/citation.cfm?id=3275445">Scheduling CPU for GPU-based Deep Learning Jobs</a></li>
</ul>
]]></content>
      <tags>
        <tag>deep learnig</tag>
        <tag>scheduling</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式深度学习系统</title>
    <url>/2018/08/01/deep_learning/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="分布式深度学习系统"><a href="#分布式深度学习系统" class="headerlink" title="分布式深度学习系统"></a>分布式深度学习系统</h2><ul>
<li>模型(model)、参数(parameter)、训练数据(data)都需要分布式并行处理</li>
<li>迭代次数=数据集大小/batchsize，也即batch的数目；每轮迭代前，worker会从ps pull最新的参数</li>
<li>一轮迭代过后，即训练完一个batch后，做反向传播、参数更新</li>
</ul>
<h3 id="《More-Effective-Distributed-ML-via-a-Stale-Synchronous-Parallel-Parameter-Server》（NIPS’13）"><a href="#《More-Effective-Distributed-ML-via-a-Stale-Synchronous-Parallel-Parameter-Server》（NIPS’13）" class="headerlink" title="《More Effective Distributed ML via a Stale Synchronous Parallel Parameter Server》（NIPS’13）"></a>《More Effective Distributed ML via a Stale Synchronous Parallel Parameter Server》（NIPS’13）</h3><p>本文基于Parameter Server模型提出SSP(Stale Synchronous Parallel)模型，解决异步训练中会出现同步问题。主要思路是在每个worker本地建立一个cache，存储参数，worker从本地cache读取参数而不是向ps请求参数，这样减缓了worker等待参数更新的时间。而本地cache的参数与ps的同步则单独处理。</p>
<p>SSP在同步和异步之间进行了折中，以兼顾quality和quantity。即每个worker在迭代的时候都有一个clock counter，记录当前迭代到哪一步了，给定一个阈值s，SSP满足以下规则：</p>
<ul>
<li>最快worker和最慢worker之间相差的迭代步不能超过s，否则最快的迭代步将强制等待最慢的worker。</li>
<li>一个clock为c的worker提交一个更新的时候，这个更新的时间戳就是c。</li>
<li>当一个clock为c的worker从cache读取一个更新的时候，它读取的参数更新最坏也是<code>c-s-1</code>时间戳之前所有的参数。</li>
<li>一个worker读取的更新总会比自己产生的所有结果更新。</li>
</ul>
<p>当s=0时，就是完全同步；当s等于无穷大时，就是完全异步。</p>
<span id="more"></span>

<h3 id="《Project-Adam-Building-an-Efficient-and-Scalable-Deep-Learning-Training-System》（OSDI‘14）"><a href="#《Project-Adam-Building-an-Efficient-and-Scalable-Deep-Learning-Training-System》（OSDI‘14）" class="headerlink" title="《Project Adam: Building an Efficient and Scalable Deep Learning Training System》（OSDI‘14）"></a>《Project Adam: Building an Efficient and Scalable Deep Learning Training System》（OSDI‘14）</h3><p>这是微软研究院的一份工作，主要是对深度神经网络训练图像识别任务的底层进行了优化，包括以下几点：</p>
<ul>
<li>数据预处理：提前完成图像的转换（包括平移、反射、旋转），将图像加载进内存。这样能减少数据预处理的时间</li>
<li>模型训练：<ul>
<li>多线程不加锁训练：因为DNN的池化层的带来的弹性性能，使得DNN可以忍受小的噪声，所以一些陈旧的权值(weight)不会影响最终的收敛</li>
<li>处理数据本地性问题：实现了Windows Socket API，相当于一个全局内存地址，减少内存的拷贝，每次只需要给出一个数据的指针即可定位不同机器上的数据的位置</li>
<li>优化浮点运算</li>
<li>降低滞后机器的影响：为避免速度较快的机器上出现线程等待滞后机器上的数据，允许线程并行处理多个image；在判断训练epoch是否结束的时候，判断如果75%的模型副本（即workers）完成处理了就当作一个训练epoch结束了。</li>
<li>减少worker与ps之间传递的参数的数目：对于全连接层，worker直接将激活函数和误差项发送给ps，让ps进行参数的更新。假设M是上一层神经元的个数，N是下一层神经元的个数，则最终worker和ps之间传递的参数的数目从M*N降到了k*(M+N)<br>对全局的参数服务器也进行了优化</li>
</ul>
</li>
</ul>
<p>实验结果显示Adam异步训练MNIST TOP-1准确率提升了0.24%，这是一个巨大的提升，并且推翻了在卷积领域公认的知识–异步会导致模型预测的准确度降低。同时，ImageNet 22K训练集上，使用4个image server，48个训练机器（分为16个模型副本，每个副本包含3台机器），和10个ps，共62台机器。较之前最好的结果（使用2000台机器训练一周得到Top-1准确率为13.6%），Adam 的Top-1准确率一天就超过了13.6%，训练完用时10天，准确率达到29.8%。</p>
<p>很多技术值得借鉴，像数据预处理、减少内存拷贝、减少worker和ps之间传递的参数的数目等，这些技术都能很好的减少模型收敛的时间。</p>
<h3 id="并行计算"><a href="#并行计算" class="headerlink" title="并行计算"></a>并行计算</h3><p>SSP模型是基于BSP(Bulk Synchronous Parallel)模型-整体同步模型的一个改进，是一个分布式存储的MIMD（多指令流多数据流）模型。BSP模型是每次迭代之后一个大同步，而SSP模型更像是一个流水线模型。</p>
<h3 id="《STRADS-A-Distributed-Framework-for-Scheduled-Model-Parallel-Machine-Learning》（EuroSys’16）"><a href="#《STRADS-A-Distributed-Framework-for-Scheduled-Model-Parallel-Machine-Learning》（EuroSys’16）" class="headerlink" title="《STRADS: A Distributed Framework for Scheduled Model Parallel Machine Learning》（EuroSys’16）"></a>《STRADS: A Distributed Framework for Scheduled Model Parallel Machine Learning》（EuroSys’16）</h3><p>提出了一种调度的模型并行化(Scheduled Model Parallelism)，即在将模型切分到不同的节点上之前，考虑模型之间的依赖（不考虑依赖可能导致错误），以及模型收敛的速率，使得模型收敛的速率更快。SchMP允许将模型并行算法分成控制组件和更新组件，控制组件负责依赖检查和设置优先权；更新组件在由控制组件规定的并行调度中执行迭代ML更新。</p>
<h3 id="《Poseidon-An-Efficient-Communication-Architecture-for-Distributed-Deep-Learning-on-GPU-Clusters》（ATC’17）"><a href="#《Poseidon-An-Efficient-Communication-Architecture-for-Distributed-Deep-Learning-on-GPU-Clusters》（ATC’17）" class="headerlink" title="《Poseidon: An Efficient Communication Architecture for Distributed Deep Learning on GPU Clusters》（ATC’17）"></a>《Poseidon: An Efficient Communication Architecture for Distributed Deep Learning on GPU Clusters》（ATC’17）</h3><p>解决分布式GPU训练中的网络带宽问题</p>
<p>文中提出分布式深度学习其中的两点限制：</p>
<ul>
<li>模型更新时可能会是一个很大的矩阵，在将模型更新发送到ps的时候会占满网络带宽</li>
<li>由于DNN的迭代性质，会在训练完一个epoch之后进行参数更新。这样会带来通信的暴增，而其他时间没有通信<br>本文旨在减小每次更新时矩阵的大小；以及对矩阵进行划分，通过重新调度，使参数更新不发生在同一时刻</li>
<li>DWBP（分布式无等待反向传播算法）用来做通信的负载均衡</li>
<li>SACP（structure-aware communication protocol）用来最小化通信负载<ul>
<li>每两个worker之间建立p2p连接</li>
<li>SFB(sufficient factor broadcast)利用p2p连接在worker之间交换parameters<ul>
<li>这一点和Adam里面减少worker与ps之间传递的参数的数目的措施有点类似，不过Adam是worker和ps之间交换</li>
<li>设p个worker，k为batch size，Adam总的通信开销为p*k*(M+N)+p*M*N</li>
<li>SFB的通信开销为$(p-1)^2<em>k</em>(M+N)$</li>
</ul>
</li>
<li>SACP<br>同时支持CPU和GPU训练</li>
</ul>
</li>
</ul>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://zhuanlan.zhihu.com/p/30976469">张昊的知乎专栏</a><br><a href="http://jcf94.com/2017/12/20/2017-12-20-distributeddl/">http://jcf94.com/2017/12/20/2017-12-20-distributeddl/</a></p>
]]></content>
      <tags>
        <tag>deep learnig</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络相关</title>
    <url>/2019/01/13/deep_learning/neural-network/</url>
    <content><![CDATA[<h2 id="神经网络相关内容"><a href="#神经网络相关内容" class="headerlink" title="神经网络相关内容"></a>神经网络相关内容</h2><h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><ul>
<li>多层神经网络需要非线性映射。如果全连接层没有非线性部分，只有线性部分，那么计算之后，线性的多层神经网络其实可以转换成一层的神经网络。故加入非线性层，多层神经网络才有意义。</li>
<li>为防止使用sigmoid激活函数可能导致的梯度消失问题，激活函数一般取relu函数</li>
<li>每个神经元都是由输入图片（或者语音等）和该神经元所在层的前面所有层的连接矩阵（如卷积核）决定的，所以一个神经元其实就是一个变量，而连接矩阵是一组固定的权值，输入图片的不同会使该神经元输出不同的值。因此模型才能预测不同的图片所属的不同分类。我们保存的模型其实主要就是模型的连接矩阵，这也是神经网络训练过程中需要学习的</li>
</ul>
<h3 id="提高验证准确性的方法"><a href="#提高验证准确性的方法" class="headerlink" title="提高验证准确性的方法"></a>提高验证准确性的方法</h3><ul>
<li>增加数据集：Adding more data augmentations often reduces the gap between training and validation accuracy. Data augmentation could be reduced in epochs closer to the end.</li>
<li>初始学习率设置大一点：Start with a large learning rate and keep it large for a long time. For example, in CIFAR10, you could keep the learning rate at 0.1 for the first 200 epochs and then reduce it to 0.01.</li>
<li>batch size不能太大：Do not use a batch size that is too large, especially batch size &gt;&gt; number of classes.<ul>
<li>batch_size增大，会使训练速度加快，不过太大会导致learning rate不好调，因为lr和batch size之间不是线性关系</li>
<li>batch_size太小，模型训练的慢</li>
</ul>
</li>
</ul>
<h3 id="Data-Augmentation"><a href="#Data-Augmentation" class="headerlink" title="Data Augmentation"></a>Data Augmentation</h3><p>人工增加训练集的大小，包括反射(image reflection)、平移(translation)、旋转(rotation)、加噪声等方法从已有的数据中创造一批新的数据</p>
<h3 id="Batch-Normalization"><a href="#Batch-Normalization" class="headerlink" title="Batch Normalization"></a>Batch Normalization</h3><p>CNN网络在训练的过程中，前一层的参数变化影响着后面层的变化（因为前面层的输出是后面的输入），而且这种影响会随着网络深度的增加而不断放大。在CNN训练时，绝大多数都采用mini-batch使用随机梯度下降算法进行训练，那么随着输入数据的不断变化，以及网络中参数不断调整，网络的各层输入数据的分布则会不断变化，那么各层在训练的过程中就需要不断的改变以适应这种新的数据分布，从而造成网络训练困难，难以拟合的问题。 </p>
<p>BatchNorm的目的是将每一层的输入数据进行归一化(normalization)，使得每一层的数据分布是稳定的–均值0方差1，增加两个可学习的参数 β 和 γ ，对数据进行缩放和平移，从而达到加速训练的目的</p>
<h3 id="momentum"><a href="#momentum" class="headerlink" title="momentum"></a>momentum</h3><p>用来加速训练过程的。引入momentum后，采用如下公式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v = mu * v - learning_rate * dw</span><br><span class="line">w = w + v</span><br></pre></td></tr></table></figure>
<p>v初始为0，mu是一个超参数，一般设置为0.9。这样理解：如果上一次v和这一次的负梯度方向是相同的，则w下降的幅度会加大，从而使收敛的速度加快；反之，w下降的幅度会减小，收敛的速度减慢。</p>
<h3 id="Softmax函数"><a href="#Softmax函数" class="headerlink" title="Softmax函数"></a>Softmax函数</h3><p>即归一化指数函数，Softmax函数将向量等比例压缩到[0,1]之间，且保证所有元素之和为1。在多分类问题中用作输出层。<br>$$ softmax(i) = \frac{e^i}{\sum_{j}e^j} $$</p>
<p>向量里面的每个元素都可能取到，只是取到的概率由softmax函数求出的值给出。</p>
<p>在做反向传播的时候，也很方便，只需将softmax算出来的类别向量对应的真正结果的那一维减一就可以了。比如通过若干层的计算，最后得到的某个训练样本的向量的分数是[ 1, 5, 3 ],那softmax计算出来的概率就是$[\frac{e^1}{e^1 + e^3 + e^5},\frac{e^5}{e^1 + e^3 + e^5},\frac{e^3}{e^1 + e^3 + e^5}]=[ 0.015, 0.866, 0.117 ]$，如果这个样本正确的分类是第二个的话，那么计算出来的偏导就是$[ 0.015, 0.866 - 1, 0.117 ] = [ 0.015, -0.134, 0.117 ]$，然后根据这个偏导做反向传播，更新参数值。</p>
<h3 id="resnet模型"><a href="#resnet模型" class="headerlink" title="resnet模型"></a>resnet模型</h3><p><img src="/img/resnet_params.png"></p>
<h3 id="反向传播是一张图片处理完成之后就开始还是等待一个batch处理完之后开始？"><a href="#反向传播是一张图片处理完成之后就开始还是等待一个batch处理完之后开始？" class="headerlink" title="反向传播是一张图片处理完成之后就开始还是等待一个batch处理完之后开始？"></a>反向传播是一张图片处理完成之后就开始还是等待一个batch处理完之后开始？</h3><p><strong>答案是等待一个batch处理完之后开始。</strong>从Mxnet代码可以看出：module.forward_backward方法里就两句话：self.forward(batch) 和self.backward。</p>
<h3 id="反向传播使用多少个loss？"><a href="#反向传播使用多少个loss？" class="headerlink" title="反向传播使用多少个loss？"></a>反向传播使用多少个loss？</h3><p>一个batch处理完之后做backward，先拿到forward时产生的batch_size个loss，如果选择sgd来做梯度下降，那么sgd选择多少个loss做backward？<strong>答案是会将batch_size个loss平均之后做backward</strong>，因为这里使用的sgd是mini-batch sgd，即一个mini-batch完成前向处理后，将loss平均之后做backward，而不是只使用其中一个loss做backward。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://blog.csdn.net/lhanchao/article/details/70308092">深度学习–Batch Normalization 算法介绍</a></li>
<li><a href="https://blog.csdn.net/superCally/article/details/54234115">Softmax的理解和应用</a></li>
</ul>
]]></content>
      <tags>
        <tag>deep learning</tag>
        <tag>neural network</tag>
      </tags>
  </entry>
  <entry>
    <title>参数服务器架构</title>
    <url>/2020/01/03/deep_learning/%E5%8F%82%E6%95%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h3><ol>
<li><strong>搞清楚ps架构通信的时候是不是都会走QPI总线，跨numa node？</strong></li>
<li><strong>PS在哪些cpu上跑也影响着通信的效率。尝试找到每个PS跑在哪几个cpu上</strong></li>
</ol>
<h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><h4 id="k8s中cpuset的探索"><a href="#k8s中cpuset的探索" class="headerlink" title="k8s中cpuset的探索"></a>k8s中cpuset的探索</h4><p>为了找到PS具体使用的是哪几个cpu，尝试探索k8s对cpuset的使用。</p>
<p>k8s中，容器 cpuset 中的 CPU 数量与 pod 规格中指定的整数型 CPU limit 相等。只要保证pod属于 Guaranteed QoS（即limits和requests相等）且cpu的资源值为大于等于1的整数值，则该pod就会被cpu manager（从 1.10 版本开始，作为 beta 特性默认开启）分配两个独占的cpu。</p>
<p>源码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/kubelet/cm/cpumanager/policy_static.go</span></span><br><span class="line"><span class="comment">// 判断一个pod是否为Guaranteed QoS，并且cpu申请值是否为整数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">guaranteedCPUs</span><span class="params">(pod *v1.Pod, container *v1.Container)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> v1qos.GetPodQOS(pod) != v1.PodQOSGuaranteed &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    cpuQuantity := container.Resources.Requests[v1.ResourceCPU]</span><br><span class="line">    <span class="keyword">if</span> cpuQuantity.Value()*<span class="number">1000</span> != cpuQuantity.MilliValue() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Safe downcast to do for all systems with &lt; 2.1 billion CPUs.</span></span><br><span class="line">    <span class="comment">// Per the language spec, `int` is guaranteed to be at least 32 bits wide.</span></span><br><span class="line">    <span class="comment">// https://golang.org/ref/spec#Numeric_types</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(cpuQuantity.Value())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pkg/kubelet/cm/cpumanager/cpu_manager.go</span></span><br><span class="line"><span class="comment">// 同步cpuset的状态，</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *manager)</span> <span class="title">reconcileState</span><span class="params">()</span> <span class="params">(success []reconciledContainer, failure []reconciledContainer)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;[cpumanager] reconcileState: updating container (pod: %s, container: %s, container id: %s, cpuset: \&quot;%v\&quot;)&quot;</span>, pod.Name, container.Name, containerID, cset)</span><br><span class="line">    err = m.updateContainerCPUSet(containerID, cset)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        klog.Errorf(<span class="string">&quot;[cpumanager] reconcileState: failed to update container (pod: %s, container: %s, container id: %s, cpuset: \&quot;%v\&quot;, error: %v)&quot;</span>, pod.Name, container.Name, containerID, cset, err)</span><br><span class="line">        failure = <span class="built_in">append</span>(failure, reconciledContainer&#123;pod.Name, container.Name, containerID&#125;)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    success = <span class="built_in">append</span>(success, reconciledContainer&#123;pod.Name, container.Name, containerID&#125;)</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *manager)</span> <span class="title">updateContainerCPUSet</span><span class="params">(containerID <span class="keyword">string</span>, cpus cpuset.CPUSet)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Consider adding a `ResourceConfigForContainer` helper in</span></span><br><span class="line">    <span class="comment">// helpers_linux.go similar to what exists for pods.</span></span><br><span class="line">    <span class="comment">// It would be better to pass the full container resources here instead of</span></span><br><span class="line">    <span class="comment">// this patch-like partial resources.</span></span><br><span class="line">    <span class="keyword">return</span> m.containerRuntime.UpdateContainerResources(</span><br><span class="line">        containerID,</span><br><span class="line">        &amp;runtimeapi.LinuxContainerResources&#123;</span><br><span class="line">            CpusetCpus: cpus.String(),</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实验环境为167集群，共20个逻辑cpu，分布在两个numa node上。PS是处于Guaranteed QoS状态，而且cpu=2，<strong>但是通过<code>docker inspect</code>怎么看不到CpusetCpus字段被设置了？</strong>，直接去cgroups中查看PS对应的pod的<code>cpuset.cpus</code>的值是给的<code>0-19</code>，表示每个cpu都有可能用到，很奇怪。</p>
<p>尝试通过docker直接绑定一组cpuset：<code>docker run --rm --cpuset-cpus 0-3 nginx:alpine</code>，查看<code>docker inspect [container-id]</code>，<code>CpusetCpus</code>字段是有设置的，查看cgroups中该容器对应的<code>cpuset.cpus</code>的值也是<code>0-3</code><br><img src="../../img/deep_learning/cpuset.png" alt="cpuset"></p>
<p>查看<code>/var/lib/kubelet/config.yaml</code>里面给出的kubelet的启动参数中，<code>cpuManagerPolicy=none</code>，表示通过操作系统调度器CFS配额来提供Guaranteed Pod的cpu使用限制，而前面提到的满足条件的Pod会被分配独占cpu的策略是cpu manager提供的另一种<code>static</code>策略，而kubelet默认开启的是<code>none</code> 策略。</p>
<p>单机n33，Resnet50：</p>
<ol>
<li>单作业 1 ps 1 worker：113 images/sec (gpu 7)<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gpu rxpci txpci</span></span><br><span class="line"><span class="comment"># Idx  MB/s  MB/s</span></span><br><span class="line">    7  4863   414</span><br><span class="line">    7  6454   827</span><br><span class="line">    7  5580  2530</span><br></pre></td></tr></table></figure></li>
<li>单作业 3 ps 1 worker：113 images/sec (gpu 7)</li>
<li>单作业 3 ps 2 worker：103 images/sec (gpu 0 4)</li>
<li>单作业 3 ps 3 worker：<ol>
<li>3 * 93 images/sec (gpu 2 14 15) （一开始速度只有80不到，到2000 batches后稳定）<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gpu rxpci txpci</span></span><br><span class="line"><span class="comment"># Idx  MB/s  MB/s</span></span><br><span class="line">   15  5172  2415</span><br><span class="line">    2  6131   978</span><br><span class="line">   14  4241   603</span><br><span class="line">   15  4032   141</span><br><span class="line">    2  2033   135</span><br><span class="line">   14  2284   584</span><br></pre></td></tr></table></figure></li>
<li>3 * 96 images/sec (gpu 1 11 13)<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gpu rxpci txpci</span></span><br><span class="line"><span class="comment"># Idx  MB/s  MB/s</span></span><br><span class="line">    1  5426  1395</span><br><span class="line">   11  5598   933</span><br><span class="line">   13  5745   596</span><br><span class="line">    1  2231   256</span><br><span class="line">   11  5812   784</span><br><span class="line">   13  6150  2869</span><br></pre></td></tr></table></figure></li>
<li>3 * 84 images/sec (gpu 4 7 10)（速度从93降到83）<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gpu rxpci txpci</span></span><br><span class="line"><span class="comment"># Idx  MB/s  MB/s</span></span><br><span class="line">    4    63   229</span><br><span class="line">    7   450     0</span><br><span class="line">   10   394   169</span><br><span class="line">    4  5789   669</span><br><span class="line">    7  1357   151</span><br><span class="line">   10  1593     0</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>两作业3 ps 2 worker：96 images/sec （gpu 0 4 vs 10 14） <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   <span class="comment"># gpu rxpci txpci</span></span><br><span class="line"><span class="comment"># Idx  MB/s  MB/s</span></span><br><span class="line">    0  6591  2638</span><br><span class="line">    4  5704   916</span><br><span class="line">   10  8900   725</span><br><span class="line">   14  5124   322</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Controller处理web请求的流程</title>
    <url>/2018/03/17/java_spring/Controller%E5%A4%84%E7%90%86web%E8%AF%B7%E6%B1%82%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="Dispatcher-Servlet是怎样被调用的？"><a href="#Dispatcher-Servlet是怎样被调用的？" class="headerlink" title="Dispatcher Servlet是怎样被调用的？"></a>Dispatcher Servlet是怎样被调用的？</h2><p>我的<a href="https://konnase.github.io/2017/07/24/Spring%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/">这篇博客</a>有讲到过程，再来分析一下Spring4.2.6的源代码</p>
<p>DispatcherServlet类继承关系是DispatcherServlet -&gt; FrameworkServlet -&gt; HttpServletBean -&gt; HttpServlet，由DispatcherServlet负责处理Http请求。<br>另：Shiro里面的securitymanager的作用跟DispatcherServlet的作用很相似，都是负责全局组件交互的前端控制器。</p>
<span id="more"></span>
<p>初始化过程如下：<br>首先，HttpServletBean方法执行初始化方法init()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Map config parameters onto bean properties of this servlet, and</span></span><br><span class="line"><span class="comment">    * invoke subclass initialization.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> ServletException if bean properties are invalid (or required</span></span><br><span class="line"><span class="comment">    * properties are missing), or if subclass initialization fails.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Initializing servlet &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set bean properties from init parameters.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        PropertyValues pvs = <span class="keyword">new</span> ServletConfigPropertyValues(getServletConfig(), <span class="keyword">this</span>.requiredProperties);</span><br><span class="line">        BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</span><br><span class="line">        ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(getServletContext());</span><br><span class="line">        bw.registerCustomEditor(Resource.class, <span class="keyword">new</span> ResourceEditor(resourceLoader, getEnvironment()));</span><br><span class="line">        initBeanWrapper(bw);</span><br><span class="line">        bw.setPropertyValues(pvs, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Failed to set bean properties on servlet &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Let subclasses do whatever initialization they like.</span></span><br><span class="line">    initServletBean();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Servlet &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27; configured successfully&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后调用子类的initServletBean方法，这里的子类就是FrameworkServlet类，该方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Overridden method of &#123;<span class="doctag">@link</span> HttpServletBean&#125;, invoked after any bean properties</span></span><br><span class="line"><span class="comment">    * have been set. Creates this servlet&#x27;s WebApplicationContext.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    getServletContext().log(<span class="string">&quot;Initializing Spring FrameworkServlet &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.info(<span class="string">&quot;FrameworkServlet &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;: initialization started&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class="line">        initFrameworkServlet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ServletException ex) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.error(<span class="string">&quot;Context initialization failed&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.error(<span class="string">&quot;Context initialization failed&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">        <span class="keyword">long</span> elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line">        <span class="keyword">this</span>.logger.info(<span class="string">&quot;FrameworkServlet &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;: initialization completed in &quot;</span> +</span><br><span class="line">                elapsedTime + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>initServletBean方法的执行可在控制台看到输出，跟该方法给出的输出是一致的。在Springboot中，servlet是在完成各种bean的加载、jpa的初始化等操作后，在开始接受Http请求时初始化的：<br><img src="/img/frameworservletonstartup.png" alt="image"><br>执行initWebApplicationContext方法，该方法调用onRefresh方法（由子类实现），即由DispatcherServlet类实现的onRefresh方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * This implementation calls &#123;<span class="doctag">@link</span> #initStrategies&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    initStrategies(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Initialize the strategy objects that this servlet uses.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    initMultipartResolver(context);</span><br><span class="line">    initLocaleResolver(context);</span><br><span class="line">    initThemeResolver(context);</span><br><span class="line">    initHandlerMappings(context);</span><br><span class="line">    initHandlerAdapters(context);</span><br><span class="line">    initHandlerExceptionResolvers(context);</span><br><span class="line">    initRequestToViewNameTranslator(context);</span><br><span class="line">    initViewResolvers(context);</span><br><span class="line">    initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>initStrategies方法初始化很多策略，包括handlerMapping、handlerAdapter等，如果从bean容器中找不到相关策略，则采用缺省的策略，即spring-webmvc jar包的文件org.springframework.web.servlet.DispatcherServlet.properties中的缺省值。如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># Default implementation classes for DispatcherServlet&#x27;s strategy interfaces.</span><br><span class="line"># Used as fallback when no matching beans are found in the DispatcherServlet context.</span><br><span class="line"># Not meant to be customized by application developers.</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolver</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\</span><br><span class="line">	org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\</span><br><span class="line">	org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\</span><br><span class="line">	org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\</span><br><span class="line">	org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\</span><br><span class="line">	org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager</span><br></pre></td></tr></table></figure>

<p>DispatcherServlet的初始化过程主要完成两件事。</p>
<ol>
<li>初始化Spring Web MVC使用的Web上下文，并且可能指定父容器为（ContextLoaderListener加载了根上下文）；</li>
<li>初始化DispatcherServlet使用的策略，如HandlerMapping、HandlerAdapter等。</li>
</ol>
<p>而在处理Http请求时，主要调用doService方法，该方法将DispatcherServlet的具体参数加入到request中，并委托doDispatch方法完成真正的调度，doDispatch方法实现了以下处理流程：</p>
<ol>
<li>用户发送请求–&gt; DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他解析器进行处理，作为统一访问点，进行全局流程控制。</li>
<li>DispatherServlet–&gt; HandlerMapping，后者将把请求映射为HandlerExecutionChain对象（包含一个Handler处理器（页面控制器）对象、多个HandlerInterceptor拦截器），通过这种策略模式，很容易添加新的映射策略，得到一个handler</li>
<li>DispatcherServlet–&gt; HandlerAdapter，后者将会把处理器包装为适配器，从而支持多种类型的处理器，由适配器执行处理器</li>
<li>HandlerAdapter–&gt; 处理器功能处理方法的调用，HandlerAdapter将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理，并返回一个ModelAndView对象</li>
<li>ModelAndView的逻辑视图名–&gt; ViewResolver，ViewResolver将把逻辑视图名解析成具体的View，通过这种策略，很容易更换其他视图技术</li>
<li>View–&gt; 渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构，因此很容易支持其他视图技术</li>
<li>返回控制权给DIspatcherServlet，由DispatcherServlet返回响应给用户，流程结束<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前端控制器分派方法  </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        HttpServletRequest processedRequest = request;  </span><br><span class="line">        HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">int</span> interceptorIndex = -<span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            ModelAndView mv;  </span><br><span class="line">            <span class="keyword">boolean</span> errorView = <span class="keyword">false</span>;  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                   <span class="comment">//检查请求是否是multipart（如文件上传），如果是将通过MultipartResolver解析  </span></span><br><span class="line">                processedRequest = checkMultipart(request);  </span><br><span class="line">                   <span class="comment">//步骤2、请求到处理器（页面控制器）的映射，通过HandlerMapping进行映射  </span></span><br><span class="line">                mappedHandler = getHandler(processedRequest, <span class="keyword">false</span>);  </span><br><span class="line">                <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    noHandlerFound(processedRequest, response);  </span><br><span class="line">                    <span class="keyword">return</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">                   <span class="comment">//步骤3、处理器适配，即将我们的处理器包装成相应的适配器（从而支持多种类型的处理器）  </span></span><br><span class="line">                HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());  </span><br><span class="line">  </span><br><span class="line">                  <span class="comment">// 304 Not Modified缓存支持  </span></span><br><span class="line">                <span class="comment">//此处省略具体代码  </span></span><br><span class="line">  </span><br><span class="line">                <span class="comment">// 执行处理器相关的拦截器的预处理（HandlerInterceptor.preHandle）  </span></span><br><span class="line">                <span class="comment">//此处省略具体代码  </span></span><br><span class="line">  </span><br><span class="line">                <span class="comment">// 步骤4、由适配器执行处理器（调用处理器相应功能处理方法）  </span></span><br><span class="line">                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());  </span><br><span class="line">  </span><br><span class="line">                <span class="comment">// Do we need view name translation?  </span></span><br><span class="line">                <span class="comment">// 在spring4.2.6中，这段代码被写入一个函数中</span></span><br><span class="line">                <span class="keyword">if</span> (mv != <span class="keyword">null</span> &amp;&amp; !mv.hasView()) &#123;  </span><br><span class="line">                    mv.setViewName(getDefaultViewName(request));  </span><br><span class="line">                &#125;  </span><br><span class="line">  </span><br><span class="line">                <span class="comment">// 执行处理器相关的拦截器的后处理（HandlerInterceptor.postHandle）  </span></span><br><span class="line">                <span class="comment">//此处省略具体代码  </span></span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">catch</span> (ModelAndViewDefiningException ex) &#123;  </span><br><span class="line">                logger.debug(<span class="string">&quot;ModelAndViewDefiningException encountered&quot;</span>, ex);  </span><br><span class="line">                mv = ex.getModelAndView();  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">catch</span> (Exception ex) &#123;  </span><br><span class="line">                Object handler = (mappedHandler != <span class="keyword">null</span> ? mappedHandler.getHandler() : <span class="keyword">null</span>);  </span><br><span class="line">                mv = processHandlerException(processedRequest, response, handler, ex);  </span><br><span class="line">                errorView = (mv != <span class="keyword">null</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">//步骤5 步骤6、解析视图并进行视图的渲染  </span></span><br><span class="line"><span class="comment">//步骤5 由ViewResolver解析View（viewResolver.resolveViewName(viewName, locale)）  </span></span><br><span class="line"><span class="comment">//步骤6 视图在渲染时会把Model传入（view.render(mv.getModelInternal(), request, response);）  </span></span><br><span class="line">            <span class="keyword">if</span> (mv != <span class="keyword">null</span> &amp;&amp; !mv.wasCleared()) &#123;  </span><br><span class="line">                render(mv, processedRequest, response);  </span><br><span class="line">                <span class="keyword">if</span> (errorView) &#123;  </span><br><span class="line">                    WebUtils.clearErrorRequestAttributes(request);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">                    logger.debug(<span class="string">&quot;Null ModelAndView returned to DispatcherServlet with name &#x27;&quot;</span> + getServletName() +  </span><br><span class="line">                            <span class="string">&quot;&#x27;: assuming HandlerAdapter completed request handling&quot;</span>);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 执行处理器相关的拦截器的完成后处理（HandlerInterceptor.afterCompletion）  </span></span><br><span class="line">            <span class="comment">//此处省略具体代码  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;  </span><br><span class="line">            <span class="comment">// Trigger after-completion for thrown exception.  </span></span><br><span class="line">            triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, ex);  </span><br><span class="line">            <span class="keyword">throw</span> ex;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">catch</span> (Error err) &#123;  </span><br><span class="line">            ServletException ex = <span class="keyword">new</span> NestedServletException(<span class="string">&quot;Handler processing failed&quot;</span>, err);  </span><br><span class="line">            <span class="comment">// Trigger after-completion for thrown exception.  </span></span><br><span class="line">            triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, ex);  </span><br><span class="line">            <span class="keyword">throw</span> ex;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">finally</span> &#123;  </span><br><span class="line">            <span class="comment">// Clean up any resources used by a multipart request.  </span></span><br><span class="line">            <span class="keyword">if</span> (processedRequest != request) &#123;  </span><br><span class="line">                cleanupMultipart(processedRequest);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="哪个类负责拦截Http请求并转发给Dispatcher-Servlet的"><a href="#哪个类负责拦截Http请求并转发给Dispatcher-Servlet的" class="headerlink" title="哪个类负责拦截Http请求并转发给Dispatcher Servlet的"></a>哪个类负责拦截Http请求并转发给Dispatcher Servlet的</h2><p>本篇博客同时参考博客网站ITEYE上开涛的Spring MVC相关教程。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>controller</tag>
        <tag>dispatcherservlet</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习知识</title>
    <url>/2018/10/11/deep_learning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h1><h2 id="曲面拟合"><a href="#曲面拟合" class="headerlink" title="曲面拟合"></a>曲面拟合</h2><p>形如二次多项式：<br>$f(x, y) = a_{20}x^2 + a_{02}y^2 + a_{11}xy + a_{10}x + a_{01}y + a_{00}$<br>使用最小二乘法计算系数矩阵a，即使得计算值和真实值之间的误差平方和最小</p>
<p>得到矩阵形如：<br>$$\left[<br> \begin{matrix}<br>   x_1^2 &amp; y_1^2 &amp; x_1y_1 &amp; x_1 &amp; y_1 &amp; 1 \<br>   . &amp; . &amp; . &amp; .&amp; . &amp; .\<br>   . &amp; . &amp; . &amp; .&amp; . &amp; . \<br>   . &amp; . &amp; . &amp; .&amp; . &amp; . \<br>   x_m^2 &amp; y_1^2 &amp; x_my_m &amp; x_m &amp; y_m &amp; 1<br>  \end{matrix}<br>  \right]<br>  \left[<br> \begin{matrix}<br>   a_{20}  \<br>   a_{02} \<br>   a_{11}  \<br>   a_{10}  \<br>   a_{01} \<br>   a_{00}<br>  \end{matrix}<br>  \right] =<br>  \left[<br> \begin{matrix}<br>   f(x_1, y_1)  \<br>   . \<br>   .  \<br>   .  \<br>   f(x_m, y_m)<br>  \end{matrix}<br>  \right]$$</p>
<span id="more"></span>

<p>由<br>$$<br>A.a = y<br>$$<br>$$<br>A^T.A.a = A^T.y<br>$$<br>$$<br>a = (A^T.A)^{-1}.A^T.y<br>$$<br>即可求出系数矩阵a</p>
<h2 id="非负最小二乘（NNLS）"><a href="#非负最小二乘（NNLS）" class="headerlink" title="非负最小二乘（NNLS）"></a>非负最小二乘（NNLS）</h2><p>解$argmin_x ||A.x - b||_2$问题<br>调用scipy.optimize.nnls(A, b)，即可求得使上式结果最小的x。对上一节提到的多项式问题，这里的x就是待求的系数矩阵a，而A矩阵就是多项式构造的矩阵，b就是函数结果f。</p>
]]></content>
      <tags>
        <tag>machine learnig</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven学习笔记</title>
    <url>/2017/11/05/java_spring/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="TheNEXUS-Maven-By-Example"><a href="#TheNEXUS-Maven-By-Example" class="headerlink" title="TheNEXUS Maven By Example"></a>TheNEXUS Maven By Example</h2><h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><ol>
<li>5.6节提到的依赖中设置scope为provided：This tells Maven that the JAR is “provided” by the container and thus should not be included in the WAR. 是什么意思？<span id="more"></span></li>
<li>第六章结合了Weather Module和Web Module，其中，在Web Module中加入了Weather的依赖，并添加了WeatherService服务，该服务中的retrieveFormat方法同Main中的start方法完成相同的工作。Web Module中新增WeatherServlet，里面的doGet方法完成实现对http请求的处理，请求天气数据并返回结果到页面展示。</li>
<li>当Maven执行一个有子模块的project的时候，Maven首先加载parent POM，然后定位所有的子模块。然后将所有的POM交给Maven Reactor，负责分析模块之间的依赖，确保以相应的顺序编译和安装相互依赖的模块。</li>
<li>第六章运行 mvn jetty:run的时候，提示找不到simple-weather-08-SNAPSHOT.jar这个包。而且Yahoo的weather.yahooapis.com网站访问不了。</li>
<li>web.xml和weather-servlet.xml都是自动加载的吗？</li>
</ol>
<h3 id="第七章对象关系"><a href="#第七章对象关系" class="headerlink" title="第七章对象关系"></a>第七章对象关系</h3><p><img src="/img/multimodule-web-spring_projects.png" alt="image"></p>
<ul>
<li>SimpleModel：由Weather、Condition、Atmosphere、Location、Wind对象组成。主要是向simple-weather提供Weather对象，simple-wather解析XML后会生成Weather对象。在simple-persist的DAO中将Weather对象存储到数据库中。</li>
<li>simple-weather：POM文件中加入对simple-model的依赖，simple-weather中定义WeatherService，通过YahooRetriever和YahooParser从Yahoo取得天气信息，返回Weather对象。simple-webapp和simple-command中通过applicationContext-weather.xml中定义的Bean–weatherService来取得该weatherService。</li>
<li>simple-persist：POM文件中加入对simple-model的依赖。LocationDAO和WeatherDAO分别实现从数据库中通过zip code查找location信息和通过location查找Weather信息。applicationContext-persist.xml中向Spring容器中注入了locationDAO和weatherDao，simple-webapp和simple-command中调用这两个Bean完成数据库查询工作。</li>
<li>simple-webapp：POM中加入对simple-weather和simple-persist的依赖，定义WeatherController从simple-weather获取Weather对象的数据，定义HistoryController从simple-persist获取数据库查询结果。weather-servlet.xml注册了两个controller，并定义了urlMapping以及限定了Velocity模板引擎访问资源的目录。</li>
<li>simple-command：同时依赖于simple-weather和simple-persist，执行Main方法，根据传入的参数的选择执行请求Weather或者查询相应zip code对应的城市的天气情况。</li>
<li>这种设计模式，将对象模型、数据持久层、业务层（service）、逻辑层（webapp和command）分开，五个submodule各司其职，相互之间存在依赖关系，利于项目的管理。</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro权限控制</title>
    <url>/2017/11/15/java_spring/Shiro%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h2 id="shiro实现访问权限控制和用户身份认证"><a href="#shiro实现访问权限控制和用户身份认证" class="headerlink" title="shiro实现访问权限控制和用户身份认证"></a>shiro实现访问权限控制和用户身份认证</h2><p><img src="http://wiki.jikexueyuan.com/project/shiro/images/3.png" alt="image"></p>
<h3 id="shiro的三大核心组件"><a href="#shiro的三大核心组件" class="headerlink" title="shiro的三大核心组件"></a>shiro的三大核心组件</h3><ol>
<li>Subject：即当前用户，在权限管理的应用程序里往往需要知道谁能够操作什么，谁拥有操作该程序的权利，shiro中则需要通过Subject来提供基础的当前用户信息，Subject 不仅仅代表某个用户，也可以是第三方进程、后台帐户（Daemon Account）或其他类似事物。</li>
<li>SecurityManager：即所有Subject的管理者，这是Shiro框架的核心组件，可以把他看做是一个Shiro框架的全局管理组件，用于调度各种Shiro框架的服务。</li>
<li>Realms：域，Shiro 从从 Realm 获取安全数据（如用户、角色、权限），就是说 SecurityManager 要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm得到用户相应的角色/权限进行验证用户是否能进行操作；可以把Realm看成DataSource，即安全数据源。Realms则是用户的信息认证器和用户的权限人证器，我们需要自己来实现Realms来自定义的管理我们自己系统内部的权限规则。<span id="more"></span></li>
</ol>
<h3 id="自定义Realm："><a href="#自定义Realm：" class="headerlink" title="自定义Realm："></a>自定义Realm：</h3><p><a href="https://github.com/swinglife/shiro_ex">shiro_example</a><br><a href="http://blog.csdn.net/swingpyzf/article/details/46342023/#reply">原博客地址</a></p>
<p>Shiro默认提供的Realm如下图所示：<br><img src="http://wiki.jikexueyuan.com/project/shiro/images/5.png" alt="image"><br>开发的时候选择继承自org.apache.shiro.realm.AuthorizingRealm， 本例中，继承自AuthorizingRealm并重写方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*** </span></span><br><span class="line"><span class="comment">     * 获取授权信息 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection pc)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//根据自己系统规则的需要编写获取授权信息，这里为了快速入门只获取了用户对应角色的资源url信息  </span></span><br><span class="line">        String username = (String) pc.fromRealm(getName()).iterator().next();  </span><br><span class="line">        <span class="keyword">if</span> (username != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            List&lt;String&gt; pers = accountService.getPermissionsByUserName(username);  </span><br><span class="line">            <span class="keyword">if</span> (pers != <span class="keyword">null</span> &amp;&amp; !pers.isEmpty()) &#123;  </span><br><span class="line">                SimpleAuthorizationInfo info = <span class="keyword">new</span> SimpleAuthorizationInfo();  </span><br><span class="line">                <span class="keyword">for</span> (String each : pers) &#123;  </span><br><span class="line">                    <span class="comment">//将权限资源添加到用户信息中  </span></span><br><span class="line">                    info.addStringPermission(each);  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">return</span> info;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">/*** </span></span><br><span class="line"><span class="comment">     * 获取认证信息 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken at)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;  </span><br><span class="line">        UsernamePasswordToken token = (UsernamePasswordToken) at;  </span><br><span class="line">        <span class="comment">// 通过表单接收的用户名  </span></span><br><span class="line">        String username = token.getUsername();  </span><br><span class="line">        <span class="keyword">if</span> (username != <span class="keyword">null</span> &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(username)) &#123;  </span><br><span class="line">            User user = accountService.getUserByUserName(username);  </span><br><span class="line">            <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(user.getUsername(), user.getPassword(), getName());  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在doGetAuthorizationInfo方法中，获取的权限为accountService.getPermissionsByUserName(username)方法返回的permission.url信息。表示该用户具有访问哪些url的权限。<br>在doGetAuthenticationInfo方法中，通过表单传来的用户名，从持久化层中获取对应用户名的用户信息，用于认证用户。</p>
<h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><ol>
<li><p>主体<br>主体，即访问应用的用户，在 Shiro 中使用 Subject 代表该用户。用户只有授权后才允许访问相应的资源。</p>
</li>
<li><p>资源<br>在应用中用户可以访问的任何东西，比如访问JSP页面、查看/编辑某些数据、访问某个业务方法、打印文本等等都是资源。用户只要授权后才能访问。</p>
</li>
<li><p>表示在应用中用户有没有操作某个资源的权力。反映在某个资源上的操作允不允许，不反映谁去执行这个操作。所以后续还需要把权限赋予给用户，即定义哪个用户允许在某个资源上做什么操作（权限），<strong>Shiro 不会去做这件事情，而是由实现人员提供</strong>。</p>
</li>
<li><p>角色<br>角色代表了操作集合，可以理解为权限的集合，一般情况下我们会赋予用户角色而不是权限，即这样用户可以拥有一组权限，赋予权限时比较方便<br>Shiro 不会去维护用户、维护权限；这些需要我们自己去设计 / 提供；然后通过相应的接口注入给 Shiro 即可。<br>隐式角色：<br>基于角色的访问控制。直接通过角色验证用户有没有操作某个资源的权限，默认某角色拥有哪些权限，但这些系统并没有明确定义一个角色到底包含了哪些可执行的行为。所以一旦对权限的需求有稍微的变动，就可能需要重新修改代码。比如说，用户user拥有两种角色：部门经理和项目经理，对user进行角色访问控制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(user.hasRole(DepartManager) &amp;&amp; user.hasRole(ProjectManager))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//把部门经理和项目经理的权限授予user</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候如果说用户不再拥有项目经理的权限了，就需要修改代码，将后面一条判断去掉，重新编译系统。如果需求变动大，就需要大量的代码重构。<br>显示角色：<br>基于资源的访问控制。在程序中通过权限控制谁能访问某个资源，角色聚合一组权限集合；这样假设哪个角色不能访问某个资源，只需要从角色代表的权限集合中移除即可。基于什么是受保护的， 而不是谁可能有能力做什么</p>
</li>
</ol>
<h3 id="实现用户可访问所属组织及其子组织的文件权限控制机制"><a href="#实现用户可访问所属组织及其子组织的文件权限控制机制" class="headerlink" title="实现用户可访问所属组织及其子组织的文件权限控制机制"></a>实现用户可访问所属组织及其子组织的文件权限控制机制</h3><p>由于shiro中没有定义哪个用户允许在某个资源上做什么操作（权限），需要开发人员自行实现，设计一个实现机制：<br>采用基于资源的权限控制。所需访问的文件命名为report，用户为user1，所属组织为role_parent，子组织为role_child。<br>角色权限分配如下：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[users]</span></span><br><span class="line"><span class="attr">user1</span>=<span class="number">123</span>,role_parent</span><br><span class="line"><span class="section">[roles]</span></span><br><span class="line"><span class="attr">role_child</span>=report:view</span><br><span class="line"><span class="attr">role_parent</span>=report:view</span><br></pre></td></tr></table></figure>
<p>表示user1是属于role_parent组的，且role_parent和role_child都具有查看report的权限，将以上角色权限分配规则存入数据库中。对于user1,在自定义的realm中重写doGetAuthorizationInfo方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override  </span><br><span class="line">protected AuthorizationInfo doGetAuthorizationInfo(  </span><br><span class="line">        PrincipalCollection principals)</span><br></pre></td></tr></table></figure>
<p>根据principals.getPrimaryPrincipal()方法获取user1，然后根据user1查询user1拥有的所有权限的列表list1，然后将list1中的权限通过simpleAuthorizationInfo.addStringPermission(permission)方法添加到AuthorizationInfo中，realm返回该AuthorizationInfo。实际使用的时候（比如测试时），执行tmp=subject.isPermitted(report:view)，如果tmp==true，则表示user1具有该权限。<br>简单的讲，就是要求子组织下的每个report都要事先将权限赋予其父组织，这样在处理该问题的时候较容易，而且这种机制也很容易实现，每次创建一个report的时候，就在permission表里面增加两条该report对应组织和父组织的权限记录。</p>
<p><strong>Reference:</strong><br><a href="http://wiki.jikexueyuan.com/project/shiro/">Shiro教程</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>shiro</tag>
        <tag>authorization</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot的启动流程</title>
    <url>/2017/07/25/java_spring/Spring-Boot%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>写在前面。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<p>这个是spring boot 父节点依赖,引入这个之后相关的引入就不需要添加version配置，spring boot会自动选择最合适的版本进行添加。</p>
<h1 id="1-程序启动入口"><a href="#1-程序启动入口" class="headerlink" title="1. 程序启动入口"></a>1. 程序启动入口</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(WeatherApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行SpringApplication的静态run方法，将WeatherApplication类和main方法的args作为参数传进去。</p>
<p>在下面的RestController类中定义了Web端访问的API，当访问的URL的path部分是”/“时，返回”Hello World!”</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">byIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello world！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-SpringApplication类的静态run方法的调用"><a href="#2-SpringApplication类的静态run方法的调用" class="headerlink" title="2. SpringApplication类的静态run方法的调用"></a>2. SpringApplication类的静态run方法的调用</h1><p>该方法位于org.framework.boot.SpringApplication类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Object source, String... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> run(<span class="keyword">new</span> Object[] &#123; source &#125;, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Object[] sources, String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SpringApplication(sources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从第一步中传递进来的对象和main方法参数匹配到以上代码中第一个静态run方法，该方法创建对象数组并调用第二个静态run方法，根据传入的对象数组新建SpringApplication对象并调用其非静态run方法（该方法定义将在后面章节进行介绍）。执行完后Spring容器就启动起来了。</p>
<h1 id="3-新建SpringApplication对象"><a href="#3-新建SpringApplication对象" class="headerlink" title="3.新建SpringApplication对象"></a>3.新建SpringApplication对象</h1><p>SpringApplication对象的构造方法中调用initialize方法，主要为SpringApplication对象赋一些初值。</p>
<h1 id="进入run方法"><a href="#进入run方法" class="headerlink" title="进入run方法"></a>进入run方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">        FailureAnalyzers analyzers = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.configureHeadlessProperty();</span><br><span class="line">        SpringApplicationRunListeners listeners = <span class="keyword">this</span>.getRunListeners(args);</span><br><span class="line">        listeners.starting();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">            ConfigurableEnvironment environment = <span class="keyword">this</span>.prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">            Banner printedBanner = <span class="keyword">this</span>.printBanner(environment);</span><br><span class="line">            context = <span class="keyword">this</span>.createApplicationContext();</span><br><span class="line">            <span class="keyword">new</span> FailureAnalyzers(context);</span><br><span class="line">            <span class="keyword">this</span>.prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">            <span class="keyword">this</span>.refreshContext(context);</span><br><span class="line">            <span class="keyword">this</span>.afterRefresh(context, applicationArguments);</span><br><span class="line">            listeners.finished(context, (Throwable)<span class="keyword">null</span>);</span><br><span class="line">            stopWatch.stop();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">                (<span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)).logStarted(<span class="keyword">this</span>.getApplicationLog(), stopWatch);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> context;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var9) &#123;</span><br><span class="line">            <span class="keyword">this</span>.handleRunFailure(context, listeners, (FailureAnalyzers)analyzers, var9);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(var9);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>创建应用的监听器SpringApplicationRunListeners并开始监听</p>
</li>
<li><p>加载SpringBoot配置环境(ConfigurableEnvironment)，如果是通过web容器发布，会加载StandardEnvironment，其最终也是继承了ConfigurableEnvironment</p>
</li>
<li><p>配置环境(Environment)加入到监听器对象中(SpringApplicationRunListeners)</p>
</li>
<li><p>创建run方法的返回对象：ConfigurableApplicationContext(应用配置上下文)<br>其中，createApplicationContext方法会先获取显式设置的应用上下文(applicationContextClass)，如果不存在，再加载默认的环境配置（通过是否是web environment判断），默认选择AnnotationConfigApplicationContext注解上下文（通过扫描所有注解类来加载bean），最后通过BeanUtils实例化上下文对象，并返回。</p>
</li>
<li><p>回到run方法内，prepareContext方法将listeners、environment、applicationArguments、banner等重要组件与上下文对象关联</p>
</li>
<li><p>接下来的refreshContext(context)方法(初始化方法如下)将是实现spring-boot-starter-*(mybatis、redis等)自动化配置的关键，包括spring.factories的加载，bean的实例化等核心工作。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring相关知识2</title>
    <url>/2018/11/14/java_spring/Spring%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%862/</url>
    <content><![CDATA[<h1 id="JPA-和-Mybatis"><a href="#JPA-和-Mybatis" class="headerlink" title="JPA 和 Mybatis"></a>JPA 和 Mybatis</h1><p>jpa是一套ORM规范或接口（注意Mybatis没有实现jpa），默认使用Hibernate作为ORM实现，所以一般使用Spring Data JPA即会使用Hibernate。jpa的查询语言是面向对象的而不是面向数据库的。Hibernate是一个ORM框架，它对JDBC进行了非常轻量级的对象封装，将POJO与数据库表建立映射关系，可以自动生成sql语句，使得Java程序员可以从繁琐的sql代码中解脱出来</p>
<p>DAO（数据库访问对象），在jpa里面一般叫做Repository，比如UserRepository；在Mybatis里面一般叫Mapper，比如UserMapper</p>
<p>操作数据库的对象：Hibernate中叫session，jpa中叫entityManager，Mybatis中叫SqlSession</p>
<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><p>SqlSessionFactory负责创建SqlSession，其作用域应该设置为整个应用，生命周期为应用运行时；SqlSession的实例不是线程安全的，因此不能被共享，所以其作用域是请求或者方法作用域，绝不能将SqlSession实例的引用放在一个类的静态域中，甚至一个类的实例变量都不行。如果处理一个Http请求，打开一个SqlSession，处理完成之后应立即关闭SqlSession，可以放到finally语句中执行</p>
<p>Mybatis支持动态Sql查询，即根据sql语句中前半部分的结果决定是否执行后半部分的查询或者条件<br>@Mapper注解：我猜这个注解在该mapper被调用时会自动创建一个SqlSession，执行完之后关闭这个SqlSession</p>
<h1 id="Spring-data-jpa"><a href="#Spring-data-jpa" class="headerlink" title="Spring data jpa"></a>Spring data jpa</h1><p>按照Spring Data JPA的规则自动生成sql语句，无需任何sql语句即可实现CRUD</p>
<p>比如findByNameAndPassword(String name, String password)方法，spring识别findBy作为: “select * from XXX”，sql语句的where部分则是: “where name = :name and password = :password”<br>参考： <a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/">https://docs.spring.io/spring-data/jpa/docs/current/reference/html/</a></p>
]]></content>
      <tags>
        <tag>spring</tag>
        <tag>jpa</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring相关知识</title>
    <url>/2017/07/24/java_spring/Spring%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="传统MVC控制器与RESTful-Web-Service控制器的不同"><a href="#传统MVC控制器与RESTful-Web-Service控制器的不同" class="headerlink" title="传统MVC控制器与RESTful Web Service控制器的不同"></a>传统MVC控制器与RESTful Web Service控制器的不同</h2><p> 传统MVC控制器返回的是一个数据的视图（Model），而RESTful Web Service控制器返回的是Json格式的对象</p>
<span id="more"></span>
<hr>
<h2 id="Spring的模块"><a href="#Spring的模块" class="headerlink" title="Spring的模块"></a>Spring的模块</h2><p><img src="/img/spring-overview.png" alt="image"></p>
<ul>
<li>上图中每个小单元都至少对应一个jar包，提供相应的API供使用。使用Maven工具管理Spring项目时，这些需要用到的jar包集中在用户目录下的.m2文件夹下，而不是包含在项目中。</li>
<li> 7个模块<blockquote>
<ol>
<li>Spring Core：核心容器的主要组件是BeanFactory，BeanFactory使用的是IoC模式</li>
<li>Spring Context：向Spring框架提供上下文信息的一个配置文件</li>
<li>Spring AOP：面向切面的编程</li>
<li>Spring DAO：数据访问层的设计机制，DAO模式是业务逻辑层和持久存储层之间的抽象层，避免持久化代码和业务逻辑混合在一起。</li>
<li>Spring ORM：对象/关系映射（Object/Relation Mapping），指的是自动将java对象状态映射到关系数据库中的数据上。</li>
<li>Spring Web：为基于Web的应用程序提供上下文</li>
<li>Spring MVC：控制器将接收请求，执行更新模型的操作，然后通知视图关于模型更改的消息，依据请求的状态以及请求的控制器，可以决定显示哪个视图。</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Spring的注解"><a href="#Spring的注解" class="headerlink" title="Spring的注解"></a>Spring的注解</h2><ul>
<li>@component 泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注，作用是将对象实例化到Spring容器中</li>
<li>@Service用于标注业务层组件；@Controller用于标注控制层组件（如struts中的action）；@Repository用于标注数据访问组件，即DAO组件，使用jpa访问数据库时，Repository类实现了很多数据库查询操作，方便用户进行数据库操作。</li>
<li>@componentscan标签默认情况下自动扫描指定路径下的包（含所有子包），将带有@Component、@Repository、@Service、@Controller标签的类自动注册到spring容器。对标记了 Spring的 @Required、@Autowired、JSR250的 @PostConstruct、@PreDestroy、@Resource、JAX-WS的 @WebServiceRef、EJB3的 @EJB、JPA的 @PersistenceContext、@PersistenceUnit等注解的类进行对应的操作使注解生效（包含了annotation-config标签的作用）</li>
<li>@Autowired可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。 通过 @Autowired的使用来消除 set ，get方法</li>
<li>@Order可以使数组有序，指定@Order(number)即可设定该Bean在数组中的排序值</li>
<li>@Configuration标注在类上，相当于把该类作为spring的xml配置文件中的<beans>，作用为：配置spring容器(应用上下文)</li>
<li>@Bean标注在方法上(返回某个实例的方法)，等价于spring的xml配置文件中的<bean>，作用为：注册bean对象</li>
<li>@Valid配合JSR303定义的校验类型（@NotNull，@Min等），并紧挨着一个BindingResult 参数，可以完成对Bean对象的自动校验</li>
</ul>
<h2 id="Spring的事件"><a href="#Spring的事件" class="headerlink" title="Spring的事件"></a>Spring的事件</h2><p>为Bean与Bean之间的消息通信提供支持。Spring时间的流程如下：</p>
<ol>
<li>自定义事件，继承自ApplicationEvent</li>
<li>定义事件监听器，实现ApplicationListener，并指定监听的事件类型，即第一步的自定义事件。</li>
<li>使用容器发布事件</li>
</ol>
<hr>
<h2 id="AOP（面向切面编程）"><a href="#AOP（面向切面编程）" class="headerlink" title="AOP（面向切面编程）"></a>AOP（面向切面编程）</h2><ul>
<li>Aspect（切面）：声明一个类为切面，并为该切面设置切入点（pointcut）后，切入点扫描某一个包中的某一个类中的某一个方法，在该方法被执行的时候，可以指定切面中的某一方法伴随该方法执行，可以是该方法执行之前，也可以是之后。扫描的方式可以是：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">expression=&quot;execution(* com.xrq.aop.HelloWorld.*(..))</span><br></pre></td></tr></table></figure></li>
<li>好处是可以把应用业务逻辑和系统服务分开</li>
</ul>
<h2 id="控制反转（IoC）"><a href="#控制反转（IoC）" class="headerlink" title="控制反转（IoC）"></a>控制反转（IoC）</h2><ul>
<li>对象们给出它们的依赖，而不是在代码中创建或查找依赖的对象们，即不需要new这些对象，而只需要描述如何创建这些对象。换种说法，依赖注入指的是容器负责创建对象和维护对象之间的依赖关系，而不是通过对象本身负责自己的创建和解决自己的依赖。</li>
<li>控制反转分为依赖注入（DI）和依赖查找（DL）</li>
<li>Spring IoC负责创建对象、管理对象（DI）、装配对象并管理这些对象的整个生命周期</li>
</ul>
<h2 id="深入理解Spring"><a href="#深入理解Spring" class="headerlink" title="深入理解Spring"></a>深入理解Spring</h2><h3 id="Bean的实例化"><a href="#Bean的实例化" class="headerlink" title="Bean的实例化"></a>Bean的实例化</h3><ul>
<li>Spring容器启动的过程中，会将Bean解析成Spring内部的BeanDefinition结构，之后对Bean的操作就直接对BeanDefinition进行；BeanDefinition是一个接口，是一个抽象的定义，实际使用的是他的实现类。</li>
<li>然后以beanName为key，BeanDefinition为value存储到DefaultListableBeanFactory中的beanDefinitionMap（ConcurrentHashMap类型）中，DefaultListableBeanFactory间接实现BeanFactory接口，后者是用于访问Spring Bean容器的根接口，最常用的方法就是getBean方法。DefaultListableBeanFactory间接实现了DefaultSingletonBeanRegistry，后者有一个ConcurrentHashMap类型的属性singletonObjects，用于存储单例bean，getBean方法就是从这里获取实例对象。</li>
<li>将beanName存入beanDefinitionNames（List类型）中</li>
<li>遍历beanDefinitionNames，完成对bean的实例化并填充属性。</li>
<li>实例化后将实例存入单例bean的缓存中，当调用getBean方法时，到单例bean的缓存中查找并返回这个实例</li>
</ul>
<h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><ul>
<li>创建Bean的实例</li>
<li>属性注入</li>
<li>初始化Bean<blockquote>
<ul>
<li>激活Aware方法</li>
<li>处理器应用</li>
<li>激活自定义的init方法</li>
</ul>
</blockquote>
</li>
<li>使用Bean</li>
<li>销毁</li>
</ul>
<h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><p><img src="/img/springmvc.png" alt="image"></p>
<ol>
<li>用户发送请求–&gt; DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他解析器进行处理，作为统一访问点，进行全局流程控制。</li>
<li>DispatherServlet–&gt; HandlerMapping，后者将把请求映射为HandlerExecutionChain对象（包含一个Handler处理器（页面控制器）对象、多个HandlerInterceptor拦截器）对象，通过这种策略模式，很容易添加新的映射策略</li>
<li>DispatcherServlet–&gt; HandlerAdapter，后者将会把处理器包装为适配器，从而支持多种类型的处理器</li>
<li>HandlerAdapter–&gt; 处理器功能处理方法的调用，HandlerAdapter将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理，并返回一个ModelAndView对象</li>
<li>ModelAndView的逻辑视图名–&gt; ViewResolver，ViewResolver将把逻辑视图名解析成具体的View，通过这种策略，很容易更换其他视图技术</li>
<li>View–&gt; 渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构，因此很容易支持其他视图技术</li>
<li>返回控制权给DIspatcherServlet，由DispatcherServlet返回响应给用户，流程结束</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>annotation</tag>
        <tag>spring mvc</tag>
      </tags>
  </entry>
  <entry>
    <title>java范型</title>
    <url>/2017/11/13/java_spring/java%E8%8C%83%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="self-bounded-type"><a href="#self-bounded-type" class="headerlink" title="self-bounded type"></a>self-bounded type</h2><p>形如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> BasicHolder &lt;T&gt; &#123;   </span><br><span class="line">  T element;  </span><br><span class="line">  <span class="function"><span class="keyword">void</span>  <span class="title">set</span><span class="params">(T arg)</span></span>&#123;element = arg; &#125;  </span><br><span class="line">  <span class="function">T <span class="title">get</span><span class="params">()</span></span>&#123;  <span class="keyword">return</span>  element; &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">void</span>  <span class="title">f</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    System.out.println(element.getClass().getSimpleName());  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Subtype</span>  <span class="keyword">extends</span>  <span class="title">BasicHolder</span> &lt;<span class="title">Subtype</span>&gt; </span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CRGWithBasicHolder</span> </span>&#123;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;    </span><br><span class="line">    Subtype st1 =  <span class="keyword">new</span>  Subtype()，st2 =  <span class="keyword">new</span>  Subtype();  </span><br><span class="line">    st1.set(ST2);  </span><br><span class="line">    Suntype st3 = st1.get();  </span><br><span class="line">    st1.f();  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/* Output: </span></span><br><span class="line"><span class="comment">Subtype </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在结果类中将使用确切的类型而不是基类型。所以在Subtype中，set()的参数和get()的返回类型都是子类型。</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;  </span><br><span class="line">  T element;  </span><br><span class="line">  <span class="function">SelfBounded&lt;T&gt; <span class="title">set</span><span class="params">(T arg)</span> </span>&#123;  </span><br><span class="line">    element = arg;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function">T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> element; &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自我约束需要额外的步骤来强制泛型被用作自己的约束参数</p>
<p>自我约束所要求的就是在这种继承关系中使用类：<code>class A extends SelfBounded&lt;A&gt; &#123;&#125; </code>；</p>
<p><code> class D  &#123;&#125;  class E extends SelfBounded&lt;D&gt; &#123;&#125;</code>这种方式的定义是错误的，因为D不是一个self-bounded类</p>
<p>自我约束仅限于保持继承关系：如果将SelfBounded类换成<code>class NotSelfBounded&lt;T&gt;&#123;&#125;</code>，则类型E的定义就可以通过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//: generics/SelfBoundingAndCovariantArguments.java  </span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(T arg)</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Setter</span> <span class="keyword">extends</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">Setter</span>&gt; </span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBoundingAndCovariantArguments</span> </span>&#123;  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testA</span><span class="params">(Setter s1, Setter s2, SelfBoundSetter sbs)</span> </span>&#123;  </span><br><span class="line">    s1.set(s2);  </span><br><span class="line">    <span class="comment">// s1.set(sbs); // Error:  </span></span><br><span class="line">    <span class="comment">// set(Setter) in SelfBoundSetter&lt;Setter&gt;  </span></span><br><span class="line">    <span class="comment">// cannot be applied to (SelfBoundSetter)  </span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器无法识别将基类型（即sbs）作为set()的参数传递的尝试，因为没有该签名的方法。实际上，set方法可接受的参数已经被重写了，不能再接受SelfBoundSetter类型的参数。但是，在非泛型代码中，参数类型不能随子类型而变化，故在非泛型代码中，上述s1.set(sbs)是可以通过的，调用的将是父类的set方法，即方法重载，而非方法重写。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>generic type</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot热部署</title>
    <url>/2018/01/20/java_spring/spring-boot%E7%83%AD%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="spring-boot热部署"><a href="#spring-boot热部署" class="headerlink" title="spring-boot热部署"></a>spring-boot热部署</h2><ol>
<li><p>第一种方式<br>在pom文件中的plugin下添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;springloaded&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.2.6.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>第二种方式<br>直接在pom文件中引入依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools/artifactId&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>hot deploy</tag>
      </tags>
  </entry>
  <entry>
    <title>Yarn</title>
    <url>/2018/05/11/resource_scheduling/Yarn/</url>
    <content><![CDATA[<h1 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h1><ul>
<li>编程框架和资源管理器解耦</li>
<li>以container为单位调度资源<h2 id="ResourceManager"><a href="#ResourceManager" class="headerlink" title="ResourceManager"></a>ResourceManager</h2></li>
<li>跟踪资源使用量和节点的活跃度</li>
<li>仲裁租户间的资源竞争</li>
<li>与客户端的接口，接受客户端提交的应用</li>
<li>AMService，与AM通信–接受AM资源请求并资源container给AM</li>
<li>如果应用不合作了，RM可以让NM强制关掉应用所开启的所有containers</li>
<li>RM崩溃并重启时会从持久化存储中加载其崩溃前存储的状态，并杀掉所有的容器并启动新的AM。正在尝试使RM重启时，AM可以继续运行</li>
</ul>
<span id="more"></span>

<h2 id="ApplicationMaster"><a href="#ApplicationMaster" class="headerlink" title="ApplicationMaster"></a>ApplicationMaster</h2><ul>
<li>Yarn中AM没有直接和运行的container通信，而是通过RM来完成的。<ul>
<li>NM将container信息报告给RM，RM将container信息发送给AM</li>
</ul>
</li>
<li>AM也可以指导NM杀掉container</li>
<li>AM崩溃的话，不会持久化崩溃前的状态。故AM重启会使所有正在运行的或者已经完成的任务重新运行。</li>
</ul>
<h2 id="NodeManager"><a href="#NodeManager" class="headerlink" title="NodeManager"></a>NodeManager</h2><ul>
<li>NM验证AM获得的lease（租约）的可用性后，配置容器的环境。需要复制所有需要的依赖到本地存储中</li>
<li>NM一旦出错，运行在其上的任务都会被认为出错了。<ul>
<li>NM重启时，会清掉所有本地状态</li>
<li>NM出错，AM负责处理该节点出错导致的任务出错问题。即将出错时运行在该NM上的任务重新运行一遍（重新向RM申请资源）。</li>
</ul>
</li>
</ul>
<h2 id="应用程序生命周期"><a href="#应用程序生命周期" class="headerlink" title="应用程序生命周期"></a>应用程序生命周期</h2><ul>
<li>用户通过CLC（容器启动上下文）提交应用程序给RM</li>
<li>RM指定NM运行ApplicationMaster，AM使用心跳向RM报告其活跃度和资源需求</li>
<li>RM收到AM的资源请求，使用准入控制机制：根据应用需求、调度优先级和资源可用性向AM以container的形式提供资源。RequestResource包括：<ul>
<li>container数目</li>
<li>每个container的资源数目</li>
<li>数据本地性偏好</li>
<li>应用中请求的优先级</li>
</ul>
</li>
<li>AM获得资源，构造一个CLC在相关NM上启动拿到的container。AM可通过RM来监控container的状态</li>
<li>AM运行完成后，向RM注销并干净的退出</li>
</ul>
]]></content>
      <categories>
        <category>Resource Management</category>
      </categories>
      <tags>
        <tag>scheduling</tag>
        <tag>yarn</tag>
      </tags>
  </entry>
  <entry>
    <title>cgroups</title>
    <url>/2018/05/13/resource_scheduling/cgroups/</url>
    <content><![CDATA[<h1 id="Cgroups"><a href="#Cgroups" class="headerlink" title="Cgroups"></a>Cgroups</h1><p>安装libcgroup （yum install libcgroup）</p>
<ul>
<li>一个css_set关联多个 cgroups 层级结构的节点时，表明需要对当前css_set下的进程进行多种资源的控制。而一个 cgroups 节点关联多个css_set时，表明多个css_set下的进程列表受到同一份资源的相同限制。</li>
<li>cgroups 也是通过 VFS 把功能暴露给用户态的，cgroups 与 VFS 之间的衔接部分称之为 cgroups 文件系统。VFS本身就是用 c 语言实现的一套面向对象的接口。</li>
<li>Linux中，用户可以使用mount命令挂载 cgroups 文件系统</li>
</ul>
<h2 id="cpu子系统和cpuacct子系统"><a href="#cpu子系统和cpuacct子系统" class="headerlink" title="cpu子系统和cpuacct子系统"></a>cpu子系统和cpuacct子系统</h2><ul>
<li>cpu子系统用来做cpu资源隔离，而cpuacct子系统是用来做cpu资源统计的</li>
<li>cpu子系统通过cpu.shares来保证任务最少可以使用的cpu资源数目</li>
<li>在cgroup挂载目录/sys/fs/cgroup/cpu里面新建一个目录比如test，则test会被自动加入到cpu子系统中去<h3 id="让job运行在cgroup中"><a href="#让job运行在cgroup中" class="headerlink" title="让job运行在cgroup中"></a>让job运行在cgroup中</h3>安装libcgroup-tools （yum install libcgroup-tools），使用cgexec执行hello.sh脚本如下：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">i=0</span><br><span class="line"><span class="keyword">while</span>(( <span class="variable">$i</span>&lt;10000 ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;hello <span class="variable">$i</span>\n&quot;</span></span><br><span class="line">  <span class="built_in">let</span> <span class="string">&quot;i++&quot;</span></span><br><span class="line">  sleep 1</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
执行<code>cgexec -g cpu:test ./hello.sh</code>，则hello.sh将运行在test cpu子系统中，进入/sys/fs/cgroup/test查看tasks可以看到hello.sh脚本运行时对应的pid</li>
</ul>
<h3 id="CPU子系统字段"><a href="#CPU子系统字段" class="headerlink" title="CPU子系统字段"></a>CPU子系统字段</h3><ul>
<li>cpu.cfs_period_us 为cfs调度器的一个时间周期的长度，默认为100000，即100000ns=100ms</li>
<li>cpu.cfs_quota_us 为只能使用0.5个cpu</li>
<li>cpuacct.stat 报告cgroup的所有任务（包括其子孙层级中的所有任务）使用的用户和系统CPU时间。user和system代表用户态和内核态，单位为USER_HZ</li>
</ul>
<h3 id="如何计算容器CPU利用率"><a href="#如何计算容器CPU利用率" class="headerlink" title="如何计算容器CPU利用率"></a>如何计算容器CPU利用率</h3><p>Linux Kernel 将 CPU 使用的信息记录在了 /proc/stat 这个文件中，该文件中记录了，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@sean ~]<span class="comment"># cat /proc/stat</span></span><br><span class="line">cpu  1344357 729 298522 107841813 41774 0 1754 0 0 0</span><br><span class="line">cpu0 1344357 729 298522 107841813 41774 0 1754 0 0 0</span><br><span class="line">intr 206534153 29 10 0 0 154 .......</span><br><span class="line">ctxt 317949799</span><br><span class="line">btime 1524823711</span><br><span class="line">processes 677986</span><br><span class="line">procs_running 3</span><br><span class="line">procs_blocked 0</span><br><span class="line">softirq 66031632 2 35326999 1 2928073 535817 0 32 0 0 27240708</span><br></pre></td></tr></table></figure>
<p>该文件记录了所有进程花费的总的cpu时间，第一行所有项（user、nice、system、idle等）之和就是所有cpu从开机到现在的总CPU时间Tmachine。单位是纳秒</p>
<p>容器使用的CPU时间Tcontainer可以从 cpuacct/cpuacct.usage 中获得，单位是纳秒；也可以从<code>cpuacct/stat</code>中获得，包括user和system，单位是 <code>USER_HZ</code>，一般为100，故<code>cpuacct/stat</code>中的值一般乘以<code>1/100</code>就是秒为单位。</p>
<p>则容器的cpu利用率为：<code>(Tcontainer - prevTcontainer) / (Tmachine - prevTmachine)</code></p>
]]></content>
      <categories>
        <category>Resource Management</category>
      </categories>
      <tags>
        <tag>cgroups</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes搭建</title>
    <url>/2018/07/09/resource_scheduling/kubernetes-%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="使用kubeadm安装kubernetes"><a href="#使用kubeadm安装kubernetes" class="headerlink" title="使用kubeadm安装kubernetes"></a>使用kubeadm安装kubernetes</h1><h2 id="预备条件"><a href="#预备条件" class="headerlink" title="预备条件"></a>预备条件</h2><ul>
<li>/etc/hosts文件</li>
<li>关闭firewall</li>
<li>关闭selinux</li>
<li>关闭swap</li>
<li>iptables参数<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat &lt;&lt;<span class="string">EOF &gt;  /etc/sysctl.d/k8s.conf</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables = 1</span></span><br><span class="line"><span class="string">net.ipv4.ip_forward = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">$ sysctl --system</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="按照官网安装kubernetes"><a href="#按照官网安装kubernetes" class="headerlink" title="按照官网安装kubernetes"></a>按照官网安装kubernetes</h2><a href="https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/">create-cluster-kubeadm</a></li>
</ul>
<p>确保docker和kubelet使用相同的cgroup driver(cgroupfs or systemd)</p>
<p>有些镜像需要外网才能pull下来，可以使用shadowsocks开一个http代理，服务器指定http代理pull镜像（注意接网线，要不然找不到地址。。）</p>
<p>执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl init --kubernetes-version=v.1.11.0 --pod-network-cidr=10.244.0.0/16 --apiserver-advertise-address=[master-ip]</span><br></pre></td></tr></table></figure>
<p>关闭http_proxy，不然最后init不成功，<code>--kubernetes-version</code>需要加上，不然需要连接外网获取version。总结就是要连外网的时候挂代理，不用的时候（连接集群中的某些机器时）把代理去掉。</p>
<p><code>--pod-network-cidr=10.244.0.0/16</code>的意思是设置cidr（无类别域间路由），使10.244.0.0/16网段的路由都通过10.244.0.0网络号转发（就是所谓的网络地址斜杠标记法），在node加入k8s集群之后，pod network(eg. flannel)会自动为其他node分配一个10.244.0.0/16网段的一个子网，如10.244.1.0/24</p>
<p>安装dashboard后，要通过其他机器浏览器访问ui，需要开启kube-proxy，执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl proxy --address 0.0.0.0 --port=8181 --accept-hosts=<span class="string">&#x27;^*$&#x27;</span></span><br></pre></td></tr></table></figure>
<p>保证接受任何ip、任何host发送的请求</p>
<h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><h3 id="镜像需要从外网获取"><a href="#镜像需要从外网获取" class="headerlink" title="镜像需要从外网获取"></a>镜像需要从外网获取</h3><p>执行<code>kubectl get pods --all-namespaces</code>观察到有很多pods的状态不是running，其实是一些镜像没能pull下来<br><img src="/img/pod_error.png" alt="image"><br>将这些镜像pull下来传到registry，然后每个node上从registry pull镜像，再tag称官方的镜像名。</p>
<p>kubernetes-dashboard也一样要pull镜像下来，开启kube-proxy后，浏览器访问 <a href="http://n167:8181/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/">n167:8181/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy</a> 或者<a href="n167:6443/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/">n167:6443/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/</a>即可进入登录界面。（提示services &quot;https:kubernetes-dashboard:&quot; is forbidden: User &quot;system:anonymous&quot; cannot get services/proxy in the namespace &quot;kube-system&quot;时表示用户未认证，需要生成证书，使用openssl生成p12证书，然后在浏览器导入该证书，才能从个人电脑上访问服务器的dashboard）</p>
<h3 id="pod-network"><a href="#pod-network" class="headerlink" title="pod network"></a>pod network</h3><p>不要单独用calico做proxy和networking，否则k8s集群内部pods之间无法通信，最大的影响是heapster不能集成，看不到配置字典等。推荐使用canal pod network，它使用calico做proxy，flannel做networking。</p>
<p><strong>targetPort表示容器内部的端口，port表示Service的虚拟端口，不要搞反了</strong>；targetPort只在service起作用，表示用来访问该service对应的容器的内部containerPort；外部系统只要用任意一个Node的IP地址+nodePort即可访问到相应的服务（即使该服务只运行在一个node上，也可以通过任意一个node访问到该服务）</p>
<h3 id="cluster-reset"><a href="#cluster-reset" class="headerlink" title="cluster reset"></a>cluster reset</h3><p>集群重置过后，再从浏览器登录的时候，由于之前的证书已经失效，需要重新导入证书，将之前的证书删除</p>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>cluster IP无法被ping通，因为没有“实体对象”响应单独的clusterIP，不具备TCP/IP通信的基础。当通过域名（如nginx.default.svc）访问应用时，实际上是通过service访问的，k8s内部会将该域名解析为service的clusterIP，所以在集群中是不能ping通某个域名，但是可以走http协议（如curl命令）拿到该域名对应端口的内容，注意端口应该使用Service的虚拟端口port，而不是容器内部的端口targetPort（如nginx.default.svc:8080）</p>
<p>kubernetes 集群中service可以映射的物理机端口范围默认为30000~32767</p>
<p>Replica Set就是Replication Controller，只是比后者多了一个支持集合的Label Selector，RS一般不单独使用，主要是被Deployment这个更高层的资源对象使用，RS负责Deployment的自动扩容</p>
<h3 id="三种方式访问nginx服务器"><a href="#三种方式访问nginx服务器" class="headerlink" title="三种方式访问nginx服务器"></a>三种方式访问nginx服务器</h3><ul>
<li>podIP:port  只能在本机上访问</li>
<li>clusterIP:targetPort  只能在集群内访问</li>
<li>nodeIP:nodePort  可以在外网访问（只要nodeIP可以出外网）</li>
</ul>
<h3 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h3><p>kubelet需要一个read-only-port，监听其他pod的请求，使用安装完kubelet之后默认为启用该port。在<code>/etc/systemd/system/kubelet.service.d/10.kubeadm.conf</code>中加入<code>Environment=&quot;KUBELET_READ_ONLY_PORT=--read-only-port=10255&quot;</code>，并在Execstart后接上该环境变量<code>$KUBELET_READ_ONLY_PORT</code>，完整的文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Note: This dropin only works with kubeadm and kubelet v1.11+</span><br><span class="line">[Service]</span><br><span class="line">Environment=&quot;KUBELET_KUBECONFIG_ARGS=--bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf&quot;</span><br><span class="line">Environment=&quot;KUBELET_CONFIG_ARGS=--config=/var/lib/kubelet/config.yaml&quot;</span><br><span class="line"># This is a file that &quot;kubeadm init&quot; and &quot;kubeadm join&quot; generates at runtime, populating the KUBELET_KUBEADM_ARGS variable dynamically</span><br><span class="line">EnvironmentFile=-/var/lib/kubelet/kubeadm-flags.env</span><br><span class="line"># This is a file that the user can use for overrides of the kubelet args as a last resort. Preferably, the user should use</span><br><span class="line"># the .NodeRegistration.KubeletExtraArgs object in the configuration files instead. KUBELET_EXTRA_ARGS should be sourced from this file.</span><br><span class="line">EnvironmentFile=-/etc/sysconfig/kubelet</span><br><span class="line">Environment=&quot;KUBELET_READ_ONLY_PORT=--read-only-port=10255&quot;</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/usr/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_CONFIG_ARGS $KUBELET_KUBEADM_ARGS $KUBELET_EXTRA_ARGS $KUBELET_READ_ONLY_PORT</span><br></pre></td></tr></table></figure>

<h3 id="更换网卡"><a href="#更换网卡" class="headerlink" title="更换网卡"></a>更换网卡</h3><p>需要修改flannel网络</p>
<ul>
<li>到～/kubernetes/flannel下面修改kube-flannel.yml，因为机器是amd64的，所以修改DaemonSet kube-flannel-ds-amd64的container kube-flannel的args的–iface=p3p2，改成某一张网卡设备</li>
<li>重启每台机器上的kube-flannel</li>
<li>如果遇到同一台机器上两个service之间不能通信的问题，可能是iptables被跳过了，应该将下面两项置为1<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;<span class="string">EOF &gt;  /etc/sysctl.d/k8s.conf</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">sysctl --system</span><br></pre></td></tr></table></figure></li>
<li>改变每台机器上的internal ip：在/etc/hosts里面加入<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10.0.1.167  n167.njuics.cn</span><br><span class="line">10.0.1.168  n168.njuics.cn</span><br><span class="line">10.0.1.169  n169.njuics.cn</span><br><span class="line">10.0.1.170  n170.njuics.cn</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Resource Management</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes</title>
    <url>/2018/09/10/resource_scheduling/kubernetes/</url>
    <content><![CDATA[<h1 id="设计架构"><a href="#设计架构" class="headerlink" title="设计架构"></a>设计架构</h1><h2 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h2><p>k8s的有两步调度策略</p>
<ul>
<li><p>预选策略(predicates)：强制性规则，遍历所有Node，选择满足要求的Node列表。v1.7支持15种策略</p>
<ul>
<li>PodFitsResources：检查主机资源是否满足pod需求</li>
<li>NoDiskConfilict：检查主机上的卷冲突</li>
<li>MatchInterPodAffinity：检查pod和其他pod是否符合亲和性规则</li>
</ul>
</li>
<li><p>优选策略(Priorities)：在预选策略的基础上，给Node打分排序，选出最优者。v1.7支持10个策略，每项策略对应一个权重，每项策略的得分乘以权重得到总分</p>
<ul>
<li>ImageLocalityPriority：根据主机上是否已具备Pod运行的环境来打分，得分计算：不存在所需镜像，返回0分，存在镜像，镜像越大得分越高</li>
<li>LeastRequestedPriority：计算Pods需要的CPU和内存在当前节点可用资源的百分比，具有最小百分比的节点就是最优，得分计算公式：cpu((capacity – sum(requested)) * 10 / capacity) + memory((capacity – sum(requested)) * 10 / capacity) / 2</li>
</ul>
<span id="more"></span></li>
</ul>
<h2 id="Serviceaccount"><a href="#Serviceaccount" class="headerlink" title="Serviceaccount"></a>Serviceaccount</h2><p>一个角色拥有指定的资源权限（可以访问k8s里面的哪些资源，如pods、sercices等）和功能权限（CRUD），通过将RoleBinding将一个role绑定到某个serviceaccount上，即可让资源可通过serviceaccount来访问。关系图如下：<br><img src="/img/resource--role.png" alt="image"></p>
<h2 id="NodeStatus"><a href="#NodeStatus" class="headerlink" title="NodeStatus"></a>NodeStatus</h2><p>在所有的 zones 都不健康（也即集群中没有健康 node）的极端情况下，node controller 将假设 master 的连接出了某些问题，它将停止所有删除动作直到一些连接恢复</p>
<h2 id="containerd-架构"><a href="#containerd-架构" class="headerlink" title="containerd 架构"></a>containerd 架构</h2><p><a href="https://containerd.io/">https://containerd.io/</a><br><img src="/img/architecture.png" alt="architecture"></p>
<h2 id="存储拓扑调度"><a href="#存储拓扑调度" class="headerlink" title="存储拓扑调度"></a>存储拓扑调度</h2><p>在k8s中，存储是以PVC-StorageClass-PV的形式产生的，而存储的调度和pod的调度是两个并行的操作（前者由PV controller调度，后者由scheduler调度），所以两个并行独立的调度过程就很可能导致最终的存储访问不满足nodeAffinity的需求（比如pod和PV分别被调度到两个不同的region，而这两个region不能互相访问存储）。为了解决这个问题，k8s使用了存储拓扑调度，即将PV和PVC的binding操作和动态创建PV的操作做了delay，delay到pod调度结果出来之后，再去做这两个操作。使得最终选择的node既满足pod的计算资源需求，又满足pod的PV的nodeAffinity需求。需求对一些组件进行改动：</p>
<ol>
<li>PV controller需求支持延迟binding</li>
<li>动态生成PV的组件。pod调度结果出来之后，根据pod的拓扑信息动态创建PV</li>
<li>kube-scheduler：在选择node的时候考虑计算资源的同时，需要考虑pod对存储的需求，即看选择的node是否能满足和PVC匹配的PV的nodeAffinity需求。<br>动态创建PV的拓扑限制需要保证两方面：一是动态创建出来的存储要能被这个可用区访问；二是调度器在选择node的时候，要落在这个可用区内。</li>
</ol>
<p>k8s中支持使用Snapshot来进行存储快照，持久化卷</p>
]]></content>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>资源调度</title>
    <url>/2018/09/10/resource_scheduling/%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="领域相关"><a href="#领域相关" class="headerlink" title="领域相关"></a>领域相关</h1><p>阿里禁用iptables，不用iptables做转发</p>
<h1 id="容器调度相关"><a href="#容器调度相关" class="headerlink" title="容器调度相关"></a>容器调度相关</h1><ul>
<li>Google无疑是最有技术敏锐性和市场敏锐性的，早早的看到了Docker企业级市场的企图心，所以Google是第一个支持Docker的竞争对手—-CoreOS的Rocket容器，2014年四月份谷歌风险投资公司牵头对CoreOS进行了1200万美元的投资，目标明确—-对准docker。Google不再是Docker+ kubernetes,而是<strong>容器抽象</strong>+ kubernetes，即不止支持docker</li>
<li>Redhat的OpenShift公有云还是OpenShift V2，V3采用Docker+k8s，很难从V2升级到V3。</li>
</ul>
<h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><p>Hadoop第一代产品使用HDFS，处理MapReduce作业的时候设计频繁的HDFS读写操作，如下图：<br><img src="/img/spark1.png" alt="mapreduce"><br>而Spark使用内存替代了使用HDFS保存中间结果，使用弹性分布数据集（RDD），使得分布式对象集合可以跨集群在内存中访问和保存，大大减少了作业加载数据的时间开销。当有数据丢失时，RDD会跟踪并重新计算得到丢失的数据。Spark的性能是MapReduce的40倍</p>
]]></content>
      <tags>
        <tag>scheduling</tag>
      </tags>
  </entry>
  <entry>
    <title>集群相关知识</title>
    <url>/2018/04/10/resource_scheduling/%E9%9B%86%E7%BE%A4%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="Marathon"><a href="#Marathon" class="headerlink" title="Marathon"></a>Marathon</h1><h2 id="应用重启"><a href="#应用重启" class="headerlink" title="应用重启"></a>应用重启</h2><ul>
<li>重启方式：marathon会根据mesos发送过来的offer把该服务在任意一台服务器上重启，故引入两个问题：<ul>
<li>如果这个服务是有状态的，那么它再次在另外的机器上启动之后，怎么恢复它的状态？Marathon支持本地的持久化卷来解决这个问题</li>
<li>如果这个服务之前作为其他服务的后端，或者有外部的客户端和它进行通信，那么当他启动到别的机器上之后，IP地址发生了变化，那么其他服务和外部的客户端改怎么和新的服务进行通信？Marathon支持Service Discovery的方式来解决这个问题</li>
</ul>
</li>
<li>提供沙箱机制来管理每个应用的实例</li>
<li>Rolling Upgrade的支持：即应用程序新版本发布后可以在不中断服务的情况下升级到新版本</li>
<li>支持高可用：只需要启动多个Marathon的服务并且指定一个相同的Zookeeper路径，Zookeeper会提供多个Marathon服务之间的Leader选举。并且用户可以在Marathon的非leader节点上操作，而不是像Mesos那样会跳转到leader节点</li>
</ul>
<h2 id="Marathon-lb"><a href="#Marathon-lb" class="headerlink" title="Marathon-lb"></a>Marathon-lb</h2><p>Marathon-lb是个基于HAProxy的快速代理和负载均衡。它能为基于TCP和HTTP协议的应用提供代理和负载均衡，此外还支持SSL、健康检查、HTTP压缩、Lua脚本等特性。Marathon-lb通过Marathon的EventBus可以自动获取Marathon上每个应用的信息，并且能够为每组应用生成HAProxy配置。不同于通过域名机制来发现服务的Mesos-DNS，Marathon-lb是通过servicePort服务端口来发现服务外，另外，还可以通过VHOST来访问服务。</p>
<ul>
<li>问题：Marathon通过一个json配置文件启动两个Nginx服务的instance，此时只生成一个marathon-lb的servicePort？并且通过这一个servicePort可以访问两个Nginx服务吗？<ul>
<li>只生成一个servicePort，通过这个servicePort可以访问这两个Nginx服务，marathon-lb为这两个Nginx服务生成HAProxy配置，通过HAProxy来实现负载均衡，应用层–http层的负载均衡</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="SNAT"><a href="#SNAT" class="headerlink" title="SNAT"></a>SNAT</h2><p>私网中的主机请求外网时，在可以连接外网的主机上修改请求的源IP地址，起到隐藏私网主机的作用，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -s 10.1.1.0/24 -j SNAT --to-source 公网IP</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-t nat</code>表示修改nat表</li>
<li><code>-A POSTROUTING</code>表示将SNAT规则加入到POSTROUTING链中，SNAT只存在于POSTROUTING和INPUT链中。POSTROUTING是iptables中报文发出去的最后一个关卡，故确保报文发出去之前修改源IP地址。</li>
<li><code>-s 10.1.1.0/24 --to-source 公网IP</code>表示将来自内网10.1.1.0/24网段的请求的源IP地址改为公司内部可以出外网的IP<br>如果外网IP时动态的，则使用MASQUERADE：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -s 10.1.1.0/24 -o eth0 -j MASQUERADE</span><br></pre></td></tr></table></figure>
<code>-o eth0 -j MASQUERADE</code>表示将内网中来自10.1.1.0/24网段的请求的源IP地址指向网卡eth0对应的IP地址，起到一个IP地址的动态装换</li>
</ul>
<h2 id="DNAT"><a href="#DNAT" class="headerlink" title="DNAT"></a>DNAT</h2><p>公网中的主机请求内网中的主机上的服务的时候，可以在能出外网的主机上修改请求的目的IP地址，即可使外网访问内网的服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -t nat -I PREROUTING -d 公网IP -p tcp --dport 公网端口 -j DNAT --to-destination 私网IP:端口号</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-I PREROUTING</code>表示将DNAT规则加入PREROUTING链中，DNAT只存在于PREROUTING和OUTPUT链中。PREROUTING是在路由器路由之前，如果不在这儿修改目的IP地址，则路由器会根据原来的IP地址转发该报文</li>
<li><code>-d 公网IP -p tcp --dport 公网端口 --to-destination 私网IP:端口号</code>公网主机首先向公司可以出外网的IP地址请求，这里表示将此IP地址的tcp的公网端口改为内网:端口。</li>
</ul>
<h2 id="HTTPS通信"><a href="#HTTPS通信" class="headerlink" title="HTTPS通信"></a>HTTPS通信</h2><p>过程如图：<br><img src="/img/https_process.png" alt="image"></p>
<ul>
<li>浏览器发送https连接请求</li>
<li>服务器向客户端返回证书</li>
<li>浏览器生成一串随机数，用证书加密，发送给服务器端。该随机数用作之后通信的对称秘钥</li>
<li>服务器使用私钥对浏览器发送过来的加密的数据进行解密，拿到对称秘钥，并使用该对称秘钥加密一段握手消息发送给浏览器</li>
<li>浏览器使用对称秘钥解密握手消息，并使用该对称秘钥加密ACK通知服务器通信已建立</li>
<li>之后浏览器和服务器之间的通信的数据就是用浏览器之前生成的那串随机对称秘钥并利用对称加密算法进行加密</li>
</ul>
<h2 id="HTTP请求消息"><a href="#HTTP请求消息" class="headerlink" title="HTTP请求消息"></a>HTTP请求消息</h2><p><img src="/img/http_request.png" alt="image"></p>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:<br>1xx：指示信息–表示请求已接收，继续处理<br>2xx：成功–表示请求已被成功接收、理解、接受<br>3xx：重定向–要完成请求必须进行更进一步的操作<br>4xx：客户端错误–请求有语法错误或请求无法实现<br>5xx：服务器端错误–服务器未能实现合法的请求</p>
<h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><ul>
<li><a href="http://geek.csdn.net/news/detail/89370">Marathon的主要功能</a></li>
<li><a href="https://blog.csdn.net/felix_yujing/article/details/52081524">关于Marathon-lb</a></li>
<li>RaphetS 链接：<a href="https://www.jianshu.com/p/80e25cb1d81a">https://www.jianshu.com/p/80e25cb1d81a</a> 來源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</li>
</ul>
]]></content>
      <categories>
        <category>Resource Management</category>
      </categories>
      <tags>
        <tag>marathon</tag>
      </tags>
  </entry>
  <entry>
    <title>Haproxy</title>
    <url>/2018/04/10/system_management/Haproxy/</url>
    <content><![CDATA[<h1 id="四层和七层负载均衡的区别"><a href="#四层和七层负载均衡的区别" class="headerlink" title="四层和七层负载均衡的区别"></a>四层和七层负载均衡的区别</h1><ul>
<li>四层负载均衡<ul>
<li>主要是分析IP和TCP/UDP流量实现的基于IP加端口的负载均衡。常见的四层负载均衡优LVS和F5。</li>
<li>以TCP请求为例。客户端将SYN请求发送到负载均衡器，负载均衡器会根据一个负载均衡算法选择一个合适的后端服务器，并修改SYN请求的目标地址，将SYN请求转发到相应的后端服务器。此过程可以看出<em>客户端和服务器之间是直接建立TCP连接的，而负载均衡器相当于实现了路由器的路由转发功能</em>；在转发报文的时候，还可修改报文的目标地址，服务器返回的报文可以正确的传递黑负载均衡器。</li>
</ul>
</li>
<li>七层负载均衡<ul>
<li>也称七层交换机（内容交换器）。主要是根据应用层的诸如HTTP、FTP、SMTP等协议的报文内容，配合负载均衡算法来选择后端服务器。比如对Web服务器的负载均衡，不但可以通过IP+端口的方式进行负载均衡，还可以通过URL、域名、浏览器类别或者语言等进行负载均衡。比如可以实现不同域名访问不同的网站的功能。常见的七层负载均衡器有HAProxy、Nginx等。</li>
<li>以TCP请求为例。客户端向七层负载均衡器发送SYN请求，由于此时还未建立TCP连接，客户端还未发送应用层请求报文，负载均衡器则代替后端服务器与客户端建立TCP连接。然后客户端将请求报文发送给负载均衡器，后者根据报文的内容采用负载均衡算法选择一个合适的后端服务器，并与该后端服务器建立TCP连接。在这个过程中，负载均衡器相当于一个代理服务器。</li>
</ul>
</li>
</ul>
<span id="more"></span>

<p>参考原文：<a href="https://www.cnblogs.com/skyflask/p/6970151.html">https://www.cnblogs.com/skyflask/p/6970151.html</a></p>
]]></content>
      <categories>
        <category>Resource Management</category>
      </categories>
      <tags>
        <tag>haproxy</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习心得</title>
    <url>/2017/08/05/system_management/Linux%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="TTY"><a href="#TTY" class="headerlink" title="TTY"></a>TTY</h3><p>TeleTYpe的简称，用来新建一个终端来和计算机交互，TTY Driver会根据为每一个终端创建一个TTY设备</p>
<p>可以把TTY理解为一个管道，从一端写入的内容可以从另一端读出来</p>
<p>ssh可以远程连接计算机，但一旦这个连接断掉了，内核会给和该tty相关的进程发送SIGHUP信号，进程收到信号之后的默认操作是推出进程。这样一旦连接断掉，之前跑的东西就都停掉了，对于远程连接服务器跑实验来说无疑是不可接受的。tmux可以解决这个问题，tmux用来为ssh连接远程计算机。ssh客户端发送过来的数据包都会被tmux客户端接收到，然后tmux转发给tmux服务端，由服务端完成和远程计算机的交互</p>
<p>常用命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># creates a new tmux session named session_name</span></span><br><span class="line">$ tmux new -s session_name</span><br><span class="line"><span class="comment"># attaches to an existing tmux session named session_name</span></span><br><span class="line">$ tmux attach -t session_name</span><br><span class="line"><span class="comment"># switches to an existing session named session_name</span></span><br><span class="line">$ tmux switch -t session_name</span><br><span class="line"><span class="comment"># lists existing tmux sessions</span></span><br><span class="line">$ tmux list-sessions</span><br><span class="line"><span class="comment"># detach the currently attached session. ctrl-b + d means press key combination ctrl-b, then release the key combination, and then press key d</span></span><br><span class="line">$ tmux detach (ctrl-b + d)</span><br></pre></td></tr></table></figure>

<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>linux刚安装系统如果上不了网，检查<code>/etc/sysconfig/network-scripts/</code>下面的网卡是否挂载，尝试<code>ifup eth0</code>，这里的eth0表示网卡名称</p>
]]></content>
      <categories>
        <category>System</category>
      </categories>
  </entry>
  <entry>
    <title>elasticsearch configuration</title>
    <url>/2018/05/30/system_management/elasticsearch-configuration/</url>
    <content><![CDATA[<h2 id="DC上配置elasticsearch"><a href="#DC上配置elasticsearch" class="headerlink" title="DC上配置elasticsearch"></a>DC上配置elasticsearch</h2><h3 id="配置node-master"><a href="#配置node-master" class="headerlink" title="配置node-master"></a>配置node-master</h3><ul>
<li>在n125上，新建/etc/elasticsearch/elasticsearch.yml<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cluster.name:</span> <span class="string">elasticsearch_cluster</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">node-master</span></span><br><span class="line"><span class="attr">node.master:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">node.data:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9200</span></span><br><span class="line"><span class="attr">transport.tcp.port:</span> <span class="number">9300</span></span><br><span class="line"><span class="attr">transport.type:</span> <span class="string">netty3</span></span><br><span class="line"><span class="attr">http.type:</span> <span class="string">netty3</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="attr">network.publish_host:</span> <span class="string">esmaster.elsearch.crawl-mesos-project.menya.marathon.mesos</span></span><br><span class="line"><span class="attr">discovery.zen.ping.unicast.hosts:</span> [<span class="string">&quot;esmaster.elsearch.crawl-mesos-project.menya.marathon.mesos:9300&quot;</span>]</span><br><span class="line"><span class="attr">discovery.zen.ping_timeout:</span> <span class="string">3s</span></span><br></pre></td></tr></table></figure></li>
<li>新建/data/crawl-es-data目录</li>
<li>执行<code>sysctl -w vm.max_map_count=262144</code>将机器的<code>vm.max_map_count</code>调高一些</li>
<li>DC上创建service，id为<code>menya/crawl-mesos-project/elsearch/esmaster</code>，网络类型选择<code>VirtualNetwork</code>，指定镜像并根据官方镜像说明，传入一些环境变量</li>
<li>运行service<h3 id="配置node-data"><a href="#配置node-data" class="headerlink" title="配置node-data"></a>配置node-data</h3></li>
<li>在n138上，新建/etc/elasticsearch/elasticsearch.yml<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cluster.name:</span> <span class="string">elasticsearch_cluster</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">node-data-1</span></span><br><span class="line"><span class="attr">node.master:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">node.data:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9200</span></span><br><span class="line"><span class="attr">transport.tcp.port:</span> <span class="number">9300</span></span><br><span class="line"><span class="attr">transport.type:</span> <span class="string">netty3</span></span><br><span class="line"><span class="attr">http.type:</span> <span class="string">netty3</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="attr">network.publish_host:</span> <span class="string">esnode1.elsearch.crawl-mesos-project.menya.marathon.mesos</span></span><br><span class="line"><span class="attr">discovery.zen.ping.unicast.hosts:</span> [<span class="string">&quot;esmaster.elsearch.crawl-mesos-project.menya.marathon.mesos:9300&quot;</span>]</span><br><span class="line"><span class="attr">discovery.zen.ping_timeout:</span> <span class="string">3s</span></span><br></pre></td></tr></table></figure></li>
<li>新建/data/crawl-es-data目录</li>
<li>执行<code>sysctl -w vm.max_map_count=262144</code>将机器的<code>vm.max_map_count</code>调高一些</li>
<li>DC上创建service，id为<code>menya/crawl-mesos-project/elsearch/esnode1</code>，网络类型选择<code>VirtualNetwork</code>，指定镜像并根据官方镜像说明，传入一些环境变量</li>
<li>运行service</li>
<li>同理，在n126上创建node-data-2。</li>
</ul>
<p>如此，就会创建一个包含node-master、node-data-1和node-data-2的elasticsearch集群。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>n125–esmaster<br>n138–esnode1<br>n126–esnode2</p>
<h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><ul>
<li><code>sysctl -w vm.max_map_count=262144</code>一定要在elasticsearch容器运行的宿主机上执行，不然会报错说<code>vm.max_map_count</code>太小</li>
<li>如果一直dataNode节点一直连接不上node-master<ul>
<li>首先看dataNode节点解析的<code>esmaster.elsearch.crawl-mesos-project.menya.marathon.mesos</code>地址对不对，如果不对可能是DNS缓存的问题，重启一下dataNode</li>
<li>如果地址解析正确，则有可能是超时响应，提示<code>time out</code>，则将超时时间设置长一点，如设置为3s：<code>discovery.zen.ping_timeout: 3s</code></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>win10 ubuntu子系统的学习心得</title>
    <url>/2017/07/23/system_management/win10-ubuntu%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h2 id="Ubuntu子系统的文件存放位置"><a href="#Ubuntu子系统的文件存放位置" class="headerlink" title="Ubuntu子系统的文件存放位置"></a>Ubuntu子系统的文件存放位置</h2><blockquote>
<p>网上搜索说在C:\Users\lqp19\AppData\Local\lxss目录下面，但本机上没有这个目录</p>
</blockquote>
<span id="more"></span>
<p><img src="/img/p1.PNG" alt="image"></p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><blockquote>
<p>每次进入Ubuntu子系统，都需要将/etc/profile文件中的配置重新生效一次，否则配置的诸如JAVA_HOME、TOMACAT_HOME等环境变量都不能识别，而且执行完：source /etc/profile 之后，terminal中的字体颜色也会随着变化 </p>
</blockquote>
<h2 id="etc-hosts文件"><a href="#etc-hosts文件" class="headerlink" title="/etc/hosts文件"></a>/etc/hosts文件</h2><blockquote>
<p>修改/etc/hosts文件过后，保存退出vim编辑器，此时可以使用刚编辑过的配置，但是一旦关闭命令行窗口，重新进入Ubuntu子系统，之前保存的/etc/hosts文件里面的内容就没有了。</p>
</blockquote>
]]></content>
      <categories>
        <category>System</category>
      </categories>
      <tags>
        <tag>ubuntu in win10</tag>
        <tag>configuraton</tag>
      </tags>
  </entry>
  <entry>
    <title>glusterDaemon</title>
    <url>/2017/07/07/system_management/glusterDaemon/</url>
    <content><![CDATA[<h2 id="connection-failed-check-if-gluster-deamon-is-running"><a href="#connection-failed-check-if-gluster-deamon-is-running" class="headerlink" title="connection failed check if gluster deamon is running"></a>connection failed check if gluster deamon is running</h2><p>在使用gluster命令的时候，如果之前在本机上创建的volume所在的局域网ip与现在本机的局域网ip不是同一个的话，就会经常出现gluster deamon不可用的情况，网上搜索了很多方法，感觉最实用的还是重装glusterfs，当然前提是gluster上的数据不那么重要。。。</p>
<blockquote>
<p>执行：</p>
</blockquote>
<pre><code>cd /var/log/glusterfs/
rm -fR *
rm -rf /var/lib/glusterd/*
</code></pre>
<blockquote>
<p>然后直接卸载重装：</p>
</blockquote>
<pre><code>sudo apt-get remove glusterfs-common
sudo add-apt-repository ppa:gluster/glusterfs-3.8
sudo apt-get update
sudo apt-get install glusterfs-server
</code></pre>
<h2 id="mount-出错"><a href="#mount-出错" class="headerlink" title="mount 出错"></a>mount 出错</h2><p>查看/var/log/glusterfs/export.log出现：failed to get the port number for remote subvolume. Please run ‘gluster volume status’ on server to see if brick process is running<br>执行<code>gluster volume status</code>发现本机Brick的TCP Port没有分配，即volume没有启起来，执行<code>gluster volume vol-name start force</code>即可</p>
<hr>
]]></content>
      <categories>
        <category>System</category>
      </categories>
      <tags>
        <tag>glusterfs</tag>
        <tag>install</tag>
      </tags>
  </entry>
  <entry>
    <title>容器网络</title>
    <url>/2019/08/30/system_management/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><p>负责转发源ip地址的请求到目标ip地址。当路由表中将网关设置为<code>0.0.0.0</code>时，表示源ip地址直连网卡。</p>
<h2 id="跨主机网络-overlay-network"><a href="#跨主机网络-overlay-network" class="headerlink" title="跨主机网络 - overlay network"></a>跨主机网络 - overlay network</h2><h3 id="flannel"><a href="#flannel" class="headerlink" title="flannel"></a>flannel</h3><p>整个过程参见张磊的极客课程<strong>深入剖析Kubernetes 32~35章节</strong><br>基于UDP的跨主机通信的基本原理如图所示：<br><img src="/img/system_management/flannel-udp-network.png"><br>可以看到每次数据从一个主机发出去的之前会进行三次用户态和内核态的切换(container0 - docker0, flannel0 - flanneld, flanneld - eth0)，非常耗时。所以后来被VXLAN（虚拟可扩展局域网）所取代，如图所示：<br><img src="/img/system_management/flannel-network.png"><br>docker0和flannel0之间通过路由表进行协作。</p>
<p>在k8s中，有一个单独的网桥来代替docker0，它的名字叫cni网桥，在宿主机上的默认设备名称为<code>cni0</code>，查看route，可以看到10.244.1.0/24网段都会经过<code>cni0</code>路由，而10.244.0.0/24、10.244.2.0/24，10.244.3.0/24都会经过<code>flannel.1</code>路由。<code>flannel.1</code>是VXLAN中的一个VTEP设备。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@n167 ~]<span class="comment"># route -n</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         210.28.132.1    0.0.0.0         UG    100    0        0 em1</span><br><span class="line">10.0.0.0        0.0.0.0         254.0.0.0       U     100    0        0 em2</span><br><span class="line">10.0.1.0        0.0.0.0         255.255.255.0   U     100    0        0 p2p1</span><br><span class="line">10.244.0.0      10.244.0.0      255.255.255.0   UG    0      0        0 flannel.1</span><br><span class="line">10.244.1.0      0.0.0.0         255.255.255.0   U     0      0        0 cni0</span><br><span class="line">10.244.2.0      10.244.2.0      255.255.255.0   UG    0      0        0 flannel.1</span><br><span class="line">10.244.3.0      10.244.3.0      255.255.255.0   UG    0      0        0 flannel.1</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br><span class="line">210.28.132.0    0.0.0.0         255.255.255.0   U     100    0        0 em1</span><br></pre></td></tr></table></figure>

<p>k8s中容器网络是由cni插件创建的，cni插件可以有多个，在dockershim启动的时候，会选择一个cni插件（如flannel）作为默认插件。当kubelet创建一个pod的时候，首先创建一个infra容器（由dockershim调用docker api创建），紧接着执行一个叫<code>SetUpPod</code>的方法，在这个方法里面就会调用cni插件为infra容器配置网络。cni插件在配置网络的时候，首先会将dockershim传过来的Network Configuration进行补充（包括将Delegate的Type设置为bridge，表示交由<code>CNI bridge</code>插件来配置网络；设置ipam，即设置<code>kubeadm init --pod-network-cidr 10.244.0.0/16</code>中的子网，路由信息等），交给cni插件的<code>Delegate</code>插件即<code>CNI bridge</code>插件来完成网络配置。<code>CNI bridge</code>插件首先会检查宿主机上CNI网桥即<code>cni0</code>是否存在，不存在就创建；然后进入infra容器的Net ns中，创建一对Veth Pair设备，<code>eth0</code>放在容器里面，<code>vethb4963f</code>放在宿主机上，这就是我们执行命令<code>ifconfig</code>可以看到的很多以veth开头的网络设备，如图所示：<br><img src="/img/system_management/vethpair.png"><br>接下来，<code>CNI bridge</code>插件会将<code>vethb4963f</code>设备连接在<code>cni0</code>网桥上，使得容器和宿主机互通。同时，需要让容器可以“自己访问自己”，即容器里面访问映射到主机上的端口，这时候需要开启<code>Hairpin Mode</code>。接下来，<code>CNI bridge</code>插件会调用<code>CNI ipam</code>插件从<code>ipam.subnet</code>字段规定的网段中为容器分配一个ip地址并添加到容器里面的<code>eth0</code>上。最后把ip地址返回给dockershim，并被kubelet写到pod的Status字段。</p>
]]></content>
      <categories>
        <category>System</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>overlay network</tag>
      </tags>
  </entry>
  <entry>
    <title>现代操作系统原理与实现1</title>
    <url>/2021/10/22/system_management/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B01/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>2020年终总结</title>
    <url>/2021/02/20/year_summary/2020%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>2020年是不平凡的一年，研三秋季学期末段便听说武汉出现疑似肺炎病毒，到后来波及全球，打乱了全世界的计划，同样包括我的一些计划。</p>
<p>本打算毕业典礼叫全家人一起去学校参加，给自己的求学生涯画上一个完美的句号，可惜计划赶不上变化。在家里呆了半年才返校，答辩也是线上完成的，在学校领了毕业证、处理了一些离校手续就在一周内匆匆离开。最想去学校的半年不得不在家里度过，回头想想确实很可惜，可惜一学期的校园时光，可惜没能跟生活了七年的南京的朋友们好好聚聚、道个别，可惜没能圆圆满满的完成毕业。校园生活已经翻篇，作为社畜的生活刚刚开始。</p>
<p>回顾在家里的几个月，最重要是事莫过于完成毕业论文，拖延症晚期的我在论文截止日期前一个月才开始写论文。现在想想幸好当时去了小冰家，那一个月在小冰妈妈的照顾下衣食无忧，潜心写论文。要是在自己家的话，还得每天自己做饭，又没人监督，怕是很难完成如此艰巨的任务（写的那么烂，还敢说艰巨。。）。当时的实验其实都做的差不多了，只是根据实验结果把文章写出来，结合一些学术论文和往年师兄们的论文，再开放一下思维、整理一下思路、拟好提纲，完成了雏形。后面修改着实让人心累，并且答辩前还在导师的要求下把实验工具以k8s原生的operator实现了，论文临提交前的那几天爆肝熬夜的日子真是让人头大。所幸最后顺利过关，也不枉三年的努力。</p>
<p>从学校匆匆离开后，便直奔深圳，从7月份加入商汤到现在这半年多时间里，学习了argo的设计实现，并运用到公司内部，argo是一个相当庞大的工作流控制组件，挺佩服开源社区做这份工作的一批人。公司以AI技术为核心，免不了有很多与训练相关的工作项，因为研究生阶段搞分布式DL调度的，来公司也顺理成章的维护起了pytorch-operator，还有对接一些pytorch的业务线。技术上没有多大突破，不过深入理解并掌握了k8s informer机制，算是一点点长进吧。</p>
<p>年末接触了一些强化学习相关的项目，还在继续开展，跟着周博磊老师的强化学习纲要课程并结合周志华老师的西瓜书一步一步学会马尔科夫决策过程（MDP）这一强化学习核心内容的原理及推导，以前看到数学公式就打退堂鼓，现在学会推导，感觉还是学到东西了。开会的时候提到Ray（一种分布式强化学习框架），想起18年看到的osdi的论文就是这篇，当时没怎么细看，这会把Ray的架构又看了一遍，也看到社区对于将Ray跑到k8s上的一些尝试，不过社区项目<a href="https://github.com/ray-project/ray-operator/">ray-operator</a>最近被删除了，通过跟高策师兄交流知道ray-operator已经被放到<a href="https://github.com/ray-project/ray">ray</a>里面了，通过python实现的。之所以不用golang以k8s原生的方式实现，好像是因为k8s原生方式对自动扩缩容不太友好，而ray的python包中可以通过autoscaler很好的实现自动扩缩容。</p>
<p>工作后每天都是两点一线，没什么娱乐项目，枯燥的生活下让我萌生了学习历史的想法，于是买了一套《白话资治通鉴》。现在后悔了，不是觉得不该买，而是觉得不该买白话版的，看起来真的没意思，现在又换成看电子书了。从三家分晋到汉文帝时期前后将近两百多年时间，见证了李悝、吴起变法带给魏国的变化；商鞅变法使得秦国一步步强大；纵横家周游列国、左右天下大局；稷下学宫促成百家争鸣；秦一统天下却二世而亡，仁义不施，而攻守之势异也；楚汉争雄，项羽毁于刚愎自用，四面楚歌，皆因不纳良言。天下已定，叔孙通修礼仪，历史评价褒贬不一；惠帝即位，萧规曹随，休养生息；吕氏乱政，周勃应高祖预言安定汉之基业；文帝即位，轻徭薄税，广纳谏言，政治随明，却文过饰非，旷世奇才贾谊，奈何屈于长沙。从贾谊的多篇论述及上书中可以看到贾谊目光之长远：对于文帝允许平民自铸钱币，贾谊看出钱币乃统治阶层命脉，不可交由平民私铸；对于农耕渐弱，贾谊假想若是出现大饥荒，国无余粮，何以赈灾。</p>
<p>历史看似有趣，实则无趣，因为当看过了王朝变更，会发现历史总是压着前人的车轨，国家权力集于一人之手的容错率太低了。</p>
<p>2021年，希望自己能把强化学习理解更透彻，多跟进一些调度相关的论文，20年只读了寥寥几篇论文（<a href="https://dl.acm.org/doi/pdf/10.1145/3373376.3378499">Prague</a>，<a href="https://arxiv.org/abs/1712.05889">Ray</a>）。</p>
<p>共勉！</p>
]]></content>
      <categories>
        <category>Year Summary</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro登录验证流程</title>
    <url>/2018/03/19/java_spring/Shiro%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Shiro登录验证的实现和验证流程"><a href="#Shiro登录验证的实现和验证流程" class="headerlink" title="Shiro登录验证的实现和验证流程"></a>Shiro登录验证的实现和验证流程</h1><h2 id="实现登录验证"><a href="#实现登录验证" class="headerlink" title="实现登录验证"></a>实现登录验证</h2><h3 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h3><ol>
<li><p>需要ShiroConfiguration：在这个类中主要是注入shiro的filterFactoryBean和securityManager等对象。</p>
</li>
<li><p>需要StatelessAccessControlFilter：这个类中实现访问控制过滤，当我们访问url的时候，这个类中的两个方法会进行拦截处理。</p>
</li>
<li><p>需要StatelessAuthorizingRealm：这个类中主要是身份认证，验证信息是否合理，是否有角色和权限信息。</p>
</li>
<li><p>需要StatelessAuthenticationToken：在shiro中有一个我们常用的UsernamePasswordToken，因为我们需要这里需要自定义一些属性值，比如：消息摘要，参数Map。</p>
</li>
<li><p>需要StatelessDefaultSubjectFactory：由于我们编写的是无状态的，每人情况是会创建session对象的，那么我们需要修改createSubject关闭session的创建。</p>
</li>
<li><p>需要HmacSHA256Utils：Java 加密解密之消息摘要算法，对我们的参数信息进行处理。</p>
</li>
</ol>
<span id="more"></span>

<h3 id="配置文件ShiroConfig"><a href="#配置文件ShiroConfig" class="headerlink" title="配置文件ShiroConfig"></a>配置文件ShiroConfig</h3><p>本篇博客以sinosteel代码分析。以上用到的核心类在com.sinosteel.framework.config.shiro包下面实现了。首先看com.sinosteel.framework.config.shiro.ShiroConfig类，其中ShiroFilterFactoryBean和DefaultWebSecurityManager这两项是在Spring中引入Shiro的基本配置，前者用于配置过滤器的过滤规则，后者用于生成全局的securitymanager。该类将核心类都注册到IoC容器中。：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfig</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * ShiroFilterFactoryBean 处理拦截资源文件问题。 </span></span><br><span class="line"><span class="comment">     * 注意：单独一个ShiroFilterFactoryBean配置是或报错的，以为在 </span></span><br><span class="line"><span class="comment">     * 初始化ShiroFilterFactoryBean的时候需要注入：SecurityManager </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">        Filter Chain定义说明 </span></span><br><span class="line"><span class="comment">       1、一个URL可以配置多个Filter，使用逗号分隔 </span></span><br><span class="line"><span class="comment">       2、当设置多个过滤器时，全部验证通过，才视为通过 </span></span><br><span class="line"><span class="comment">       3、部分过滤器可指定参数，如perms，roles </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShiroFilterFactoryBean <span class="title">shiroFilter</span><span class="params">(SecurityManager securityManager)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	ShiroFilterFactoryBean factoryBean = <span class="keyword">new</span> ShiroFilterFactoryBean();</span><br><span class="line">    	factoryBean.setSecurityManager(securityManager);</span><br><span class="line"></span><br><span class="line">        Map&lt;String,String&gt; filterChainDefinitionMap = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//&lt;!-- authc:所有url都必须认证通过才可以访问; anon:所有url都都可以匿名访问--&gt;</span></span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/login&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        <span class="comment">//filterChainDefinitionMap.put(&quot;/druid&quot;, &quot;anon&quot;);</span></span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/services/**&quot;</span>, <span class="string">&quot;statelessAuthc&quot;</span>);</span><br><span class="line">        factoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);</span><br><span class="line">        </span><br><span class="line">        factoryBean.getFilters().put(<span class="string">&quot;statelessAuthc&quot;</span>, statelessAuthcFilter());</span><br><span class="line">        </span><br><span class="line">    	<span class="keyword">return</span> factoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultWebSecurityManager <span class="title">securityManager</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DefaultWebSecurityManager securityManager = <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line">        </span><br><span class="line">        securityManager.setSubjectFactory(subjectFactory());</span><br><span class="line">        securityManager.setSessionManager(sessionManager());</span><br><span class="line">        securityManager.setRealm(statelessRealm());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 禁用使用Sessions 作为存储策略的实现，但它没有完全地禁用Sessions</span></span><br><span class="line"><span class="comment">            * 所以需要配合context.setSessionCreationEnabled(false);</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ((DefaultSessionStorageEvaluator)((DefaultSubjectDAO)securityManager.getSubjectDAO()).getSessionStorageEvaluator()).setSessionStorageEnabled(<span class="keyword">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成subject</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultWebSubjectFactory <span class="title">subjectFactory</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        StatelessDefaultSubjectFactory subjectFactory = <span class="keyword">new</span> StatelessDefaultSubjectFactory();</span><br><span class="line">        <span class="keyword">return</span> subjectFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * session管理器：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * sessionManager通过sessionValidationSchedulerEnabled禁用掉会话调度器，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 因为我们禁用掉了会话，所以没必要再定期过期会话了。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultSessionManager <span class="title">sessionManager</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	DefaultSessionManager sessionManager = <span class="keyword">new</span> DefaultSessionManager();</span><br><span class="line">    	sessionManager.setSessionValidationSchedulerEnabled(<span class="keyword">false</span>);</span><br><span class="line">    	<span class="keyword">return</span> sessionManager;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自定义realm</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StatelessAuthorizingRealm <span class="title">statelessRealm</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	StatelessAuthorizingRealm realm = <span class="keyword">new</span> StatelessAuthorizingRealm();</span><br><span class="line">    	<span class="keyword">return</span> realm;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//访问控制器，相当于spring mvc中的DispatcherServlet</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StatelessAccessControlFilter <span class="title">statelessAuthcFilter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	StatelessAccessControlFilter statelessAuthcFilter = <span class="keyword">new</span> StatelessAccessControlFilter();</span><br><span class="line">    	<span class="keyword">return</span> statelessAuthcFilter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义切面，最后这两个Bean是用于权限控制的，不是用于登录验证，这里可以不看</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthorizationAttributeSourceAdvisor <span class="title">authorizationAttributeSourceAdvisor</span><span class="params">(SecurityManager securityManager)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = <span class="keyword">new</span> AuthorizationAttributeSourceAdvisor();</span><br><span class="line">    	authorizationAttributeSourceAdvisor.setSecurityManager(securityManager);</span><br><span class="line">    	<span class="keyword">return</span> authorizationAttributeSourceAdvisor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * Add.5.2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     *   自动代理所有的advisor:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     *   由Advisor决定对哪些类的方法进行AOP代理。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//自动将shiro中的切面应用到匹配的Bean中（即为目标Bean创建代理实例）</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultAdvisorAutoProxyCreator <span class="title">getDefaultAdvisorAutoProxyCreator</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	DefaultAdvisorAutoProxyCreator daap = <span class="keyword">new</span> DefaultAdvisorAutoProxyCreator();</span><br><span class="line">    	daap.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">    	<span class="keyword">return</span> daap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="无状态web配置"><a href="#无状态web配置" class="headerlink" title="无状态web配置"></a>无状态web配置</h3><p>sinosteel启用的是无状态的web配置，需要配置三个地方：</p>
<ol>
<li><p>根据上下文创建subject的时候，需要关闭session的创建，在StatelessDefaultSubjectFactory的createSubject方法中实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatelessDefaultSubjectFactory</span> <span class="keyword">extends</span> <span class="title">DefaultWebSubjectFactory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	 <span class="meta">@Override</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> Subject <span class="title">createSubject</span><span class="params">(SubjectContext context)</span> </span></span><br><span class="line"><span class="function">	 </span>&#123;</span><br><span class="line">		 <span class="comment">//不创建session.</span></span><br><span class="line">		 context.setSessionCreationEnabled(<span class="keyword">false</span>);</span><br><span class="line">		 <span class="keyword">return</span> <span class="keyword">super</span>.createSubject(context);</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>禁用使用session作为存储策略的实现，由securitymanager的subjectDao的sessionStorageEvaluator进行管理，下面是ShiroConfig里面securitymanager方法下的一条语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 禁用使用Sessions 作为存储策略的实现，但它没有完全地禁用Sessions</span></span><br><span class="line"><span class="comment">* 所以需要配合context.setSessionCreationEnabled(false);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">((DefaultSessionStorageEvaluator)((DefaultSubjectDAO)securityManager.getSubjectDAO()).getSessionStorageEvaluator()).setSessionStorageEnabled(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>禁用会话调度器，由sessionManager管理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ShiroConfig里的一个Bean</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DefaultSessionManager <span class="title">sessionManager</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DefaultSessionManager sessionManager = <span class="keyword">new</span> DefaultSessionManager();</span><br><span class="line">    sessionManager.setSessionValidationSchedulerEnabled(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> sessionManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="请求控制拦截"><a href="#请求控制拦截" class="headerlink" title="请求控制拦截"></a>请求控制拦截</h3><p>首先是用于加密解密的消息摘要算法的实现，com.sinosteel.framework.utils.encryption.HmacSHA256Util类。里面的digest方法用于生成客户端和服务端消息摘要。<br>接着是实现StatelessAuthenticationToken类，用于保存用户名和摘要，较为简单。<br>然后开始编写访问控制过滤器StatelessAccessControlFilter：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatelessAccessControlFilter</span> <span class="keyword">extends</span> <span class="title">AccessControlFilter</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回true表示允许访问；这里默认false，表示对每一个请求都进行权限验证</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isAccessAllowed</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> Exception </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//isAccessAllowed返回false才调用，表示需要进一步认证。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAccessDenied</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	String clientDigest = request.getParameter(<span class="string">&quot;clientDigest&quot;</span>);</span><br><span class="line">    	String username = request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成无状态token，交由subject完成登录验证</span></span><br><span class="line">    	StatelessAuthenticationToken token = <span class="keyword">new</span> StatelessAuthenticationToken(username, clientDigest);</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">try</span> </span><br><span class="line">    	&#123;</span><br><span class="line">            <span class="comment">//交给subject进行登录验证，最终会调用StatelessAuthorizingRealm进行处理</span></span><br><span class="line">    		getSubject(request, response).login(token);</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">//验证完成，交由下一个filter过滤</span></span><br><span class="line">    	&#125; </span><br><span class="line">    	<span class="keyword">catch</span> (Exception e) </span><br><span class="line">    	&#123;</span><br><span class="line">    		e.printStackTrace();</span><br><span class="line">    		onLoginFail(response);</span><br><span class="line">           </span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onLoginFail</span><span class="params">(ServletResponse response)</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	HttpServletResponse httpResponse = (HttpServletResponse) response;</span><br><span class="line">    	httpResponse.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line">    	httpResponse.getWriter().write(<span class="string">&quot;login error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>getSubject(request, response).login(token);将进入StatelessAuthorizingRealm获取验证信息，完成登录验证。该方法的核心就是获取到AccessControlFilter传递过来的StatelessAuthenticationToken中的参数进行消息摘要，然后生成对象SimpleAuthenticationInfo交给Shiro进行比对，看客户端发来的token与服务端的是否匹配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatelessAuthorizingRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="comment">//...省略部分代码</span></span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span></span><br><span class="line"><span class="function">    </span>&#123;	</span><br><span class="line">        <span class="comment">//获取AccessControlFilter传递过来的StatelessAuthenticationToken</span></span><br><span class="line">    	StatelessAuthenticationToken statelessToken = (StatelessAuthenticationToken)token;</span><br><span class="line">    	String username = (String)statelessToken.getPrincipal();</span><br><span class="line">    	</span><br><span class="line">        <span class="comment">//获取用户的信息</span></span><br><span class="line">    	JSONObject userInfoJson = CacheUtil.getUserInfoJson(username);</span><br><span class="line">    	<span class="keyword">if</span>(userInfoJson == <span class="keyword">null</span>)</span><br><span class="line">    	&#123; 	</span><br><span class="line">    		User user = userRepository.findByUsername(username);  </span><br><span class="line">        	<span class="keyword">if</span>(user == <span class="keyword">null</span>)</span><br><span class="line">        	&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        	</span><br><span class="line">        	userInfoJson = CacheUtil.saveUserInfoCache(user);</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">        <span class="comment">//在服务端生成客户端消息摘要</span></span><br><span class="line">    	String serverDigest = HmacSHA256Util.digest(getKey(username), userInfoJson.getString(<span class="string">&quot;password&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回authenticationInfo</span></span><br><span class="line">    	SimpleAuthenticationInfo authenticationInfo = <span class="keyword">new</span> SimpleAuthenticationInfo(username, serverDigest, getName());</span><br><span class="line">    	<span class="keyword">return</span> authenticationInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//doGetAuthorizationInfo省略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Key的生成策略</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getKey</span><span class="params">(String username)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> username;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>至此，登录验证就实现了。总结一下，首先引入Shiro基本配置，然后编写StatelessDefaultSubjectFactory类，用以生产subject；配置无状态web登录；编写消息摘要算法用以消息加密和StatelessAuthenticationToken用以存储用户名和摘要；编写StatelessAccessControlFilter实现对登录请求的过滤，编写StatelessAuthorizingRealm获取token并生成服务端token，用于shiro认证。</p>
</li>
</ol>
<h2 id="验证流程源代码分析"><a href="#验证流程源代码分析" class="headerlink" title="验证流程源代码分析"></a>验证流程源代码分析</h2><p>首先是StatelessAccessControlFilter过滤器，拦截请求，调用onAccessDenid方法实现登录验证：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//isAccessAllowed返回false才调用，表示需要进一步认证。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAccessDenied</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    String clientDigest = request.getParameter(<span class="string">&quot;clientDigest&quot;</span>);</span><br><span class="line">    String username = request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成无状态token，交由subject完成登录验证</span></span><br><span class="line">    StatelessAuthenticationToken token = <span class="keyword">new</span> StatelessAuthenticationToken(username, clientDigest);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//交给subject进行登录验证，最终会调用StatelessAuthorizingRealm进行处理</span></span><br><span class="line">        getSubject(request, response).login(token);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">//验证完成，交由下一个filter过滤</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">catch</span> (Exception e) </span><br><span class="line">    &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        onLoginFail(response);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>onAccessDenid方法调用getSubject(request, response).login(token)进行登录验证，进入subject.login()方法，即调用接口类Subject的实现类org.apache.shiro.subject.support.DelegatingSubject类中的login方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">    clearRunAsIdentitiesInternal();</span><br><span class="line">    <span class="comment">//最终交由securityManager执行login操作</span></span><br><span class="line">    Subject subject = securityManager.login(<span class="keyword">this</span>, token);</span><br><span class="line"></span><br><span class="line">    PrincipalCollection principals;</span><br><span class="line"></span><br><span class="line">    String host = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (subject <span class="keyword">instanceof</span> DelegatingSubject) &#123;</span><br><span class="line">        DelegatingSubject delegating = (DelegatingSubject) subject;</span><br><span class="line">        <span class="comment">//we have to do this in case there are assumed identities - we don&#x27;t want to lose the &#x27;real&#x27; principals:</span></span><br><span class="line">        principals = delegating.principals;</span><br><span class="line">        host = delegating.host;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        principals = subject.getPrincipals();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (principals == <span class="keyword">null</span> || principals.isEmpty()) &#123;</span><br><span class="line">        String msg = <span class="string">&quot;Principals returned from securityManager.login( token ) returned a null or &quot;</span> +</span><br><span class="line">                <span class="string">&quot;empty value.  This value must be non null and populated with one or more elements.&quot;</span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.principals = principals;</span><br><span class="line">    <span class="keyword">this</span>.authenticated = <span class="keyword">true</span>;  <span class="comment">//认证通过</span></span><br><span class="line">    <span class="keyword">if</span> (token <span class="keyword">instanceof</span> HostAuthenticationToken) &#123;</span><br><span class="line">        host = ((HostAuthenticationToken) token).getHost();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (host != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">    &#125;</span><br><span class="line">    Session session = subject.getSession(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.session = decorate(session);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.session = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续调用securityManager.login(this, token);进入securityManager的login方法，即调用接口SecurityManager的实现类org.apache.shiro.mgt.DefaultSecurityManager类的login方法，该方法接收subject和token参数，如果验证成功，则构造一个Subject，代表已经验证的用户返回给DelegatingSubject类的login方法。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * First authenticates the &#123;<span class="doctag">@code</span> AuthenticationToken&#125; argument, and if successful, constructs a</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> Subject&#125; instance representing the authenticated account&#x27;s identity.</span></span><br><span class="line"><span class="comment">    如果构造成功则返回一个Subject实例代表作为已经验证的用户的凭证</span></span><br><span class="line"><span class="comment">    * &lt;p/&gt;</span></span><br><span class="line"><span class="comment">    * Once constructed, the &#123;<span class="doctag">@code</span> Subject&#125; instance is then &#123;<span class="doctag">@link</span> #bind bound&#125; to the application for</span></span><br><span class="line"><span class="comment">    * subsequent access before being returned to the caller.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> token the authenticationToken to process for the login attempt.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> a Subject representing the authenticated user.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> AuthenticationException if there is a problem authenticating the specified &#123;<span class="doctag">@code</span> token&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Subject <span class="title">login</span><span class="params">(Subject subject, AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">    AuthenticationInfo info;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        info = authenticate(token);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (AuthenticationException ae) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            onFailedLogin(token, ae, subject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isInfoEnabled()) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;onFailedLogin method threw an &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;exception.  Logging and propagating original AuthenticationException.&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> ae; <span class="comment">//propagate</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造Subject，代表已经验证的用户</span></span><br><span class="line">    Subject loggedIn = createSubject(token, info, subject);</span><br><span class="line"></span><br><span class="line">    onSuccessfulLogin(token, info, loggedIn);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> loggedIn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着继续执行authenticate(token)方法，返回一个AuthenticationInfo，从这里可以看出，这个AuthenticationInfo肯定是要从我们自定义的StatelessAuthorizingRealm里面取得。我们一步一步分析，authenticate(token)方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Delegates to the wrapped &#123;<span class="doctag">@link</span> org.apache.shiro.authc.Authenticator Authenticator&#125; for authentication.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AuthenticationInfo <span class="title">authenticate</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.authenticator.authenticate(token);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>提示我们将转到org.apache.shiro.authc.Authenticator 执行authenticate(token)方法，即进入其实现类org.apache.shiro.authc.AbstractAuthenticator执行该方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @param token the submitted token representing the subject&#x27;s (user&#x27;s) login principals and credentials.</span></span><br><span class="line"><span class="comment">* @return the AuthenticationInfo referencing the authenticated user&#x27;s account data.</span></span><br><span class="line"><span class="comment">* @throws AuthenticationException if there is any problem during the authentication process - see the</span></span><br><span class="line"><span class="comment">*                                 interface&#x27;s JavaDoc for a more detailed explanation.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AuthenticationInfo <span class="title">authenticate</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//token为空</span></span><br><span class="line">    <span class="keyword">if</span> (token == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Method argument (authentication token) cannot be null.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.trace(<span class="string">&quot;Authentication attempt received for token [&#123;&#125;]&quot;</span>, token);</span><br><span class="line"></span><br><span class="line">    AuthenticationInfo info;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        info = doAuthenticate(token);</span><br><span class="line">        <span class="keyword">if</span> (info == <span class="keyword">null</span>) &#123;</span><br><span class="line">            String msg = <span class="string">&quot;No account information found for authentication token [&quot;</span> + token + <span class="string">&quot;] by this &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;Authenticator instance.  Please check that it is configured correctly.&quot;</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationException(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        AuthenticationException ae = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> AuthenticationException) &#123;</span><br><span class="line">            ae = (AuthenticationException) t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ae == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//Exception thrown was not an expected AuthenticationException.  Therefore it is probably a little more</span></span><br><span class="line">            <span class="comment">//severe or unexpected.  So, wrap in an AuthenticationException, log to warn, and propagate:</span></span><br><span class="line">            String msg = <span class="string">&quot;Authentication failed for token submission [&quot;</span> + token + <span class="string">&quot;].  Possible unexpected &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;error? (Typical or expected login exceptions should extend from AuthenticationException).&quot;</span>;</span><br><span class="line">            ae = <span class="keyword">new</span> AuthenticationException(msg, t);</span><br><span class="line">            <span class="keyword">if</span> (log.isWarnEnabled())</span><br><span class="line">                log.warn(msg, t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            notifyFailure(token, ae);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isWarnEnabled()) &#123;</span><br><span class="line">                String msg = <span class="string">&quot;Unable to send notification for failed authentication attempt - listener error?.  &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;Please check your AuthenticationListener implementation(s).  Logging sending exception &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;and propagating original AuthenticationException instead...&quot;</span>;</span><br><span class="line">                log.warn(msg, t2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> ae;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">&quot;Authentication successful for token [&#123;&#125;].  Returned account [&#123;&#125;]&quot;</span>, token, info);</span><br><span class="line"></span><br><span class="line">    notifySuccess(token, info);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着进入doAuthenticate(token)方法，该方法交由AbstractAuthenticator的子类org.apache.shiro.authc.pam.ModularRealmAuthenticator类实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Attempts to authenticate the given token by iterating over the internal collection of</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> Realm&#125;s.  For each realm, first the &#123;<span class="doctag">@link</span> Realm#supports(org.apache.shiro.authc.AuthenticationToken)&#125;</span></span><br><span class="line"><span class="comment">* method will be called to determine if the realm supports the &#123;<span class="doctag">@code</span> authenticationToken&#125; method argument.</span></span><br><span class="line"><span class="comment">* &lt;p/&gt;</span></span><br><span class="line"><span class="comment">* If a realm does support</span></span><br><span class="line"><span class="comment">* the token, its &#123;<span class="doctag">@link</span> Realm#getAuthenticationInfo(org.apache.shiro.authc.AuthenticationToken)&#125;</span></span><br><span class="line"><span class="comment">* method will be called.  If the realm returns a non-null account, the token will be</span></span><br><span class="line"><span class="comment">* considered authenticated for that realm and the account data recorded.  If the realm returns &#123;<span class="doctag">@code</span> null&#125;,</span></span><br><span class="line"><span class="comment">* the next realm will be consulted.  If no realms support the token or all supporting realms return null,</span></span><br><span class="line"><span class="comment">* an &#123;<span class="doctag">@link</span> AuthenticationException&#125; will be thrown to indicate that the user could not be authenticated.</span></span><br><span class="line"><span class="comment">* &lt;p/&gt;</span></span><br><span class="line"><span class="comment">* After all realms have been consulted, the information from each realm is aggregated into a single</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> AuthenticationInfo&#125; object and returned.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doAuthenticate</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">    assertRealmsConfigured();</span><br><span class="line">    Collection&lt;Realm&gt; realms = getRealms();</span><br><span class="line">    <span class="keyword">if</span> (realms.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> doSingleRealmAuthentication(realms.iterator().next(), authenticationToken);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> doMultiRealmAuthentication(realms, authenticationToken);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如注解所说，上述方法遍历所有realms，检查realms是否支持传入的AuthenticationToken，如果支持则调用该realm的getAuthenticateInfo方法，具体实现可分为对单个realm和多个realm两种方法，下面只看doMutiRealmAuthentication方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doMultiRealmAuthentication</span><span class="params">(Collection&lt;Realm&gt; realms, AuthenticationToken token)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*验证策略</span></span><br><span class="line"><span class="comment">    llSuccessFulStrategy:所有Realm验证成功才算成功，且返回所有Realm身份验证成功的认证信息，如果有一个失败就失败了。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    AtLeastOneSuccessFulAtrategy:只要有一个Realm验证成功即可，和FirstSuccessfulStrategy 不同，将返回所有Realm身份验证成功的认证信息；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    FirstSuccessFulStrategy:只要有一个 Realm 验证成功即可，只返回第一个 Realm 身份验证成功的认证信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    AuthenticationStrategy strategy = getAuthenticationStrategy();</span><br><span class="line"></span><br><span class="line">    AuthenticationInfo aggregate = strategy.beforeAllAttempts(realms, token);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">        log.trace(<span class="string">&quot;Iterating through &#123;&#125; realms for PAM authentication&quot;</span>, realms.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Realm realm : realms) &#123;</span><br><span class="line"></span><br><span class="line">        aggregate = strategy.beforeAttempt(realm, token, aggregate);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (realm.supports(token)) &#123;</span><br><span class="line"></span><br><span class="line">            log.trace(<span class="string">&quot;Attempting to authenticate token [&#123;&#125;] using realm [&#123;&#125;]&quot;</span>, token, realm);</span><br><span class="line"></span><br><span class="line">            AuthenticationInfo info = <span class="keyword">null</span>;</span><br><span class="line">            Throwable t = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                info = realm.getAuthenticationInfo(token);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                t = throwable;</span><br><span class="line">                <span class="keyword">if</span> (log.isWarnEnabled()) &#123;</span><br><span class="line">                    String msg = <span class="string">&quot;Realm [&quot;</span> + realm + <span class="string">&quot;] threw an exception during a multi-realm authentication attempt:&quot;</span>;</span><br><span class="line">                    log.warn(msg, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            aggregate = strategy.afterAttempt(realm, token, info, aggregate, t);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;Realm [&#123;&#125;] does not support token &#123;&#125;.  Skipping realm.&quot;</span>, realm, token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    aggregate = strategy.afterAllAttempts(token, aggregate);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> aggregate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面就调用了realm的getAuthenticationInfo方法，及调用org.apache.shiro.realm.Realm接口的getAuthenticationInfo方法，该方法在org.apache.shiro.realm.AuthenticatingRealm类中实现，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AuthenticationInfo <span class="title">getAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查缓存，如果缓存有AuthenticationInfo，则返回</span></span><br><span class="line">    AuthenticationInfo info = getCachedAuthenticationInfo(token);</span><br><span class="line">    <span class="keyword">if</span> (info == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//otherwise not cached, perform the lookup:</span></span><br><span class="line">        info = doGetAuthenticationInfo(token);</span><br><span class="line">        log.debug(<span class="string">&quot;Looked up AuthenticationInfo [&#123;&#125;] from doGetAuthenticationInfo&quot;</span>, info);</span><br><span class="line">        <span class="keyword">if</span> (token != <span class="keyword">null</span> &amp;&amp; info != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cacheAuthenticationInfoIfPossible(token, info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Using cached authentication info [&#123;&#125;] to perform credentials matching.&quot;</span>, info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">        assertCredentialsMatch(token, info);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;No AuthenticationInfo found for submitted AuthenticationToken [&#123;&#125;].  Returning null.&quot;</span>, token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行info = doGetAuthenticationInfo(token);因为AuthorizingRealm继承自AuthenticatingRealm，而AuthorizingRealm将doGetAuthenticationInfo(token)方法交由其子类实现，故doGetAuthenticationInfo(token)方法由我们自定义的com.sinosteel.framework.core.auth.StatelessAuthorizingRealm实现，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">    StatelessAuthenticationToken statelessToken = (StatelessAuthenticationToken)token;</span><br><span class="line">    String username = (String)statelessToken.getPrincipal();</span><br><span class="line">    </span><br><span class="line">    JSONObject userInfoJson = CacheUtil.getUserInfoJson(username);</span><br><span class="line">    <span class="keyword">if</span>(userInfoJson == <span class="keyword">null</span>)</span><br><span class="line">    &#123; 	</span><br><span class="line">        User user = userRepository.findByUsername(username);  </span><br><span class="line">        <span class="keyword">if</span>(user == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        userInfoJson = CacheUtil.saveUserInfoCache(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    String serverDigest = HmacSHA256Util.digest(getKey(username), userInfoJson.getString(<span class="string">&quot;password&quot;</span>));</span><br><span class="line"></span><br><span class="line">    SimpleAuthenticationInfo authenticationInfo = <span class="keyword">new</span> SimpleAuthenticationInfo(username, serverDigest, getName());</span><br><span class="line">    <span class="keyword">return</span> authenticationInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一层层将AuthenticationInfo返回给securityManager.login(this, token);用于构造已经验证的用户。至此登录验证的流程就分析完了。</p>
<blockquote>
<p>本篇博客登录验证的实现参考ITEYE博客网站上林祥纤的<a href="http://412887952-qq-com.iteye.com/blog/2359084">Spring boot之无状态</a>系列以及极客学院系列文章<a href="http://wiki.jikexueyuan.com/project/shiro/interceptor.html">跟我学Shiro</a></p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>shiro</tag>
        <tag>authentication</tag>
      </tags>
  </entry>
  <entry>
    <title>sinosteel @RequiresPermissions注解实现流程</title>
    <url>/2017/11/25/java_spring/sinosteel-RequiresPermissions%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p><a href="https://github.com/DimitriZhao/sinosteel.git">Github代码仓库</a></p>
<h2 id="shiro注解授权源码实现"><a href="#shiro注解授权源码实现" class="headerlink" title="shiro注解授权源码实现"></a>shiro注解授权源码实现</h2><h3 id="授权流程"><a href="#授权流程" class="headerlink" title="授权流程"></a>授权流程</h3><p>概括的说，shiro在实现注解授权时采用的是Spring AOP的方式。<br>在Controller里面的相关方法上添加@RequiresPermissions()注解，Shiro即可自动调用AuthorizationAttributeSourceAdvisor进行AOP操作。从自定义的com.sinosteel.framework.config.shiro.ShiroConfig类开始，该类用@Configuration注解，表示为一个Spring IoC容器，往IoC容器中加入两个Bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AuthorizationAttributeSourceAdvisor <span class="title">authorizationAttributeSourceAdvisor</span><span class="params">(SecurityManager securityManager)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = <span class="keyword">new</span> AuthorizationAttributeSourceAdvisor();</span><br><span class="line">	authorizationAttributeSourceAdvisor.setSecurityManager(securityManager);</span><br><span class="line">	<span class="keyword">return</span> authorizationAttributeSourceAdvisor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DefaultAdvisorAutoProxyCreator <span class="title">getDefaultAdvisorAutoProxyCreator</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DefaultAdvisorAutoProxyCreator daap = <span class="keyword">new</span> DefaultAdvisorAutoProxyCreator();</span><br><span class="line">	daap.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">	<span class="keyword">return</span> daap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<ol>
<li>AuthorizationAttributeSourceAdvisor继承自StaticMethodMatcherPointcutAdvisor，StaticMethodMatcherPointcutAdvisor为静态方法匹配器切点定义的切面，默认情况下，匹配所有的目标类；继承自PointcutAdvisor，代表具有切点的切面，它包含Advice和Pointcut两个类，这样我们就可以通过类、方法名以及方法方位等信息灵活地定义切面的连接点，提供更具适用性的切面。将shiro的securityManager传入AuthorizationAttributeSourceAdvisor中，用于后续获取用户的信息。</li>
<li>DefaultAdvisorAutoProxyCreator表示基于Advisor匹配机制的自动代理创建器：它会对容器中所有的Advisor进行扫描，自动将这些切面应用到匹配的Bean中（即为目标Bean创建代理实例），是Spring为我们提供的自动代理机制，让容器为我们自动生成代理，把我们从烦琐的配置工作中解放出来。</li>
</ol>
<p>AuthorizationAttributeSourceAdvisor类定义了一个切面，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationAttributeSourceAdvisor</span> <span class="keyword">extends</span> <span class="title">StaticMethodMatcherPointcutAdvisor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(AuthorizationAttributeSourceAdvisor.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;? extends Annotation&gt;[] AUTHZ_ANNOTATION_CLASSES =</span><br><span class="line">            <span class="keyword">new</span> Class[] &#123;</span><br><span class="line">                    RequiresPermissions.class, RequiresRoles.class,</span><br><span class="line">                    RequiresUser.class, RequiresGuest.class, RequiresAuthentication.class</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> SecurityManager securityManager = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a new AuthorizationAttributeSourceAdvisor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuthorizationAttributeSourceAdvisor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        **setAdvice**(<span class="keyword">new</span> AopAllianceAnnotationsAuthorizingMethodInterceptor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SecurityManager <span class="title">getSecurityManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecurityManager</span><span class="params">(org.apache.shiro.mgt.SecurityManager securityManager)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.securityManager = securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &lt;tt&gt;true&lt;/tt&gt; if the method has any Shiro annotations, false otherwise.</span></span><br><span class="line"><span class="comment">     * The annotations inspected are:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;&#123;<span class="doctag">@link</span> org.apache.shiro.authz.annotation.RequiresAuthentication RequiresAuthentication&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;&#123;<span class="doctag">@link</span> org.apache.shiro.authz.annotation.RequiresUser RequiresUser&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;&#123;<span class="doctag">@link</span> org.apache.shiro.authz.annotation.RequiresGuest RequiresGuest&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;&#123;<span class="doctag">@link</span> org.apache.shiro.authz.annotation.RequiresRoles RequiresRoles&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;&#123;<span class="doctag">@link</span> org.apache.shiro.authz.annotation.RequiresPermissions RequiresPermissions&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method      the method to check for a Shiro annotation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetClass the class potentially declaring Shiro annotations</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if the method has a Shiro annotation, false otherwise.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.aop.MethodMatcher#matches(java.lang.reflect.Method, Class)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class targetClass)</span> </span>&#123;</span><br><span class="line">        Method m = method;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( isAuthzAnnotationPresent(m) ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//The &#x27;method&#x27; parameter could be from an interface that doesn&#x27;t have the annotation.</span></span><br><span class="line">        <span class="comment">//Check to see if the implementation has it.</span></span><br><span class="line">        <span class="keyword">if</span> ( targetClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                m = targetClass.getMethod(m.getName(), m.getParameterTypes());</span><br><span class="line">                <span class="keyword">if</span> ( isAuthzAnnotationPresent(m) ) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException ignored) &#123;</span><br><span class="line">                <span class="comment">//default return value is false.  If we can&#x27;t find the method, then obviously</span></span><br><span class="line">                <span class="comment">//there is no annotation, so just use the default return value.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAuthzAnnotationPresent</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>( Class&lt;? extends Annotation&gt; annClass : AUTHZ_ANNOTATION_CLASSES ) &#123;</span><br><span class="line">            Annotation a = AnnotationUtils.findAnnotation(method, annClass);</span><br><span class="line">            <span class="keyword">if</span> ( a != <span class="keyword">null</span> ) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AuthorizationAttributeSourceAdvisor类中的setAdvice方法，传入一个Advice（通知）。查看AopAllianceAnnotationsAuthorizingMethodInterceptor的继承关系发现该类继承自org.aopalliance.aop.Advice和org.apache.shiro.aop.MethodInterceptor<br><img src="/img/inherit_aopmethod_interceptor.png" alt="image"><br>AopAllianceAnnotationsAuthorizingMethodInterceptor的方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AopAllianceAnnotationsAuthorizingMethodInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;AuthorizingAnnotationMethodInterceptor&gt; interceptors =</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;AuthorizingAnnotationMethodInterceptor&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//use a Spring-specific Annotation resolver - Spring&#x27;s AnnotationUtils is nicer than the</span></span><br><span class="line">    <span class="comment">//raw JDK resolution process.</span></span><br><span class="line">    AnnotationResolver resolver = <span class="keyword">new</span> SpringAnnotationResolver();</span><br><span class="line">    <span class="comment">//we can re-use the same resolver instance - it does not retain state:</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> RoleAnnotationMethodInterceptor(resolver));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> PermissionAnnotationMethodInterceptor(resolver));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> AuthenticatedAnnotationMethodInterceptor(resolver));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> UserAnnotationMethodInterceptor(resolver));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> GuestAnnotationMethodInterceptor(resolver));</span><br><span class="line"></span><br><span class="line">    setMethodInterceptors(interceptors);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里添加了5个AuthorizingAnnotationMethodInterceptor，分别对应@RequiresRoles注解权限、@RequiresPermissions注解权限、@RequiresAuthentication注解权限、@RequiresUser注解权限和@RequiresGuest注解权限。这里以@RequiresPermissions为例展开讨论。<br>PermissionAnnotationMethodInterceptor继承自AuthorizingAnnotationMethodInterceptor，前者的内部构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PermissionAnnotationMethodInterceptor</span><span class="params">(AnnotationResolver resolver)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>( <span class="keyword">new</span> PermissionAnnotationHandler(), resolver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码new一个PermissionAnnotationHandler对象。然后PermissionAnnotationHandler对象的构造器设置annotationClass = RequiresPermissions.class，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PermissionAnnotationHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(RequiresPermissions.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样PermissionAnnotationMethodInterceptor就设置好了，回到AopAllianceAnnotationsAuthorizingMethodInterceptor方法拦截器中，代理对象的方法被调用时触发回调方法invoke()，调用间接父类AuthorizingMethodInterceptor的invoke()方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation methodInvocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        assertAuthorized(methodInvocation);</span><br><span class="line">        <span class="keyword">return</span> methodInvocation.proceed();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>调用assertAuthorized(methodInvocation)方法，即调用AopAllianceAnnotationsAuthorizingMethodInterceptor的父类AnnotationsAuthorizingMethodInterceptor的assertAuthorized(methodInvocation)方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Iterates over the internal &#123;<span class="doctag">@link</span> #getMethodInterceptors() methodInterceptors&#125; collection, and for each one,</span></span><br><span class="line"><span class="comment"> * ensures that if the interceptor</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> AuthorizingAnnotationMethodInterceptor#supports(org.apache.shiro.aop.MethodInvocation) supports&#125;</span></span><br><span class="line"><span class="comment"> * the invocation, that the interceptor</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> AuthorizingAnnotationMethodInterceptor#assertAuthorized(org.apache.shiro.aop.MethodInvocation) asserts&#125;</span></span><br><span class="line"><span class="comment"> * that the invocation is authorized to proceed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">assertAuthorized</span><span class="params">(MethodInvocation methodInvocation)</span> <span class="keyword">throws</span> AuthorizationException </span>&#123;</span><br><span class="line">    <span class="comment">//default implementation just ensures no deny votes are cast:</span></span><br><span class="line">    Collection&lt;AuthorizingAnnotationMethodInterceptor&gt; aamis = getMethodInterceptors();</span><br><span class="line">    <span class="keyword">if</span> (aamis != <span class="keyword">null</span> &amp;&amp; !aamis.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (AuthorizingAnnotationMethodInterceptor aami : aamis) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aami.supports(methodInvocation)) &#123;</span><br><span class="line">                aami.assertAuthorized(methodInvocation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面根据传入的AuthorizingAnnotationMethodInterceptor的不同，调用子类的assertAuthorized方法。因为这里传入的是PermissionAnnotationMethodInterceptor，故执行PermissionAnnotationMethodInterceptor的assertAuthorized方法，由于PermissionAnnotationMethodInterceptor没有重写assertAuthorized方法，故调用其父类AuthorizingAnnotationMethodInterceptor的assertAuthorized方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assertAuthorized</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> AuthorizationException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ((AuthorizingAnnotationHandler)getHandler()).assertAuthorized(getAnnotation(mi));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(AuthorizationException ae) &#123;</span><br><span class="line">        <span class="comment">// Annotation handler doesn&#x27;t know why it was called, so add the information here if possible. </span></span><br><span class="line">        <span class="comment">// Don&#x27;t wrap the exception here since we don&#x27;t want to mask the specific exception, such as </span></span><br><span class="line">        <span class="comment">// UnauthenticatedException etc. </span></span><br><span class="line">        <span class="keyword">if</span> (ae.getCause() == <span class="keyword">null</span>) ae.initCause(<span class="keyword">new</span> AuthorizationException(<span class="string">&quot;Not authorized to invoke method: &quot;</span> + mi.getMethod()));</span><br><span class="line">        <span class="keyword">throw</span> ae;</span><br><span class="line">    &#125;         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PermissionAnnotationMethodInterceptor类的继承关系如图：<br><img src="/img/permission_annotation_method_interceptor.png" alt="image"><br>((AuthorizingAnnotationHandler)getHandler()).assertAuthorized(getAnnotation(mi))调用即执行PermissionAnnotationHandler中的assertAuthorized方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ensures that the calling &lt;code&gt;Subject&lt;/code&gt; has the Annotation&#x27;s specified permissions, and if not, throws an</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;AuthorizingException&lt;/code&gt; indicating access is denied.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a the RequiresPermission annotation being inspected to check for one or more permissions</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> org.apache.shiro.authz.AuthorizationException</span></span><br><span class="line"><span class="comment"> *          if the calling &lt;code&gt;Subject&lt;/code&gt; does not have the permission(s) necessary to</span></span><br><span class="line"><span class="comment"> *          continue access or execution.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assertAuthorized</span><span class="params">(Annotation a)</span> <span class="keyword">throws</span> AuthorizationException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(a <span class="keyword">instanceof</span> RequiresPermissions)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    RequiresPermissions rpAnnotation = (RequiresPermissions) a;</span><br><span class="line">    String[] perms = getAnnotationValue(a);</span><br><span class="line">    Subject subject = getSubject();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (perms.length == <span class="number">1</span>) &#123;</span><br><span class="line">        subject.checkPermission(perms[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Logical.AND.equals(rpAnnotation.logical())) &#123;</span><br><span class="line">        getSubject().checkPermissions(perms);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Logical.OR.equals(rpAnnotation.logical())) &#123;</span><br><span class="line">        <span class="comment">// Avoid processing exceptions unnecessarily - &quot;delay&quot; throwing the exception by calling hasRole first</span></span><br><span class="line">        <span class="keyword">boolean</span> hasAtLeastOnePermission = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (String permission : perms) <span class="keyword">if</span> (getSubject().isPermitted(permission)) hasAtLeastOnePermission = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// Cause the exception if none of the role match, note that the exception message will be a bit misleading</span></span><br><span class="line">        <span class="keyword">if</span> (!hasAtLeastOnePermission) getSubject().checkPermission(perms[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码通过getSubject()方法获取用户对象，通过subject.checkPermission方法进行授权验证，进入到DelegatingSubject类中，查看checkPermission方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkPermission</span><span class="params">(String permission)</span> <span class="keyword">throws</span> AuthorizationException </span>&#123;</span><br><span class="line">    assertAuthzCheckPossible();</span><br><span class="line">    securityManager.checkPermission(getPrincipals(), permission);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行securityManager.checkPermission(getPrincipals(), permission)，进入AuthorizingSecurityManager中，执行方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkPermission</span><span class="params">(PrincipalCollection principals, String permission)</span> <span class="keyword">throws</span> AuthorizationException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.authorizer.checkPermission(principals, permission);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AuthorizingSecurityManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.authorizer = <span class="keyword">new</span> ModularRealmAuthorizer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，上面调用ModularRealmAuthorizer.checkPermission方法，该方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkPermission</span><span class="params">(PrincipalCollection principals, String permission)</span> <span class="keyword">throws</span> AuthorizationException </span>&#123;</span><br><span class="line">    assertRealmsConfigured();</span><br><span class="line">    <span class="keyword">if</span> (!isPermitted(principals, permission)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnauthorizedException(<span class="string">&quot;Subject does not have permission [&quot;</span> + permission + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法首先检查realm是否被设置，然后调用isPermitted方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPermitted</span><span class="params">(PrincipalCollection principals, String permission)</span> </span>&#123;</span><br><span class="line">    assertRealmsConfigured();</span><br><span class="line">    <span class="keyword">for</span> (Realm realm : getRealms()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(realm <span class="keyword">instanceof</span> Authorizer)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (((Authorizer) realm).isPermitted(principals, permission)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就调用到了Realm的isPermitted方法，查看Realm的注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;Most users will not implement the &lt;tt&gt;Realm&lt;/tt&gt; <span class="class"><span class="keyword">interface</span> <span class="title">directly</span>, <span class="title">but</span> <span class="title">will</span> <span class="title">extend</span> <span class="title">one</span> <span class="title">of</span> <span class="title">the</span> <span class="title">subclasses</span>,</span></span><br><span class="line"><span class="class"> * </span>&#123;<span class="meta">@link</span> org.apache.shiro.realm.AuthenticatingRealm AuthenticatingRealm&#125; or &#123;<span class="meta">@link</span> org.apache.shiro.realm.AuthorizingRealm&#125;, greatly reducing the effort requird</span><br><span class="line"> * to implement a &lt;tt&gt;Realm&lt;/tt&gt; from scratch.&lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * <span class="meta">@see</span> org.apache.shiro.realm.CachingRealm CachingRealm</span><br><span class="line"> * <span class="meta">@see</span> org.apache.shiro.realm.AuthenticatingRealm AuthenticatingRealm</span><br><span class="line"> * <span class="meta">@see</span> org.apache.shiro.realm.AuthorizingRealm AuthorizingRealm</span><br><span class="line"> * <span class="meta">@see</span> org.apache.shiro.authc.pam.ModularRealmAuthenticator ModularRealmAuthenticator</span><br></pre></td></tr></table></figure>
<p>上面解释了大部分开发者不会直接实现Realm类，而是选择实现其几个子类。这里便使用了AuthorizingRealm的isPermitted方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPermitted</span><span class="params">(PrincipalCollection principals, Permission permission)</span> </span>&#123;</span><br><span class="line">    AuthorizationInfo info = getAuthorizationInfo(principals);</span><br><span class="line">    <span class="keyword">return</span> isPermitted(permission, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getAuthorizationInfo(principals)方法是获取对象拥有的权限信息，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param principals the corresponding Subject&#x27;s identifying principals with which to look up the Subject&#x27;s</span></span><br><span class="line"><span class="comment"> *                   &#123;@code AuthorizationInfo&#125;.</span></span><br><span class="line"><span class="comment"> * @return the authorization information for the account associated with the specified &#123;@code principals&#125;,</span></span><br><span class="line"><span class="comment"> *         or &#123;@code null&#125; if no account could be found.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">getAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (principals == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AuthorizationInfo info = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">        log.trace(<span class="string">&quot;Retrieving AuthorizationInfo for principals [&quot;</span> + principals + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查缓存，如果有AuthorizationInfo则返回</span></span><br><span class="line">    Cache&lt;Object, AuthorizationInfo&gt; cache = getAvailableAuthorizationCache();</span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">            log.trace(<span class="string">&quot;Attempting to retrieve the AuthorizationInfo from cache.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Object key = getAuthorizationCacheKey(principals);</span><br><span class="line">        info = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (info == <span class="keyword">null</span>) &#123;</span><br><span class="line">                log.trace(<span class="string">&quot;No AuthorizationInfo found in cache for principals [&quot;</span> + principals + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.trace(<span class="string">&quot;AuthorizationInfo found in cache for principals [&quot;</span> + principals + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Call template method if the info was not found in a cache</span></span><br><span class="line">        info = doGetAuthorizationInfo(principals);</span><br><span class="line">        <span class="comment">// If the info is not null and the cache has been created, then cache the authorization info.</span></span><br><span class="line">        <span class="keyword">if</span> (info != <span class="keyword">null</span> &amp;&amp; cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">                log.trace(<span class="string">&quot;Caching authorization info for principals: [&quot;</span> + principals + <span class="string">&quot;].&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Object key = getAuthorizationCacheKey(principals);</span><br><span class="line">            cache.put(key, info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中执行info = doGetAuthorizationInfo(principals);该方法就是我们自定义的StatelessAuthorizingRealm（继承自AuthorizingRealm）里面实现的doGetAuthorizationInfo方法，该方法返回AuthorizationInfo，然后调用重载的isPermitted方法，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//changed visibility from private to protected for SHIRO-332</span><br><span class="line">protected boolean isPermitted(Permission permission, AuthorizationInfo info) &#123;</span><br><span class="line">    Collection&lt;Permission&gt; perms = getPermissions(info);</span><br><span class="line">    if (perms != null &amp;&amp; !perms.isEmpty()) &#123;</span><br><span class="line">        for (Permission perm : perms) &#123;</span><br><span class="line">            if (perm.implies(permission)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方法判断通过注解@RequiresPermissions传入的permission是否在AuthorizationInfo中，如果在就返回true，允许用户访问该资源。到此@RequiresPermissions的权限控制就结束了。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>shiro</tag>
        <tag>annotation</tag>
        <tag>aop</tag>
        <tag>interceptor</tag>
      </tags>
  </entry>
  <entry>
    <title>sinosteel代码详解</title>
    <url>/2017/11/10/java_spring/sinosteel%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p><a href="https://github.com/DimitriZhao/sinosteel.git">Github代码仓库</a></p>
<h2 id="spring开发服务器端"><a href="#spring开发服务器端" class="headerlink" title="spring开发服务器端"></a>spring开发服务器端</h2><h3 id="Http消息机制-也即一些编程规范"><a href="#Http消息机制-也即一些编程规范" class="headerlink" title="Http消息机制(也即一些编程规范)"></a>Http消息机制(也即一些编程规范)</h3><ol>
<li><strong>controller一般只负责Http消息的传输；service负责业务逻辑的处理；repository负责执行数据库操作；domain层是领域模型对象，对应数据库中相应的表</strong></li>
<li>controller中基本的交互方法应写成：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;自定义的路径&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">doSomething</span><span class="params">(Request request)</span></span></span><br></pre></td></tr></table></figure>
<p>所有的Http请求都会被解析为Request类的实例，而对于基本的返回类型（String、JSON之类的），则一律定义成Response类实例</p>
<span id="more"></span>
<h3 id="基础CURD"><a href="#基础CURD" class="headerlink" title="基础CURD"></a>基础CURD</h3><ol>
<li>很多框架会有比如BaseEntity，BaseDao，BaseService之类的基础类，很多新建的领域对象模型都是从这些基础类继承而来。</li>
<li>orm框架：hibernate和mybatis各有千秋</li>
</ol>
<h2 id="RequiresAuthorization的实现"><a href="#RequiresAuthorization的实现" class="headerlink" title="@RequiresAuthorization的实现"></a>@RequiresAuthorization的实现</h2><p>以framework-example中的StandardController为例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//通过切面编程实现</span></span><br><span class="line"><span class="meta">@RequiresAuthorization(</span></span><br><span class="line"><span class="meta">		requestType = RequestType.QUERY, </span></span><br><span class="line"><span class="meta">		serviceClass = UserService.class, </span></span><br><span class="line"><span class="meta">		queryScope = AuthorizationScope.ALL,</span></span><br><span class="line"><span class="meta">		editScope = AuthorizationScope.ORGANIZATION,</span></span><br><span class="line"><span class="meta">		deleteScope = AuthorizationScope.ORGANIZATION)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">queryStandards</span><span class="params">(Request request)</span></span>&#123;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>queryStandards方法前面加上了@RequiresAuthorization注解，看一下@RequiresAuthorization的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注解表明这个注解应该被 javadoc工具记录</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="comment">//用于设定注解使用范围，这里表明注解仅使用于方法上</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span>  </span><br><span class="line"><span class="comment">//用于说明这种类型的注解会被保留到那个阶段。此处注解能在运行时被JVM或其他使用反射机制的代码所读取和使用.</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequiresAuthorization</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">RequestType <span class="title">requestType</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function">AuthorizationScope <span class="title">queryScope</span><span class="params">()</span> <span class="keyword">default</span> AuthorizationScope.ORGANIZATION</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function">AuthorizationScope <span class="title">editScope</span><span class="params">()</span> <span class="keyword">default</span> AuthorizationScope.USER</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function">AuthorizationScope <span class="title">deleteScope</span><span class="params">()</span> <span class="keyword">default</span> AuthorizationScope.USER</span>;</span><br><span class="line">	</span><br><span class="line">	Class&lt;? extends BaseService&lt;? extends BaseEntity&gt;&gt; serviceClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当queryStandards方法执行的时候，将会触发com.sinosteel.framework.core.auth包下面的类AuthorizationAspect中的filterAuthorizations方法，AuthorizationAspect被定义为一个切面，filterAuthorizations方法作为@RequiresAuthorization注解的切入点。进入该方法内部：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   Object arg = args[<span class="number">0</span>];</span><br><span class="line">Request request = (Request) arg;</span><br><span class="line">User requestUser = request.getUser();</span><br></pre></td></tr></table></figure>
<p>此处获取Controller中queryStandards方法的入口参数，即一个Request，并获取request中的参数user。查看Request的类型定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> User user;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String uri;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String client;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String dateTime;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> JSONObject params;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> List&lt;MultipartFile&gt; files;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//constructers, getters and setters</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后将@RequireAuthorization注解中的属性值提取出来，得到requestType, serviceClass, queryScope, editScope，deleteScope。接着进行环绕处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">if</span>(requestType == RequestType.QUERY)</span><br><span class="line">&#123;</span><br><span class="line">	Response response = (Response) joinPoint.proceed(args);</span><br><span class="line">	JSON data = response.data;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(data <span class="keyword">instanceof</span> JSONObject) <span class="comment">//pageResult</span></span><br><span class="line">	&#123;</span><br><span class="line">		JSONObject dataJson = (JSONObject) data;</span><br><span class="line">		JSONArray dataJsonArray = dataJson.getJSONArray(<span class="string">&quot;data&quot;</span>);   <span class="comment">//一些Standard</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> filteredDataCount = filterData(dataJsonArray, requestUser, queryScope, editScope, deleteScope);</span><br><span class="line">		<span class="keyword">int</span> total = dataJson.getIntValue(<span class="string">&quot;total&quot;</span>);</span><br><span class="line">		dataJson.put(<span class="string">&quot;total&quot;</span>, total - filteredDataCount);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(data <span class="keyword">instanceof</span> JSONArray) <span class="comment">//list</span></span><br><span class="line">	&#123;</span><br><span class="line">		JSONArray dataJsonArray = (JSONArray) data;</span><br><span class="line">		filterData(dataJsonArray, requestUser, queryScope, editScope, deleteScope);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码首先判断请求类型为QUERY，则执行查询操作，即执行Controller中的standardService.queryStandards(request.getParams())方法，进入queryStandards方法，在com.sinosteel.metallurgical.knowledge.service.StandardService中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> JSONObject <span class="title">queryStandards</span><span class="params">(JSONObject params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	StringBuilder hqlBuilder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;FROM Standard standard WHERE 1 = 1 &quot;</span>);</span><br><span class="line">	HashMap&lt;String, Object&gt; paramsMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//更改查询条件，加入查询变量到paramsMap中</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	hqlBuilder.append(<span class="string">&quot;ORDER BY ISSUE_DATE DESC&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在params中得到分页信息后，将该分页信息转化为Pager对象</span></span><br><span class="line">	Pager pager = JSONObject.toJavaObject(params.getJSONObject(<span class="string">&quot;pagination&quot;</span>), Pager.class);</span><br><span class="line">	PageResult&lt;Standard&gt; pageResult = standardRepository.executeHql(hqlBuilder.toString(), paramsMap, pager);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> pageResult.toJSONObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法定义好查询语句后执行standardRepository.executeHql方法，即执行standardRepository的实现类standardRepositoryImpl中的executeHql方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> PageResult&lt;T&gt; <span class="title">executeHql</span><span class="params">(String hql, HashMap&lt;String, Object&gt; paramsMap, Pager pager)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Query query = <span class="keyword">this</span>.entityManager.createQuery(hql);</span><br><span class="line">	setParams(query, paramsMap);</span><br><span class="line">	setPager(query, pager);	</span><br><span class="line">	List&lt;T&gt; data = query.getResultList();</span><br><span class="line">	</span><br><span class="line">	String countHql = <span class="keyword">this</span>.genCountSql(hql);</span><br><span class="line">	Query countQuery = <span class="keyword">this</span>.entityManager.createQuery(countHql);</span><br><span class="line">	setParams(countQuery, paramsMap);</span><br><span class="line">	<span class="keyword">int</span> total =  Integer.parseInt(countQuery.getSingleResult().toString());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//PageResult中第二个参数为模板，可为任意类型的值，此处为查询结果集，List&lt;T&gt;</span></span><br><span class="line">	PageResult&lt;T&gt; queryResult = <span class="keyword">new</span> PageResult&lt;T&gt;(total, data);</span><br><span class="line">	<span class="keyword">return</span> queryResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先设置查询变量和分页信息，其中setPager需要注意：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setPager</span><span class="params">(Query query, Pager pager)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(pager != <span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> current = pager.current;</span><br><span class="line">		<span class="keyword">int</span> pageSize = pager.pageSize;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> firstIndex = pageSize * (current - <span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">		query.setFirstResult(firstIndex);</span><br><span class="line">		query.setMaxResults(pageSize);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里设置每页只查询pageSize条记录，根据current的不同设置查询结果集的初始位置=pageSize * (current - 1)。回到execuSql方法中，查询完得到的结果是长度为pageSize的记录，数据类型为Standard，这里用模板T表示的，泛指所有可查询类型。将查询结果数量total和data封装到PageResult中返回给StandardService中的queryStandards方法，该方法将pageResult对象转换为JSONObject后返回给Controller中的queryStandards方法，Controller中的queryStandards方法将该JSONObject封装到Response对象中返回给调用方。查看Response的类型定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> ResponseType status;</span><br><span class="line">	<span class="keyword">public</span> JSON data;   <span class="comment">//可以使JSONArray，也可以时JSONObject</span></span><br><span class="line">	<span class="keyword">public</span> String message;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Response</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.status = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">this</span>.data = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">this</span>.message = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Response</span><span class="params">(ResponseType status, JSON data, String message)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.status = status;</span><br><span class="line">		<span class="keyword">this</span>.data = data;</span><br><span class="line">		<span class="keyword">this</span>.message = message;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此queryStandards方法执行完毕，返回到环绕处理阶段。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">if</span>(requestType == RequestType.QUERY)</span><br><span class="line">&#123;</span><br><span class="line">	Response response = (Response) joinPoint.proceed(args);</span><br><span class="line">	JSON data = response.data;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(data <span class="keyword">instanceof</span> JSONObject) <span class="comment">//pageResult</span></span><br><span class="line">	&#123;</span><br><span class="line">		JSONObject dataJson = (JSONObject) data;</span><br><span class="line">		JSONArray dataJsonArray = dataJson.getJSONArray(<span class="string">&quot;data&quot;</span>);   <span class="comment">//一些Standard</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> filteredDataCount = filterData(dataJsonArray, requestUser, queryScope, editScope, deleteScope);</span><br><span class="line">		<span class="keyword">int</span> total = dataJson.getIntValue(<span class="string">&quot;total&quot;</span>);</span><br><span class="line">		dataJson.put(<span class="string">&quot;total&quot;</span>, total - filteredDataCount);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(data <span class="keyword">instanceof</span> JSONArray) <span class="comment">//list</span></span><br><span class="line">	&#123;</span><br><span class="line">		JSONArray dataJsonArray = (JSONArray) data;</span><br><span class="line">		filterData(dataJsonArray, requestUser, queryScope, editScope, deleteScope);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上我们得到返回值response，获取response中的data（pageResult），获取pageResult中的data属性值（<code>List&lt;Standard&gt;</code>类型），赋值给dataJsonArray，调用filterData方法，遍历dataJsonArrary，过滤掉不满足权限控制的查询结果，并修改total的值为原结果集中的数量-过滤掉的数量，最后返回过滤后的response。</p>
<p>进入filterData方法：<br>遍历dataJsonArrary，对每一个查询到的Standard结果，获取创建该Standard的用户的ID，即createdUserID，并取得该用户所在的组织的ID，即authorizedOrganizationIds。判断queryScope（删除和修改操作对应的是deleteScope和editScope）的值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//控制query权限</span></span><br><span class="line"><span class="keyword">switch</span>(queryScope)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">case</span> ALL:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">case</span> ORGANIZATION:</span><br><span class="line">		<span class="keyword">if</span>(!hasAuthorization(queryAuthorizedOrganizationIds, authorizedOrganizationIds) &amp;&amp; !hasAuthorization(requestOrganizationIds, authorizedOrganizationIds))</span><br><span class="line">		&#123;</span><br><span class="line">			iter.remove();  <span class="comment">//删除不是authorizedOrganizationIds授权的查询结果（Standard）</span></span><br><span class="line">			filtered = <span class="keyword">true</span>;</span><br><span class="line">			filteredDataCount++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">case</span> USER:</span><br><span class="line">		<span class="keyword">if</span>(!hasAuthorization(queryAuthorizedOrganizationIds, authorizedOrganizationIds) &amp;&amp; !requestUserId.equals(authorizedUserId))</span><br><span class="line">		&#123;</span><br><span class="line">			iter.remove();</span><br><span class="line">			filtered = <span class="keyword">true</span>;</span><br><span class="line">			filteredDataCount++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">case</span> NONE:</span><br><span class="line">		iter.remove();</span><br><span class="line">		filtered = <span class="keyword">true</span>;</span><br><span class="line">		filteredDataCount++;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果为ORGANIZATION，则判断用户是否有查询authorizedOrganizationIds的权限以及用户是否属于authorizedOrganizationIds这个组织，如果都不满足，则将该条查询从dataJsonArrary中删除。由此完成了权限控制。</p>
<p><strong>总结一下</strong>：@RequiresAuthorization注解是通过切面来实现的，用户在浏览器访问/queryStandards时，该切面便会执行，完成权限控制。</p>
<h2 id="shiro注解授权源码实现"><a href="#shiro注解授权源码实现" class="headerlink" title="shiro注解授权源码实现"></a>shiro注解授权源码实现</h2><h3 id="授权流程"><a href="#授权流程" class="headerlink" title="授权流程"></a>授权流程</h3><p>概括的说，shiro在实现注解授权时采用的是Spring AOP的方式。<br>从com.sinosteel.framework.config.shiro.ShiroConfig开始，该类用@Configuration注解，表示为一个Spring IoC容器，往IoC容器中加入一个Bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AuthorizationAttributeSourceAdvisor <span class="title">authorizationAttributeSourceAdvisor</span><span class="params">(SecurityManager securityManager)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = <span class="keyword">new</span> AuthorizationAttributeSourceAdvisor();</span><br><span class="line">	authorizationAttributeSourceAdvisor.setSecurityManager(securityManager);</span><br><span class="line">	<span class="keyword">return</span> authorizationAttributeSourceAdvisor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AuthorizationAttributeSourceAdvisor继承自StaticMethodMatcherPointcutAdvisor，StaticMethodMatcherPointcutAdvisor为静态方法匹配器切点定义的切面，默认情况下，匹配所有的目标类；继承自PointcutAdvisor，代表具有切点的切面，它包含Advice和Pointcut两个类，这样我们就可以通过类、方法名以及方法方位等信息灵活地定义切面的连接点，提供更具适用性的切面。将shiro的securityManager传入AuthorizationAttributeSourceAdvisor中。<br>AuthorizationAttributeSourceAdvisor类定义了一个切面，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationAttributeSourceAdvisor</span> <span class="keyword">extends</span> <span class="title">StaticMethodMatcherPointcutAdvisor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(AuthorizationAttributeSourceAdvisor.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;? extends Annotation&gt;[] AUTHZ_ANNOTATION_CLASSES =</span><br><span class="line">            <span class="keyword">new</span> Class[] &#123;</span><br><span class="line">                    RequiresPermissions.class, RequiresRoles.class,</span><br><span class="line">                    RequiresUser.class, RequiresGuest.class, RequiresAuthentication.class</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> SecurityManager securityManager = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a new AuthorizationAttributeSourceAdvisor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuthorizationAttributeSourceAdvisor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        **setAdvice**(<span class="keyword">new</span> AopAllianceAnnotationsAuthorizingMethodInterceptor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SecurityManager <span class="title">getSecurityManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecurityManager</span><span class="params">(org.apache.shiro.mgt.SecurityManager securityManager)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.securityManager = securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &lt;tt&gt;true&lt;/tt&gt; if the method has any Shiro annotations, false otherwise.</span></span><br><span class="line"><span class="comment">     * The annotations inspected are:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;&#123;<span class="doctag">@link</span> org.apache.shiro.authz.annotation.RequiresAuthentication RequiresAuthentication&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;&#123;<span class="doctag">@link</span> org.apache.shiro.authz.annotation.RequiresUser RequiresUser&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;&#123;<span class="doctag">@link</span> org.apache.shiro.authz.annotation.RequiresGuest RequiresGuest&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;&#123;<span class="doctag">@link</span> org.apache.shiro.authz.annotation.RequiresRoles RequiresRoles&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;&#123;<span class="doctag">@link</span> org.apache.shiro.authz.annotation.RequiresPermissions RequiresPermissions&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method      the method to check for a Shiro annotation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetClass the class potentially declaring Shiro annotations</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if the method has a Shiro annotation, false otherwise.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.aop.MethodMatcher#matches(java.lang.reflect.Method, Class)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class targetClass)</span> </span>&#123;</span><br><span class="line">        Method m = method;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( isAuthzAnnotationPresent(m) ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//The &#x27;method&#x27; parameter could be from an interface that doesn&#x27;t have the annotation.</span></span><br><span class="line">        <span class="comment">//Check to see if the implementation has it.</span></span><br><span class="line">        <span class="keyword">if</span> ( targetClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                m = targetClass.getMethod(m.getName(), m.getParameterTypes());</span><br><span class="line">                <span class="keyword">if</span> ( isAuthzAnnotationPresent(m) ) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException ignored) &#123;</span><br><span class="line">                <span class="comment">//default return value is false.  If we can&#x27;t find the method, then obviously</span></span><br><span class="line">                <span class="comment">//there is no annotation, so just use the default return value.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAuthzAnnotationPresent</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>( Class&lt;? extends Annotation&gt; annClass : AUTHZ_ANNOTATION_CLASSES ) &#123;</span><br><span class="line">            Annotation a = AnnotationUtils.findAnnotation(method, annClass);</span><br><span class="line">            <span class="keyword">if</span> ( a != <span class="keyword">null</span> ) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AuthorizationAttributeSourceAdvisor类中的setAdvice方法，传入一个Advice（通知）。查看AopAllianceAnnotationsAuthorizingMethodInterceptor的继承关系发现该类继承自org.aopalliance.aop.Advice和org.apache.shiro.aop.MethodInterceptor<br><img src="/img/inherit_aopmethod_interceptor.png" alt="image"><br>AopAllianceAnnotationsAuthorizingMethodInterceptor的方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AopAllianceAnnotationsAuthorizingMethodInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;AuthorizingAnnotationMethodInterceptor&gt; interceptors =</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;AuthorizingAnnotationMethodInterceptor&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//use a Spring-specific Annotation resolver - Spring&#x27;s AnnotationUtils is nicer than the</span></span><br><span class="line">    <span class="comment">//raw JDK resolution process.</span></span><br><span class="line">    AnnotationResolver resolver = <span class="keyword">new</span> SpringAnnotationResolver();</span><br><span class="line">    <span class="comment">//we can re-use the same resolver instance - it does not retain state:</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> RoleAnnotationMethodInterceptor(resolver));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> PermissionAnnotationMethodInterceptor(resolver));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> AuthenticatedAnnotationMethodInterceptor(resolver));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> UserAnnotationMethodInterceptor(resolver));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> GuestAnnotationMethodInterceptor(resolver));</span><br><span class="line"></span><br><span class="line">    setMethodInterceptors(interceptors);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里添加了5个AuthorizingAnnotationMethodInterceptor，分别对应@RequiresRoles注解权限、@RequiresPermissions注解权限、@RequiresAuthentication注解权限、@RequiresUser注解权限和@RequiresGuest注解权限。这里以@RequiresPermissions为例展开讨论。<br>PermissionAnnotationMethodInterceptor内部构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PermissionAnnotationMethodInterceptor</span><span class="params">(AnnotationResolver resolver)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>( <span class="keyword">new</span> PermissionAnnotationHandler(), resolver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码new一个PermissionAnnotationHandler对象。然后PermissionAnnotationHandler对象的构造器设置annotationClass = RequiresPermissions.class，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PermissionAnnotationHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(RequiresPermissions.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样PermissionAnnotationMethodInterceptor就设置好了，回到AopAllianceAnnotationsAuthorizingMethodInterceptor方法拦截器中，代理对象的方法被调用时触发回调方法invoke()，调用父类AuthorizingMethodInterceptor的invoke()方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation methodInvocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        assertAuthorized(methodInvocation);</span><br><span class="line">        <span class="keyword">return</span> methodInvocation.proceed();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在com.sinosteel.framework.config.shiro.ShiroConfig类中，定义了一个Spring IoC容器，配置了securityManager，并配置securityManager的subjectFactory（用于产生subject，setSessionCreationEnabled(false)，表示不创建会话，将web应用做成无会话的），sessionManager（会话管理）和realm（就是自定义的com.sinosteel.framework.core.auth.StatelessAuthorizingRealm）。<br>还定义了StatelessAccessControlFilter，根据当前请求上下文信息每次请求时都要登录的认证过滤器，重写onAccessDenied方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAccessDenied</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	String clientDigest = request.getParameter(<span class="string">&quot;clientDigest&quot;</span>);</span><br><span class="line">    	String username = request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line"></span><br><span class="line">    	StatelessAuthenticationToken token = <span class="keyword">new</span> StatelessAuthenticationToken(username, clientDigest);</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">try</span> </span><br><span class="line">    	&#123;</span><br><span class="line">    		getSubject(request, response).login(token);</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    	&#125; </span><br><span class="line">    	<span class="keyword">catch</span> (Exception e) </span><br><span class="line">    	&#123;</span><br><span class="line">    		e.printStackTrace();</span><br><span class="line">    		onLoginFail(response);</span><br><span class="line">           </span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>客户端在验证时，除了发送用户名和密码外，还需要发送使用基于散列的消息认证码生成的消息摘要，StatelessAccessControlFilter收到验证请求后，根据username和消息摘要生成无状态的token，并交由StatelessAuthorizingRealm进行验证。StatelessAuthorizingRealm的doGetAuthenticationInfo方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span></span><br><span class="line"><span class="function">    </span>&#123;	</span><br><span class="line">    	StatelessAuthenticationToken statelessToken = (StatelessAuthenticationToken)token;</span><br><span class="line">    	String username = (String)statelessToken.getPrincipal();</span><br><span class="line">    	</span><br><span class="line">    	JSONObject userInfoJson = CacheUtil.getUserInfoJson(username);</span><br><span class="line">    	<span class="keyword">if</span>(userInfoJson == <span class="keyword">null</span>)</span><br><span class="line">    	&#123; 	</span><br><span class="line">    		User user = userRepository.findByUsername(username);  </span><br><span class="line">        	<span class="keyword">if</span>(user == <span class="keyword">null</span>)</span><br><span class="line">        	&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        	</span><br><span class="line">        	userInfoJson = CacheUtil.saveUserInfoCache(user);</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	String serverDigest = HmacSHA256Util.digest(getKey(username), userInfoJson.getString(<span class="string">&quot;password&quot;</span>));</span><br><span class="line"></span><br><span class="line">    	SimpleAuthenticationInfo authenticationInfo = <span class="keyword">new</span> SimpleAuthenticationInfo(username, serverDigest, getName());</span><br><span class="line">    	<span class="keyword">return</span> authenticationInfo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>此处首先根据客户端传入的用户名获取相应的密钥，然后使用密钥对请求参数生成服务器端的消息摘要serverDigest；然后生成authenticationInfo，返回给调用方，与客户端的消息摘要进行匹配；如果匹配，说明是合法客户端传入的，则login成功；否则是非法的。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>shiro</tag>
        <tag>annotation</tag>
        <tag>aspect</tag>
        <tag>hibernate</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>部署DC环境</title>
    <url>/2018/03/29/system_management/%E9%83%A8%E7%BD%B2DC%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="基础环境搭建"><a href="#基础环境搭建" class="headerlink" title="基础环境搭建"></a>基础环境搭建</h1><p>四台阿里云集群：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">172.0.0.1    master1</span><br><span class="line">172.0.0.2    agent1</span><br><span class="line">172.0.0.3    agent2</span><br><span class="line">172.0.0.4    agent3</span><br></pre></td></tr></table></figure>
<p>其中172.0.0.1机器可以访问外网(47.0.0.1)。</p>
<span id="more"></span>

<h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>每台机器都安装</p>
<ul>
<li>安装必要的packages<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br></pre></td></tr></table></figure></li>
<li>配置阿里镜像源<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></li>
<li>安装docker<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install docker-ce</span><br></pre></td></tr></table></figure></li>
<li>开启docker服务<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>
<h3 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h3>docker daemon不能启动，即执行<code>systemctl start docker</code>时提示<code>Job for docker.service failed because the control process exited with error code. See &quot;systemctl status docker.service&quot; and &quot;journalctl -xe&quot; for details. </code>，执行<code>systemctl status docker.service </code>，输出<code> Active: failed (Result: start-limit)  Process: 7880 ExecStart=/usr/bin/dockerd (code=exited, status=1/FAILURE) Main PID: 7880 (code=exited, status=1/FAILURE)</code>。<br>解决方法：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -rf /var/lib/docker/</span><br><span class="line"><span class="comment"># 添加如下内容</span></span><br><span class="line"><span class="comment"># vim /etc/docker/daemon.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;graph&quot;</span>: <span class="string">&quot;/mnt/docker-data&quot;</span>,</span><br><span class="line">    <span class="string">&quot;storage-driver&quot;</span>: <span class="string">&quot;overlay&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="安装Glusterfs"><a href="#安装Glusterfs" class="headerlink" title="安装Glusterfs"></a>安装Glusterfs</h2><ul>
<li>每台机器都安装<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install glusterfs</span><br><span class="line">yum install glusterfs-cli</span><br><span class="line">yum install glusterfs-libs</span><br><span class="line">yum install glusterfs-server</span><br><span class="line">yum install glusterfs-fuse</span><br><span class="line">yum install glusterfs-geo-replication</span><br></pre></td></tr></table></figure></li>
<li>在每台机器上的/etc/hosts文件中添加hosts信息：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">172.0.0.1    master1</span><br><span class="line">172.0.0.2    agent1</span><br><span class="line">172.0.0.3    agent2</span><br><span class="line">172.0.0.4    agent3</span><br></pre></td></tr></table></figure></li>
<li>加入peer<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># master1上：</span></span><br><span class="line">gluster peer probe agent1</span><br><span class="line">gluster peer probe agent2</span><br><span class="line">gluster peer probe agent3</span><br><span class="line"><span class="comment"># 在各台机器上查看peer status</span></span><br><span class="line">gluster peer status</span><br></pre></td></tr></table></figure></li>
<li>创建两个volume，一个做复制卷(replica=2)，一个Hash卷<ul>
<li><p>创建复制卷：</p>
<ul>
<li>在master1和agent1上创建<code>/data/repli</code>目录</li>
<li>执行<code>gluster volume create replica_volume replica 2 transport tcp master1:/data/repli agent1:/data/repli force</code>创建名为replica_volume的复制卷</li>
<li>执行<code>gluster volume start replica_volume</code>开启复制卷</li>
<li>在master1上创建目录<code>/data/mnt</code>用于挂载复制卷</li>
<li>执行<code>mount -t glusterfs master1:replica_volume /data/mnt</code>挂载复制卷</li>
</ul>
</li>
<li><p>创建Hash卷</p>
<ul>
<li>分别在四台机器上创建<code>/data/hash</code>目录</li>
<li>执行<code>gluster volume create hash_volume master1:/data/hash agent1:/data/hash agent2:/data/hash agent3:/data/hash force </code>创建名为hash_volume的Hash卷</li>
<li>执行<code>gluster volume start hash_volume</code></li>
<li>在master1上创建目录<code>/data/mnt_hash</code>用于挂载Hash卷</li>
<li>执行<code>mount -t glusterfs master1:hash_volume /data/mnt_hash</code>挂载Hash卷</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Mesos-Zookeeper-Marathon集群搭建"><a href="#Mesos-Zookeeper-Marathon集群搭建" class="headerlink" title="Mesos+Zookeeper+Marathon集群搭建"></a>Mesos+Zookeeper+Marathon集群搭建</h2><h3 id="Mesos-master节点"><a href="#Mesos-master节点" class="headerlink" title="Mesos-master节点"></a>Mesos-master节点</h3><p>这里使用master1节点作为mesos-master，配置如下：</p>
<ul>
<li><p>关闭selinux</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;/SELINUX/s/enforcing/disabled/&#x27;</span> /etc/selinux/config</span><br><span class="line">setenforce 0</span><br></pre></td></tr></table></figure></li>
<li><p>关闭防火墙</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service</span><br></pre></td></tr></table></figure></li>
<li><p>添加mesos的yum源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -Uvh http://repos.mesosphere.io/el/7/noarch/RPMS/mesosphere-el-repo-7-1.noarch.rpm</span><br></pre></td></tr></table></figure></li>
<li><p>安装依赖的JDK环境、Mesos1.5.0、Marathon、Zookeeper</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需要java8</span></span><br><span class="line">yum install -y java-1.8.0-openjdk-devel java-1.8.0-openjdk      </span><br><span class="line">yum -y install mesos marathon mesosphere-zookeeper</span><br></pre></td></tr></table></figure></li>
<li><p>配置Zookeeper<br>我们将master1、agent1和agent2作为zookeeper的三个Znode，分别编号为1,2,3；zookeeper的配置必须在这三个Znode上都完成。</p>
<ul>
<li><p>将编号写到/var/lib/zookeeper/myid文件中去：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">master1: <span class="built_in">echo</span> 1 &gt; /var/lib/zookeeper/myid</span><br><span class="line">agent1: <span class="built_in">echo</span> 2 &gt; /var/lib/zookeeper/myid</span><br><span class="line">agent2: <span class="built_in">echo</span> 3 &gt; /var/lib/zookeeper/myid</span><br></pre></td></tr></table></figure></li>
<li><p>修改zookeeper文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 备份zoo.cfg文件</span></span><br><span class="line">cp /etc/zookeeper/conf/zoo.cfg /etc/zookeeper/conf/zoo.cfg.bak</span><br><span class="line"><span class="comment"># 然后往zoo.cfg文件中加入以下配置信息：</span></span><br><span class="line">server.1=master1:2888:3888</span><br><span class="line">server.2=agent1:2888:3888</span><br><span class="line">server.3=agent2:2888:3888 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>配置Mesos-master</p>
<ul>
<li>在/etc/mesos/zk文件中加入<code>zk://172.0.0.1:2181,172.0.0.2:2181,172.0.0.3:2181/mesos</code></li>
<li>设置文件/etc/mesos-master/quorum内容为一个大于（master节点数除以2）的整数。这里只有一个master，故quorum设置为1：<code>echo 1 &gt;/etc/mesos-master/quorum</code>。</li>
<li>创建目录：<code>mkdir -p /etc/marathon/conf</code></li>
<li>设置mesos-master的hostname：<code>echo 172.0.0.1 &gt; /etc/mesos-master/hostname</code></li>
<li>设置marathon的hostname：<code>echo 172.0.0.1 &gt; /etc/marathon/conf/hostname</code></li>
<li>在/etc/marathon/conf/master文件中加入<code>zk://172.0.0.1:2181,172.0.0.2:2181,172.0.0.3:2181/mesos</code></li>
<li>在/etc/marathon/conf/zk文件中加入<code>zk://172.0.0.1:2181,172.0.0.2:2181,172.0.0.3:2181/marathon</code></li>
</ul>
</li>
<li><p>启动mesos，marathon，zookeeper</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> zookeeper &amp;&amp; systemctl <span class="built_in">enable</span> mesos-master &amp;&amp; systemctl <span class="built_in">enable</span> marathon</span><br><span class="line">systemctl start zookeeper &amp;&amp; systemctl start mesos-master &amp;&amp; systemctl start marathon</span><br></pre></td></tr></table></figure></li>
<li><p>启动marathon的时候报错：未指定master。<br>解决办法：在启动marathon的时候指定master和zk，即进入<code>/usr/lib/systemd/system/marathon.service</code>，修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ExecStart=/usr/share/marathon/bin/marathon \</span><br><span class="line">--master zk://172.0.0.1:2181,172.0.0.2:2181,172.0.0.3:2181/mesos \</span><br><span class="line">--zk zk://172.0.0.1:2181,172.0.0.2:2181,172.0.0.3:2181/marathon</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start marathon</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Mesos-slave节点"><a href="#Mesos-slave节点" class="headerlink" title="Mesos-slave节点"></a>Mesos-slave节点</h3><p>这里使用全部四个节点作为mesos-slave，配置如下：</p>
<ul>
<li>关闭selinux<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;/SELINUX/s/enforcing/disabled/&#x27;</span> /etc/selinux/config</span><br><span class="line">setenforce 0</span><br></pre></td></tr></table></figure></li>
<li>关闭防火墙<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service</span><br></pre></td></tr></table></figure></li>
<li>添加mesos的yum源<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -Uvh http://repos.mesosphere.io/el/7/noarch/RPMS/mesosphere-el-repo-7-1.noarch.rpm</span><br></pre></td></tr></table></figure></li>
<li>安装Mesos1.5.0<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y mesos</span><br></pre></td></tr></table></figure></li>
<li>将IP写入<code>/etc/mesos-slave/hostname</code>中：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">master1: <span class="built_in">echo</span> 172.0.0.1 &gt; /etc/mesos-slave/hostname</span><br><span class="line">agent1: <span class="built_in">echo</span> 172.0.0.2 &gt; /etc/mesos-slave/hostname</span><br><span class="line">agent2: <span class="built_in">echo</span> 172.0.0.3 &gt; /etc/mesos-slave/hostname</span><br><span class="line">agent3: <span class="built_in">echo</span> 172.0.0.4 &gt; /etc/mesos-slave/hostname</span><br></pre></td></tr></table></figure></li>
<li>配置Mesos<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> zk://172.0.0.1:2181,172.0.0.2:2181,172.0.0.3:2181/mesos /etc/mesos/zk</span><br></pre></td></tr></table></figure></li>
<li>配置marathon调用mesos运行docker容器<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;docker,mesos&#x27;</span> &gt; /etc/mesos-slave/containerizers</span><br></pre></td></tr></table></figure></li>
<li>启动slave<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> mesos-slave &amp;&amp; systemctl start mesos-slave</span><br></pre></td></tr></table></figure>
除了master1节点外，其余节点分别执行：<code>systemctl disable mesos-master</code></li>
</ul>
<h3 id="遇到的问题：-1"><a href="#遇到的问题：-1" class="headerlink" title="遇到的问题："></a>遇到的问题：</h3><p>  <code>Mesos-slave：Failed to perform recovery: Incompatible agent info detected.</code>通过<code>journalctl -xe</code>查看log，提示<br>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">To restart this agent with a new agent id instead, <span class="keyword">do</span> as follows:</span><br><span class="line">4月 03 19:13:30 iZbp194ugtbu9s8ct8lt3eZ mesos-slave[1542]: rm -f /var/mesos/meta/slaves/latest</span><br><span class="line">4月 03 19:13:30 iZbp194ugtbu9s8ct8lt3eZ mesos-slave[1542]: This ensures that the agent does not recover old live executors.</span><br></pre></td></tr></table></figure><br>  执行<code>rm -f /var/mesos/meta/slaves/latest</code>，重启mesos-slave即可</p>
<h2 id="安装并配置Etcd3-2-15"><a href="#安装并配置Etcd3-2-15" class="headerlink" title="安装并配置Etcd3.2.15"></a>安装并配置Etcd3.2.15</h2><h3 id="安装etcd"><a href="#安装etcd" class="headerlink" title="安装etcd"></a>安装etcd</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install etcd -y</span><br></pre></td></tr></table></figure>
<h3 id="配置etcd"><a href="#配置etcd" class="headerlink" title="配置etcd"></a>配置etcd</h3><ul>
<li><p>修改etcd默认配置文件/etc/etcd/etcd.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">master1节点：</span><br><span class="line"><span class="comment">#[Member]</span></span><br><span class="line">ETCD_DATA_DIR=<span class="string">&quot;/var/lib/etcd/default.etcd&quot;</span></span><br><span class="line">ETCD_LISTEN_PEER_URLS=<span class="string">&quot;http://0.0.0.0:2380&quot;</span></span><br><span class="line">ETCD_LISTEN_CLIENT_URLS=<span class="string">&quot;http://0.0.0.0:2379,http://0.0.0.0:4001&quot;</span></span><br><span class="line">ETCD_NAME=<span class="string">&quot;master1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#[Clustering]</span></span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS=<span class="string">&quot;http://master1:2380&quot;</span>、</span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS=<span class="string">&quot;http://master1:2379,http://master1:4001&quot;</span></span><br><span class="line">ETCD_INITIAL_CLUSTER=<span class="string">&quot;master1=http://master1:2380,agent1=http://agent1:2380,agent2=http://agent2:2380,agent3=http://agent3:2380&quot;</span></span><br><span class="line">ETCD_INITIAL_CLUSTER_TOKEN=<span class="string">&quot;mritd-etcd-cluster&quot;</span></span><br><span class="line">ETCD_INITIAL_CLUSTER_STATE=<span class="string">&quot;new&quot;</span></span><br><span class="line"></span><br><span class="line">agent1节点：</span><br><span class="line"><span class="comment">#[Member]</span></span><br><span class="line">ETCD_DATA_DIR=<span class="string">&quot;/var/lib/etcd/default.etcd&quot;</span></span><br><span class="line">ETCD_LISTEN_PEER_URLS=<span class="string">&quot;http://0.0.0.0:2380&quot;</span></span><br><span class="line">ETCD_LISTEN_CLIENT_URLS=<span class="string">&quot;http://0.0.0.0:2379,http://0.0.0.0:4001&quot;</span></span><br><span class="line">ETCD_NAME=<span class="string">&quot;agent1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#[Clustering]</span></span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS=<span class="string">&quot;http://agent1:2380&quot;</span></span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS=<span class="string">&quot;http://agent1:2379,http://agent1:4001&quot;</span></span><br><span class="line">ETCD_INITIAL_CLUSTER=<span class="string">&quot;master1=http://master1:2380,agent1=http://agent1:2380,agent2=http://agent2:2380,agent3=http://agent3:2380&quot;</span></span><br><span class="line">ETCD_INITIAL_CLUSTER_TOKEN=<span class="string">&quot;mritd-etcd-cluster&quot;</span></span><br><span class="line">ETCD_INITIAL_CLUSTER_STATE=<span class="string">&quot;new&quot;</span></span><br><span class="line"></span><br><span class="line">agent2节点：</span><br><span class="line"><span class="comment">#[Member]</span></span><br><span class="line">ETCD_DATA_DIR=<span class="string">&quot;/var/lib/etcd/default.etcd&quot;</span></span><br><span class="line">ETCD_LISTEN_PEER_URLS=<span class="string">&quot;http://0.0.0.0:2380&quot;</span></span><br><span class="line">ETCD_LISTEN_CLIENT_URLS=<span class="string">&quot;http://0.0.0.0:2379,http://0.0.0.0:4001&quot;</span></span><br><span class="line">ETCD_NAME=<span class="string">&quot;agent2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#[Clustering]</span></span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS=<span class="string">&quot;http://agent2:2380&quot;</span></span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS=<span class="string">&quot;http://agent2:2379,http://agent2:4001&quot;</span></span><br><span class="line">ETCD_INITIAL_CLUSTER=<span class="string">&quot;master1=http://master1:2380,agent1=http://agent1:2380,agent2=http://agent2:2380,agent3=http://agent3:2380&quot;</span></span><br><span class="line">ETCD_INITIAL_CLUSTER_TOKEN=<span class="string">&quot;mritd-etcd-cluster&quot;</span></span><br><span class="line">ETCD_INITIAL_CLUSTER_STATE=<span class="string">&quot;new&quot;</span></span><br><span class="line"></span><br><span class="line">agent3节点：</span><br><span class="line"><span class="comment">#[Member]</span></span><br><span class="line">ETCD_DATA_DIR=<span class="string">&quot;/var/lib/etcd/default.etcd&quot;</span></span><br><span class="line">ETCD_LISTEN_PEER_URLS=<span class="string">&quot;http://0.0.0.0:2380&quot;</span></span><br><span class="line">ETCD_LISTEN_CLIENT_URLS=<span class="string">&quot;http://0.0.0.0:2379,http://0.0.0.0:4001&quot;</span></span><br><span class="line">ETCD_NAME=<span class="string">&quot;agent3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#[Clustering]</span></span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS=<span class="string">&quot;http://agent3:2380&quot;</span></span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS=<span class="string">&quot;http://agent3:2379,http://agent3:4001&quot;</span></span><br><span class="line">ETCD_INITIAL_CLUSTER=<span class="string">&quot;master1=http://master1:2380,agent1=http://agent1:2380,agent2=http://agent2:2380,agent3=http://agent3:2380&quot;</span></span><br><span class="line">ETCD_INITIAL_CLUSTER_TOKEN=<span class="string">&quot;mritd-etcd-cluster&quot;</span></span><br><span class="line">ETCD_INITIAL_CLUSTER_STATE=<span class="string">&quot;new&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>修改/usr/lib/systemd/system/etcd.service:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">所有四个节点：</span><br><span class="line">[Unit]</span><br><span class="line">Description=Etcd Server</span><br><span class="line">After=network.target</span><br><span class="line">After=network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">WorkingDirectory=/var/lib/etcd/</span><br><span class="line">EnvironmentFile=-/etc/etcd/etcd.conf</span><br><span class="line">User=etcd</span><br><span class="line"><span class="comment"># set GOMAXPROCS to number of processors</span></span><br><span class="line">ExecStart=/bin/bash -c <span class="string">&quot;GOMAXPROCS=<span class="subst">$(nproc)</span> /usr/bin/etcd --name=\&quot;<span class="variable">$&#123;ETCD_NAME&#125;</span>\&quot; \</span></span><br><span class="line"><span class="string">--data-dir=\&quot;<span class="variable">$&#123;ETCD_DATA_DIR&#125;</span>\&quot; \</span></span><br><span class="line"><span class="string">--listen-client-urls=\&quot;<span class="variable">$&#123;ETCD_LISTEN_CLIENT_URLS&#125;</span>\&quot; \</span></span><br><span class="line"><span class="string">--advertise-client-urls=\&quot;<span class="variable">$&#123;ETCD_ADVERTISE_CLIENT_URLS&#125;</span>\&quot; \</span></span><br><span class="line"><span class="string">--initial-advertise-peer-urls=\&quot;<span class="variable">$&#123;ETCD_INITIAL_ADVERTISE_PEER_URLS&#125;</span>\&quot; \</span></span><br><span class="line"><span class="string">--listen-peer-urls=\&quot;<span class="variable">$&#123;ETCD_LISTEN_PEER_URLS&#125;</span>\&quot; \</span></span><br><span class="line"><span class="string">--initial-cluster-token=\&quot;<span class="variable">$&#123;ETCD_INITIAL_CLUSTER_TOKEN&#125;</span>\&quot; \</span></span><br><span class="line"><span class="string">--initial-cluster=\&quot;<span class="variable">$&#123;ETCD_INITIAL_CLUSTER&#125;</span>\&quot; \</span></span><br><span class="line"><span class="string">--initial-cluster-state=\&quot;<span class="variable">$&#123;ETCD_INITIAL_CLUSTER_STATE&#125;</span>\&quot; \</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line">Restart=on-failure</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></li>
<li><p>开启etcd服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start etcd</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="遇到的问题：-2"><a href="#遇到的问题：-2" class="headerlink" title="遇到的问题："></a>遇到的问题：</h3><p><code>error verifying flags, --advertise-client-urls is required when --listen-client-urls is set explicitly. See &#39;etcd --help&#39;.</code>问题是–advertise-client-urls未指定。查看<code>/etc/etcd/etcd.cnf</code>发现<code>ETCD_ADVERTISE_CLIENT_URLS=&quot;http://master1:2379,http://master1:4001&quot;</code>写成了<code>ETCD_ADVERTISE_CLIENT_URLS=&quot;http://master1:2379,master1:4001&quot;</code>，应该加上<code>http://</code></p>
<h2 id="安装Calico"><a href="#安装Calico" class="headerlink" title="安装Calico"></a>安装Calico</h2><p>以下配置在每台机器上都需要完成。</p>
<ul>
<li>下载calicoctl二进制文件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -O /usr/<span class="built_in">local</span>/bin/calicoctl https://github.com/projectcalico/calicoctl/releases/download/v1.6.3/calicoctl</span><br><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/calicoctl</span><br></pre></td></tr></table></figure></li>
<li>开启calico/node<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="comment"># master1节点</span></span><br><span class="line">ETCD_ENDPOINTS=http://master1:<span class="number">2379</span> calicoctl node <span class="keyword">run</span><span class="bash"> --node-image=quay.io/calico/node:v2.6.8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># agent节点（使用自己搭建的registry仓库，下面将介绍如何搭建）</span></span><br><span class="line"><span class="comment"># 将&quot;insecure-registries&quot;:[&quot;master1:5000&quot;]写入/etc/docker/daemon.json</span></span><br><span class="line">ETCD_ENDPOINTS=http://master1:<span class="number">2379</span> calicoctl node <span class="keyword">run</span><span class="bash"> --node-image=master1:5000/calico/node:v2.6.8</span></span><br></pre></td></tr></table></figure>

检查calico/node是否运行：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID  IMAGE                        COMMAND         CREATED        STATUS       PORTS     NAMES</span><br><span class="line">7cfe445e5d58  quay.io/calico/node:v2.6.8   <span class="string">&quot;start_runit&quot;</span>   26 hours ago   Up 26 hours            calico-node</span><br><span class="line"></span><br><span class="line"><span class="comment"># calicoctl node status</span></span><br><span class="line">Calico process is running.</span><br></pre></td></tr></table></figure>
对于agent节点，从后面搭建的docker registry拉取镜像。</li>
<li>配置CNI网络：<ul>
<li>设置环境变量<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># set cni network</span></span><br><span class="line"><span class="comment"># CNI configuration directory</span></span><br><span class="line"><span class="built_in">export</span> NETWORK_CNI_PLUGINS_DIR=/var/lib/mesos/cni/plugins</span><br><span class="line"><span class="comment"># CNI plugin directory</span></span><br><span class="line"><span class="built_in">export</span> NETWORK_CNI_CONF_DIR=/var/lib/mesos/cni/config</span><br></pre></td></tr></table></figure></li>
<li>下载Calico CNI插件到$NETWORK_CNI_PLUGINS_DIR<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -L -o <span class="variable">$NETWORK_CNI_PLUGINS_DIR</span>/calico \</span><br><span class="line">https://github.com/projectcalico/cni-plugin/releases/download/v1.11.4/calico</span><br><span class="line">curl -L -o <span class="variable">$NETWORK_CNI_PLUGINS_DIR</span>/calico-ipam \</span><br><span class="line">    https://github.com/projectcalico/cni-plugin/releases/download/v1.11.4/calico-ipam</span><br><span class="line">chmod +x <span class="variable">$NETWORK_CNI_PLUGINS_DIR</span>/calico</span><br><span class="line">chmod +x <span class="variable">$NETWORK_CNI_PLUGINS_DIR</span>/calico-ipam</span><br></pre></td></tr></table></figure></li>
<li>创建Calico CNI配置到$NETWORK_CNI_CONF_DIR<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &gt; <span class="variable">$NETWORK_CNI_CONF_DIR</span>/calico.conf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;name&quot;: &quot;calico&quot;,</span></span><br><span class="line"><span class="string">  &quot;cniVersion&quot;: &quot;0.1.0&quot;,</span></span><br><span class="line"><span class="string">  &quot;type&quot;: &quot;calico&quot;,</span></span><br><span class="line"><span class="string">  &quot;ipam&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;type&quot;: &quot;calico-ipam&quot;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  &quot;etcd_endpoints&quot;: &quot;http://master1:2379&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Docker Registry的搭建(后面由marathon运行docker registry，该步骤可忽略)<br>由于agent[1,2,3]不能出外网，故需要在master1节点上搭建docker registry。<ul>
<li>在master1节点上，执行<code>docker pull registry</code>拉取最新版docker registry镜像。</li>
<li>创建/data/registry/config.yml文件，写入一下内容，在创建registry后允许删除镜像<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="number">0.1</span></span><br><span class="line"><span class="attr">log:</span></span><br><span class="line">  <span class="attr">fields:</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">registry</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">delete:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">blobdescriptor:</span> <span class="string">inmemory</span></span><br><span class="line">  <span class="attr">filesystem:</span></span><br><span class="line">    <span class="attr">rootdirectory:</span> <span class="string">/var/lib/registry</span></span><br><span class="line"><span class="attr">http:</span></span><br><span class="line">  <span class="attr">addr:</span> <span class="string">:5000</span></span><br><span class="line">  <span class="attr">headers:</span></span><br><span class="line">    <span class="attr">X-Content-Type-Options:</span> [<span class="string">nosniff</span>]</span><br><span class="line"><span class="attr">health:</span></span><br><span class="line">  <span class="attr">storagedriver:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="string">10s</span></span><br><span class="line">    <span class="attr">threshold:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></li>
<li>创建/opt/data/registry目录用于挂载registry容器内部存储的镜像</li>
<li>运行registry<br>加入insecure-registries到/etc/docker/daemon.json中：<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;graph&quot;</span>: <span class="string">&quot;/mnt/docker-data&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;storage-driver&quot;</span>: <span class="string">&quot;overlay&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;insecure-registries&quot;</span>:[</span><br><span class="line">        <span class="string">&quot;master1:5000&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
运行registry，将registry容器命名为docker_registry<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -d -p 5000:5000 -v /opt/data/registry:/var/lib/registry  -v /data/registry/config.yml:/etc/docker/registry/config.yml --name docker_registry registry </span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Marathon运行Docker registry<ul>
<li>在/root/zhongchuang-cluster/marathon/registry.json文件中加入以下内容：<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;registry&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;cpus&quot;</span>: <span class="number">0.3</span>,</span><br><span class="line">  <span class="attr">&quot;mem&quot;</span>: <span class="number">100.0</span>,</span><br><span class="line">  <span class="attr">&quot;disk&quot;</span>: <span class="number">20000</span>,</span><br><span class="line">  <span class="attr">&quot;instances&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;constraints&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;hostname&quot;</span>,</span><br><span class="line">      <span class="string">&quot;CLUSTER&quot;</span>,</span><br><span class="line">      <span class="string">&quot;172.0.0.1&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;container&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;DOCKER&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;docker&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;image&quot;</span>: <span class="string">&quot;registry&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;privileged&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;volumes&quot;</span>:[</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;containerPath&quot;</span>:<span class="string">&quot;/var/lib/registry&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;hostPath&quot;</span>:<span class="string">&quot;/opt/data/registry&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;mode&quot;</span>:<span class="string">&quot;RW&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;containerPath&quot;</span>:<span class="string">&quot;/etc/docker/registry/config.yml&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;hostPath&quot;</span>:<span class="string">&quot;/data/registry/config.yml&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;mode&quot;</span>:<span class="string">&quot;RO&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;portMappings&quot;</span>: [</span><br><span class="line">      &#123; <span class="attr">&quot;containerPort&quot;</span>: <span class="number">5000</span>, <span class="attr">&quot;hostPort&quot;</span>: <span class="number">5000</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
/etc/docker/registry/config.yml为上一步创建的config.yml</li>
<li>执行<code>curl -X POST http://master1:8080/v2/apps -d@registry.json -H &quot;Conten-type:application/json&quot;</code>即在marathon上启动docker registry。</li>
<li>测试registry是否创建成功<ul>
<li><code>docker tag busybox master1:5000/busybox</code></li>
<li><code>docker push master1:5000/busybox</code></li>
<li>在agent1上执行：<code>docker pull master1:5000/busybox</code>成功。</li>
</ul>
</li>
</ul>
</li>
<li>Marathon运行Marathon-lb：<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;/system/marathon-lb&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;cmd&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">&quot;cpus&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;mem&quot;</span>: <span class="number">128</span>,</span><br><span class="line">  <span class="attr">&quot;disk&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;instances&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;constraints&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;hostname&quot;</span>,</span><br><span class="line">      <span class="string">&quot;CLUSTER&quot;</span>,</span><br><span class="line">      <span class="string">&quot;172.0.0.1&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;acceptedResourceRoles&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;*&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;container&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;DOCKER&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;volumes&quot;</span>: [],</span><br><span class="line">    <span class="attr">&quot;docker&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;image&quot;</span>: <span class="string">&quot;docker.io/mesosphere/marathon-lb&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;network&quot;</span>: <span class="string">&quot;HOST&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;privileged&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;parameters&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;forcePullImage&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;portDefinitions&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;port&quot;</span>: <span class="number">10000</span>,</span><br><span class="line">      <span class="attr">&quot;protocol&quot;</span>: <span class="string">&quot;tcp&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;labels&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;sse&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-m&quot;</span>,</span><br><span class="line">    <span class="string">&quot;http://master1:8080&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-m&quot;</span>,</span><br><span class="line">    <span class="string">&quot;http://agent1:8080&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-m&quot;</span>,</span><br><span class="line">    <span class="string">&quot;http://agent2:8080&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-m&quot;</span>,</span><br><span class="line">    <span class="string">&quot;http://agent3:8080&quot;</span>,</span><br><span class="line">    <span class="string">&quot;--group&quot;</span>,</span><br><span class="line">    <span class="string">&quot;external&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;healthChecks&quot;</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>遇到的问题：marathon前端一直显示waiting。解决方案是：<ul>
<li>mesos-slave上资源不够，一般是内存不够。可上mesos-master:5050上查看</li>
<li>宿主机上没有镜像，一直在拉或拉不到。上宿主机上查看: docker images | grep xxx，确保marathon上配置的镜像名和版本在宿主机上存在</li>
<li>marathon上属性Constraints中包含的主机名和/etc/mesos-slave/hostname的内容一样。一开始配置constraints的时候将172.0.0.1写成了master1，而/etc/mesos-slave/hostname写的是172.0.0.1</li>
<li>mesos-master数量有问题，正常情况应该是3个，至少需要是奇数。如果有多余启动的mesos-master，关掉服务并禁止启动</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="安装DC"><a href="#安装DC" class="headerlink" title="安装DC"></a>安装DC</h2><ul>
<li>遇到的问题：阿里云上haproxy/nginx反代到自己机子上的一个端口时，如果upstream用的公网ip，会被莫名的拦截，即使开了安全组。<ul>
<li>使用内网IP做反向代理的upstream就没问题。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Resource Management</category>
      </categories>
      <tags>
        <tag>marathon</tag>
        <tag>glusterfs</tag>
        <tag>docker</tag>
        <tag>mesos</tag>
        <tag>zookeeper</tag>
        <tag>calico</tag>
        <tag>docker registry</tag>
      </tags>
  </entry>
</search>
